# The theory and notations used in this file are documented in detail in the
# Bernstein bases algorithms Developper notes of the official documentation.

"""
    FEEC_space_definition_checks(::Val{D}, T, r, k, F, rotate_90)

Check if the argument define a valid Finite Element Exterior Calculus (FEEC) polynomial space,
as defined in the Periodic Table of the Finite Elements, `Fáµ£Î›áµ` in dimension `D`.

The arguments are also described in [`FEEC_poly_basis`](@ref).
"""
function FEEC_space_definition_checks(
  ::Val{D},::Type{T},r::Int,k::Int,F::Symbol, rotate_90::Bool=false, DG_calc::Bool=false
) where {D,T}

  @check T<:Real "T needs to be <:Real since represents the scalar type, got $T"
  @check F in (:Pâ»,:P,:Qâ»,:S) "F must be either :Pâ»,:P,:Qâ» or :S, got $F."
  @check k in 0:D "The form order k must be in 0:D, got k=$k and D=$D."
  @check r â‰¥ 0    "The polynomial order r must be positive, got $r."

  if DG_calc
    @notimplemented "A new MultiValue type and associated algebraic operations âˆ§/â‹†/ğ‘‘/Î´ need to be implemented to use form valued polynomials."
  elseif D>3 && ( 1 < k < D-1)
    @unreachable "Vector calculus proxy of differential form bases are only available for `k`=0,1,`D`-1 and `D`, got k=$k and D=$D."
  end

  if rotate_90 && !(!DG_calc && isone(k) && D==2)
    @warn """The `rotate_90` kwarg only makes sense for 2D vector proxied forms
              of degree 1, it will be ignored and may lead to errors.
              Got k=$k, D=$D for F=$F
          """
  end
  true
end

#############################
# BarycentricPÎ›Indices type #
#############################

# Do print some BarycentricPÎ›Indices generated by PÎ›_bubbles(r,k,D) in REPL before
# reading this...

# All types and fields "XX" below should be understood as "Indices_For_XX"

# One bubble function:
#               Ï‰_w  =      (  w,           Î±, Î±_id,           J,   sub_J_ids,  sup_Î±_ids )
const BubbleFunction = Tuple{Int, Vector{Int},  Int, Vector{Int}, Vector{Int}, Vector{Int}}

# One bubble space associated to the d-dimensional face F
# bubble_d_F =      (          F,    F_bubble_functions )
const Bubble = Tuple{Vector{Int}, Vector{BubbleFunction}}

"""
    struct BarycentricPÎ›Indices
      identity::UInt
      bubbles::Vector{Bubble}
      components::Vector{Tuple{ Int, Vector{Int}, Int}}
    end

For storing indices in `BarycentricP(m)Î›Basis`. The `bubbles` are generated by
[`PÎ›_bubbles`](@ref) or [`PmÎ›_bubbles`](@ref), the `components` by
[`_basis_forms_components`](@ref).
"""
struct BarycentricPÎ›Indices
  # An objectid is stored here to keep track of what's inside and perform a
  # sanity check when reusing the indices elsewhere:
  #     identity = objectid( (r,k,D,:P,false,false) )
  # for a Páµ£Î›áµ(â–³á´°) basis indices with vector-proxied components and rotate_90=false.
  identity::UInt

  # bubble indices given by P(m)Î›_bubbles (can be filtered and renumbered to select subset of bubbles)
  # The BubbleFunction[1] "w" MUST be in increasing order when iterating over bubbles and bubble_functions
  bubbles::Vector{Bubble}

  # Indices for the components of a basis k-form or its vector calculus proxy,
  #                       (I_id,           I, sgnIcomp), see _basis_forms_components .
  components::Vector{Tuple{ Int, Vector{Int},      Int}}

  # Components "I" of the exterior derivative of a basis polynomial form
  # ext_deriv_components::Vector{Component}
end

function _check_PÎ›_indices(r,k,D,F,DG_style, indices::BarycentricPÎ›Indices, rot_90)
  @check F âˆˆ (:P,:Pâ»)
  # Changing one of those requires re-computing all fields of BarycentricPÎ›Indices,
  # otherwise wrong result or segfault due to @inbounds in evaluating functions
  # are expected
  @assert objectid( (r,k,D,F,DG_style,rot_90) ) == indices.identity
  @check begin
    ordered_bf_ids = [ bubfun[1] for bub in indices.bubbles for bubfun in bub[2] ]
    C = length(ordered_bf_ids)
    ordered_bf_ids == 1:C
  end "Invalid BarycentricPÎ›Indices: bubble functions are not numbered from 1 to length(b) in the bubble indices"
end

"""
    _last_bubble_function_index(ids::BarycentricPÎ›Indices)

The index of the last bubble function in `ids`, that is also the number of basis
polynomial defined by `ids`, and cardinal of the owning basis.
"""
function _last_bubble_function_index(ids::BarycentricPÎ›Indices)
  isempty(ids.bubbles) && return 0
  return ids.bubbles[end][2][end][1]
end

function Base.show(io::IO, ::MIME"text/plain", indices::BarycentricPÎ›Indices)
  if isempty(indices.bubbles)
    print(io,"Empty PÎ› basis indices")
    return
  end

  Î± = indices.bubbles[1][2][1][2]
  J = indices.bubbles[1][2][1][4]
  I = indices.components[1][2]

  r = sum(Î±)+length(J)-length(I)
  k = length(I)
  D = length(Î±)-1
  is_Pm = r != sum(Î±)
  println(io,"Páµ£Î›áµ(â–³á´°) basis indices, r=$r k=$k D=$D")

  println(io)
  println(io,"Basis polynomial components")
  println(io,"\tI_id\t I\t I_sgn")
  for (I_id, I, I_sgn) in indices.components
    println(io,"\t$I_id\t $(join(I))\t $I_sgn")
  end

  println(io)
  println(io,"\tw \tÎ± \tÎ±_id \tJ",  is_Pm ? "\tsub_J_ids \tsup_Î±_ids" : "")
  for (F, F_bubble) in indices.bubbles
    isempty(F_bubble) && continue

    println(io,"Bubble of face F=$(join(F))")
    for (w, Î±, Î±_id, J, sub_J_ids, sup_Î±_ids) in F_bubble
      println(io,"\t$w \t$(join(Î±)) \t$Î±_id \t$(join(J)) \t$(join(sub_J_ids,",")) \t\t$(join(sup_Î±_ids,","))")
    end
  end
  println(io)
  println(io,"Páµ£Î›áµ(â–³á´°) basis indices, r=$r k=$k D=$D")
end


###########################################
# BarycentricPmÎ›Basis nD polynomial bases #
###########################################

"""
    BarycentricPmÎ›Basis{D,V,LN,B} <: PolynomialBasis{D,V,Bernstein}

Finite Element Exterior Calculus polynomial basis for the spaces Pâ»`áµ£`Î›`á´·` on
`D`-dimensional simplices, but with polynomial forms explicitely transformed
into vectors using the standard equivalence with usual vector calculus defined
in terms of the hodge star operator â‹† and the sharp map â™¯, see
[`_basis_forms_components`](@ref) (the simplex is assumed Euclidean).

- `V` is `VectorValue{L,T}` where `L` is binomial(`D`,`k`),
- `B` is the concrete type of the `BernsteinBasisOnSimplex` necessary for the evaluation of the polynomials.

The number of basis polynomials is binomial(`r`+`k`-1,`k`)*binomial(`D`+`r`,`D`-`k`) if no filtered bubble indices are given.

Reference: D.N. Arnold, R.S. Falk & R. Winther, Geometric decompositions and local bases for spaces of finite element differential forms, CMAME, 2009
"""
struct BarycentricPmÎ›Basis{D,V,LN,B} <: PolynomialBasis{D,V,Bernstein}
  r::Int
  k::Int
  scalar_bernstein_basis::B
  m::SVector{LN,V}
  _indices::BarycentricPÎ›Indices

  function BarycentricPmÎ›Basis{D}(::Type{T}, r, k, vertices=nothing;
        DG_calc=false, indices=nothing, rotate_90=false) where {D,T}

    FEEC_space_definition_checks(Val(D), T, r, k, :Pâ», rotate_90, DG_calc)
    _simplex_vertices_checks(Val(D), vertices)

    indices = _generate_or_check_PmÎ›_indices(r,k,D,DG_calc,indices,rotate_90)

    L = binomial(D,k) # Number of components of a basis form
    V = VectorValue{L,T} # To update once DG_calc is implemented

    b = BernsteinBasisOnSimplex{D}(T, r, vertices)
    B = typeof(b)
    LN = binomial(D+1,k) # Number of k-faces J of a D-dimensional tetrahedron
    m = zero(MVector{LN,V})
    _compute_PmÎ›_basis_coefficients!(m,Val(k),D,b,vertices,indices)

    if isone(L) && !DG_calc
      V = T
      m = reinterpret(T, m)
    end

    new{D,V,LN,B}(r,k,b,m,indices)
  end

  @doc """
      BarycentricPmÎ›Basis(b::BarycentricPmÎ›Basis, faces::Vector{Int}...)

  Create a new basis which is `b` restricted to the bubble spaces for F âˆˆ `faces`.
  """
  function BarycentricPmÎ›Basis(_b::BarycentricPmÎ›Basis{D,V,LN,B}, faces::Vector{Int}...) where {D,V,LN,B}
    # Notation:â€¯_old, new
    _indices = _b._indices
    _bubbles = _indices.bubbles
    bubbles = similar(_bubbles, length(faces))

    w = 1
    for (Fid, F) in enumerate(faces)
      F_id = findfirst(bub -> bub[1] == F, _bubbles)
      @assert !isnothing(F_id) "No bubble associated to face $F in the given basis"

      _F_bubfuns = _bubbles[F_id][2]
      F_bubfuns = similar(_F_bubfuns)
      for (i, _fun) in enumerate(_F_bubfuns)
        # re-use all Î±,J, etc... to minimise allocation, just change w
        F_bubfuns[i] = (w, _fun[2:end]...)
        w += 1
      end
      bubbles[Fid] = (F, F_bubfuns)
    end

    indices = BarycentricPÎ›Indices(_indices.identity, bubbles, _indices.components)
    new{D,V,LN,B}(_b.r, _b.k, _b.scalar_bernstein_basis, _b.m, indices)
  end

  function BarycentricPmÎ›Basis{D,V,LN,B}() where {D,V,LN,B} # just for testvalue
    indices = _generate_or_check_PmÎ›_indices(1,0,0,false,nothing,false)
    new{D,V,LN,B}(0,0,testvalue(B),zero(SVector{LN,V}),indices)
  end
end

"""
    BarycentricPmÎ›Basis(::Val{D}, T, r, k, vertices=nothing; kwargs...)

Constructors for [`BarycentricPmÎ›Basis`](@ref) of scalar type `T`.
If `vertices` are specified, they must define a non-degenerate simplex, c.f. [`BernsteinBasisOnSimplex`](@ref).

The kwargs are the following:
- `indices::BarycentricPÎ›Indices = nothing`: may be provided to avoid allocations of new indices, or to select specific bubbles spaces,
- `DG_calc = false`: set to `true` to choose `k`-form valued polynomials instead of vector valued polynomials (not implemented yet),
- `rotate_90 = false`: In 2`D` for `k`=1, `true` to apply a 90Â° rotation of the vector proxied polynomials ((x,y) -> (-y,x)), needed for Raviart-Thomas/BDM.
"""
function BarycentricPmÎ›Basis(::Val{D},::Type{T},r,k,vertices=nothing; kwargs...) where {D,T}
  BarycentricPmÎ›Basis{D}(T,r,k,vertices; kwargs...)
end

#get_FEEC_poly_degree(b::BarycentricPmÎ›Basis) = b.r
#get_FEEC_form_degree(b::BarycentricPmÎ›Basis) = b.k
#get_FEEC_family(::BarycentricPmÎ›Basis) = :Pâ»

Base.size(b::BarycentricPmÎ›Basis) = (_last_bubble_function_index(b._indices), )

function testvalue(::Type{BarycentricPmÎ›Basis{D,V,LN,B}}) where {D,V,LN,B}
  BarycentricPmÎ›Basis{D,V,LN,B}()
end

##########################################
# BarycentricPÎ›Basis nD polynomial bases #
##########################################

"""
    BarycentricPÎ›Basis{D,V,C,B} <: PolynomialBasis{D,V,Bernstein}

Finite Element Exterior Calculus polynomial basis for the spaces P`áµ£`Î›`á´·` on
`D`-dimensional simplices, but with polynomial forms explicitely transformed
into vectors using the standard equivalence with usual vector calculus defined
in terms of the hodge star operator â‹† and the sharp map â™¯, see
[`_basis_forms_components`](@ref) (the simplex is assumed Euclidean).

- `V` is `VectorValue{L,T}` where `L=binomial(D,k)`,
- `C` is the number of basis polynomials,
- `B` is the concrete type of the `BernsteinBasisOnSimplex` necessary for the evaluation of the polynomials.

`C` = binomial(`r`+`k`,`k`)*binomial(`D`+`r`,`D`-`k`) if no custom bubble indices are given.

Reference: D.N. Arnold, R.S. Falk & R. Winther, Geometric decompositions and local bases for spaces of finite element differential forms, CMAME, 2009
"""
struct BarycentricPÎ›Basis{D,V,C,B} <: PolynomialBasis{D,V,Bernstein}
  r::Int
  k::Int
  scalar_bernstein_basis::B
  Î¨::SVector{C,V}
  _indices::BarycentricPÎ›Indices

  function BarycentricPÎ›Basis{D}(::Type{T}, r, k, vertices=nothing;
        DG_calc=false, indices=nothing, rotate_90=false) where {D,T}

    FEEC_space_definition_checks(Val(D), T, r, k, :Pâ», rotate_90, DG_calc)
    _simplex_vertices_checks(Val(D), vertices)

    indices = _generate_or_check_PÎ›_indices(r,k,D,DG_calc,indices,rotate_90)

    L = binomial(D,k) # Number of components of a basis form
    V = VectorValue{L,T} # To update once DG_calc is implemented
    C = _last_bubble_function_index(indices) # Cardinal of the basis

    b = BernsteinBasisOnSimplex{D}(T, r, vertices)
    B = typeof(b)
    Î¨ = zero(MVector{C,V})
    _compute_PÎ›_basis_form_coefficient!(Î¨,r,k,Val(D),b,vertices,indices)

    if isone(L) && !DG_calc
      V = T
      Î¨ = reinterpret(T, Î¨)
    end

    new{D,V,C,B}(r,k,b,Î¨,indices)
  end

  @doc """
      BarycentricPÎ›Basis(b::BarycentricPÎ›Basis, faces::Vector{Int}...)

  Create a new basis which is `b` restricted to the bubble spaces for F âˆˆ `faces`.
  The faces are represented by some `Vector{Int}` of their vertices ids, like in
  [`BarycentricPÎ›Indices`](@ref).
  """
  function BarycentricPÎ›Basis(_b::BarycentricPÎ›Basis{D,V,_C,B}, faces::Vector{Int}...) where {D,V,_C,B}
    # Notation:â€¯_old, new
    _indices = _b._indices
    _bubbles = _indices.bubbles
    _Î¨ = _b.Î¨

    bubbles = similar(_bubbles, length(faces))
    Î¨ = zero(MVector{_C,V}) # cache of maximum possible size
    w = 1

    for (Fid, F) in enumerate(faces)
      F_id = findfirst(bub -> bub[1] == F, _bubbles)
      @assert !isnothing(F_id) "No bubble associated to face $F in the given basis"

      _F_bubfuns = _bubbles[F_id][2]
      F_bubfuns = similar(_F_bubfuns)
      for (i, _fun) in enumerate(_F_bubfuns)
        # re-use all Î±,J, etc... to minimise allocation, just change w
        (_w, _fun_ids...) = _fun
        F_bubfuns[i] = (w, _fun_ids...)
        Î¨[w] = _Î¨[_w]
        w += 1
      end
      bubbles[Fid] = (F, F_bubfuns)
    end

    C = w-1
    Î¨ = SVector{C,V}( Î¨[1:C] )
    indices = BarycentricPÎ›Indices(_indices.identity, bubbles, _indices.components)
    new{D,V,C,B}(_b.r, _b.k, _b.scalar_bernstein_basis, Î¨, indices)
  end

  function BarycentricPÎ›Basis{D,V,C,B}() where {D,V,C,B} # Just for testvalue
    indices = _generate_or_check_PÎ›_indices(1,0,0,false,nothing,false)
    new{D,V,C,B}(0,0,testvalue(B),zero(SVector{C,V}),indices)
  end
end

"""
    BarycentricPÎ›Basis(::Val{D}, T, r, k, vertices=nothing; kwargs...)

Constructors for [`BarycentricPÎ›Basis`](@ref) of scalar type `T`.
If `vertices` are specified, they must define a non-degenerate simplex, c.f. [`BernsteinBasisOnSimplex`](@ref).

The kwargs are the following:
- `indices::BarycentricPÎ›Indices = nothing`: may be provided to avoid allocations of new indices, or to select specific bubbles spaces,
- `DG_calc = false`: set to `true` to choose `k`-form valued polynomials instead of vector valued polynomials (not implemented yet),
- `rotate_90 = false`: In 2`D` for `k`=1, `true` to apply a 90Â° rotation of the vector proxied polynomials ((x,y) -> (-y,x)), needed for Raviart-Thomas/BDM.
"""
function BarycentricPÎ›Basis(::Val{D},::Type{T},r,k,vertices=nothing; kwargs...) where {D,T}
  BarycentricPÎ›Basis{D}(T,r,k,vertices; kwargs...)
end

#get_FEEC_poly_degree(b::BarycentricPÎ›Basis) = b.r
#get_FEEC_form_degree(b::BarycentricPÎ›Basis) = b.k
#get_FEEC_family(::BarycentricPÎ›Basis) = :P

Base.size(::BarycentricPÎ›Basis{D,V,C}) where {D,V,C} = (C, )

function testvalue(::Type{BarycentricPÎ›Basis{D,V,C,B}}) where {D,V,C,B}
  BarycentricPÎ›Basis{D,V,C,B}()
end

##########################
# Common Implementation  #
##########################

const _BaryPÎ›Basis = Union{BarycentricPmÎ›Basis, BarycentricPÎ›Basis}

"""
    get_bubbles(b::BarycentricPmÎ›Basis)
    get_bubbles(b::BarycentricPÎ›Basis)

Get the iterator over the bubble spaces in the geometric decomposition of `b`,
typically generated by [`PmÎ›_bubbles`](@ref) or [`PÎ›_bubbles`](@ref).

They can be vizualized using [`print_indices(b)`](@ref print_indices).
"""
get_bubbles(b::_BaryPÎ›Basis) = b._indices.bubbles
get_order(b::_BaryPÎ›Basis) = b.r

"""
    print_indices(b::BarycentricPmÎ›Basis, out=stdout)
    print_indices(b::BarycentricPÎ›Basis,  out=stdout)

Prints the indices of `b` in a user friendly format into `out`.
"""
print_indices(b::_BaryPÎ›Basis, out=stdout) = show(out, MIME"text/plain"(), b._indices)

_get_cart_to_bary_matrix(b::_BaryPÎ›Basis) = b.scalar_bernstein_basis.cart_to_bary_matrix

function _return_cache(b::_BaryPÎ›Basis,x,::Type{G},::Val{N_deriv}) where {G,N_deriv}
  T = eltype(G)
  np = length(x)
  ndof = length(b)
  ndof_bernstein = length(b.scalar_bernstein_basis)

  r = CachedArray(zeros(G,(np,ndof)))
  # Cache for all scalar nD-Bernstein polynomials BÎ±
  cB = CachedVector(zeros(T,ndof_bernstein))
  # Cache for derivatives of BÎ± (âˆ‡BÎ± or HBÎ±)
  if N_deriv > 0
    DB = T
    xi = testitem(x)
    for _ in 1:N_deriv
      DB = gradient_type(DB,xi)
    end
    # Cache for N_deriv's derivatives all of scalar nD-Bernstein polynomials
    t = (( nothing for _ in 2:N_deriv)..., CachedArray(zeros(DB,(1,ndof_bernstein))))
    s = MArray{Tuple{size(DB)...},T}(undef)
  else
    t = ()
    s = nothing
  end
  (r, s, cB, t...)
end

function _setsize!(b::_BaryPÎ›Basis, np, Ï‰, t...)
  ndof = length(b)
  ndof_bernstein = length(b.scalar_bernstein_basis)
  setsize!(Ï‰,(np,ndof))
  setsize!(t[1],(ndof_bernstein,)) # this is cB
  if length(t) > 1
    setsize!(t[end],(1,ndof_bernstein)) # this is âˆ‡B or HB
  end
end

function _get_static_parameters(b::_BaryPÎ›Basis)
  r = get_order(b)
  return Val(r)
end

"""
    _basis_forms_components(D,k,DG_style,rotate_90)

If `DG_style==true`, return the triples (`I_id`, `I`, 1) for each D-dimensional
k-form components dxá´µ = dxá´µÂ¹ âˆ§ dxá´µÂ² âˆ§ ... âˆ§ dxá´µáµ where `I` is a combination of
1:`D` and `I_id = _combination_index(I)`. The triples are ordered like in
[`_sorted_combinations`](@ref) (`I_id` increasing).

If `DG_style`==false, the indices are changed to implement the vector proxy of
the differential forms Ï‰ defined by:
- Ï‰â™¯    if `k` = 0 or 1
- (â‹†Ï‰)â™¯ if `k` = `D`-1 or `D` and `k`>1
where â‹† is the hodge star operator and â™¯ the sharp map.

The triples become (`I_proxy_id`, `I`, `I_proxy_sgn`) with the same `I` (and in
the same order), such that the components of the vector proxy v of a `k`-form Ï‰ are

    v[I_proxy_id] = I_proxy_sgn * Ï‰[I_id]

If `k` âˆˆ {0,1,`D`}, the proxy is trivial. If `k`=`D`-1, â™¯ reverses the
components order and â‹† adds signs 1, -1, 1, -1 ...

If `rotate_90` is `true` and `k` is `1`, the (â‹†Ï‰)â™¯ proxy is applied instead of Ï‰â™¯.
"""
function _basis_forms_components(D,k,DG_style,rot_90)
  components = Vector{Tuple{ Int, Vector{Int}, Int}}(undef, binomial(D,k))
  for (I_id, I) in enumerate(_sorted_combinations(D,k))
    # The rotation for 2D Raviart-Thomas/BDM is actually considering k to be D-1
    # rather than 1, that is applying â‹†.
    if DG_style || iszero(k) || isone(k) && !rot_90
      components[I_id] = (I_id, I, 1)
    else # if k == D, I = [1:D] and this is just (1, [], 1) (but that works)
      Icomp = _complement(I, D)
      Istar_id = _combination_index(Icomp)
      Istar_sgn = _combination_sign(I)
      components[I_id] = (Istar_id, I, Istar_sgn)
    end
  end
  components
end


######################################
# BarycentricPmÎ›Basis Implementation #
######################################

function _generate_or_check_PmÎ›_indices(r,k,D,DG_style,::Nothing,rot_90)
  identity = objectid( (r,k,D,:Pâ»,DG_style,rot_90) )
  bubbles = PmÎ›_bubbles(r,k,D)
  components = _basis_forms_components(D,k,DG_style,rot_90)
  return BarycentricPÎ›Indices(identity,bubbles,components)
end

function _generate_or_check_PmÎ›_indices(r,k,D,DG_style,indices::BarycentricPÎ›Indices,rot_90)
  _check_PÎ›_indices(r,k,D,:Pâ»,DG_style,indices,rot_90)
  return indices
end

function _PmÎ›_F_bubble_functions(r,k,D,F,w)
  N = D + 1
  ids = BubbleFunction[]
  for Î± in bernstein_terms(r-1,D)
    sup_Î±_ids = _sup_multi_indices(Î±)
    for J in _sorted_combinations(N,k+1)
      sub_J_ids = _sub_combinations_ids(J)
      j = _minimum_or_one(J)-1
      if issetequal(_support(Î±) âˆª J, F) && all(Î±[1:j] .== 0)
        w += 1
        Î±_id = bernstein_term_id(Î±)
        push!(ids, (w, Î±, Î±_id, J, sub_J_ids, sup_Î±_ids))
      end
    end
  end
  ids
end

"""
    PmÎ›_bubbles(r,k,D)

Generates the indices caracterizing the basis function of `BarycentricPmÎ›Basis`,
described in the Bernstein bases algorithm Developper notes of the official
documentation, and are used as follows:

    for (F, bubble_functions) in PmÎ›_bubbles(r,k,D)
      for (w, Î±, Î±_id, J, sub_J_ids, sup_Î±_ids) in bubble_functions
        # ...
      end
    end
"""
function PmÎ›_bubbles(r,k,D)
  w=0
  bubbles = Bubble[]
  for d in k:D
    for F in _sorted_combinations(D+1, d+1)
      bubble_functions = _PmÎ›_F_bubble_functions(r,k,D,F,w)
      isempty(bubble_functions) && continue
      push!(bubbles, (F, bubble_functions))
      w += length(bubble_functions)
    end
  end
  @check w == binomial(r+k-1,k)*binomial(D+r,D-k)
  bubbles
end

function _compute_PmÎ›_basis_coefficients!(m,::Val{k},D,b,vertices,indices) where k
  V = eltype(m)
  M = transpose(b.cart_to_bary_matrix[:,2:end])
  m_J = Mutable(V)(undef)
  @inbounds for (J_id, J) in enumerate(_sorted_combinations(D+1,k))
    for (I_id, I, I_sgn) in indices.components
      m_J[I_id] = I_sgn * _minor(M,I,J,Val(k))
    end
    m[J_id] = m_J
  end
  nothing
end

function _compute_PmÎ›_basis_coefficients!(
  m,::Val{k},D,b,vertices::Nothing,indices) where k

  if iszero(k) # so V is scalar, no change of basis
    m .= 1
    return nothing
  end

  V = eltype(m)
  m_J = Mutable(V)(undef)
  @inbounds for (J_id, J) in enumerate(_sorted_combinations(D+1,k))
    s = Int(isone(J[1]))
    for (I_id, I, I_sgn) in indices.components
      n = count(i-> (J[i]-1)âˆ‰I, (1+s):k)
      if iszero(n)
        p = _findfirst_val_or_zero(j-> (I[j]+1)âˆ‰J, 1, k)
        m_J[I_id] = I_sgn*_minusone_if_even_else_one(p+1)
      else
        m_J[I_id] = 0
      end
    end
    m[J_id] = m_J
  end
  nothing
end

# API

function _evaluate_nd!(
  b::BarycentricPmÎ›Basis{D}, x,
  Ï‰::AbstractMatrix, i, cB,
  ::Val{r}) where {D,r}

  V = eltype(Ï‰)
  Î» = _cart_to_bary(x, _get_cart_to_bary_matrix(b))

  # _evaluate_nd!(::BernsteinBasisOnSimplex) without set_value
  cB[1] = 1
  _downwards_de_Casteljau_nD!(cB,Î»,Val(r-1),Val(D))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Î±_id, J, sub_J_ids) in bubble_functions
      BÎ± = cB[Î±_id]
      Ï‰_w = zero(V)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Î»_j = Î»[J[l]]
        m_J_l = b.m[J_sub_Jl_id]

        Ï‰_w += flipsign(Î»_j,sgnl) * m_J_l
      end

      Ï‰[i,w] = BÎ± * Ï‰_w
    end
  end
end

function _gradient_nd!(
  b::BarycentricPmÎ›Basis{D}, x,
  âˆ‡Ï‰::AbstractMatrix{G}, i, cB,
  âˆ‡B::AbstractMatrix{<:VectorValue{D}},
  s::MVector{D},
  ::Val{r}) where {D,G,r}

  _gradient_nd!(b.scalar_bernstein_basis, x, âˆ‡B, 1, cB, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, Î±, _, J, sub_J_ids, sup_Î±_ids) in bubble_functions
      âˆ‡Ï‰_w = zero(G)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Jl = J[l]
        Î±_pJl_id = sup_Î±_ids[Jl]

        âˆ‡BÎ±_pJl = âˆ‡B[1,Î±_pJl_id]
        c_Î±_Jl = (Î±[Jl]+1) * sgnl / r
        m_J_l = b.m[J_sub_Jl_id]

        âˆ‡Ï‰_w += (c_Î±_Jl * âˆ‡BÎ±_pJl) âŠ— m_J_l
      end

      âˆ‡Ï‰[i,w] = âˆ‡Ï‰_w
    end
  end
end

function _hessian_nd!(
  b::BarycentricPmÎ›Basis{D}, x,
  HÏ‰::AbstractMatrix{G}, i, cB,
  ::Nothing,
  HB::AbstractMatrix{<:TensorValue{D,D}},
  s::MMatrix{D,D},
  ::Val{r}) where {D,G,r}

  _hessian_nd!(b.scalar_bernstein_basis, x, HB, 1, cB, nothing, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, Î±, _, J, sub_J_ids, sup_Î±_ids) in bubble_functions
      HÏ‰_w = zero(G)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Jl = J[l]
        Î±_pJl_id = sup_Î±_ids[Jl]

        HB_Î±Jl = HB[1,Î±_pJl_id]
        c_Î±Jl = (Î±[Jl]+1) * sgnl / r
        m_Jl = b.m[J_sub_Jl_id]

        HÏ‰_w += (c_Î±Jl * HB_Î±Jl) âŠ— m_Jl
      end

      HÏ‰[i,w] = HÏ‰_w
    end
  end
end


#####################################
# BarycentricPÎ›Basis Implementation #
#####################################

function _generate_or_check_PÎ›_indices(r,k,D,DG_style,::Nothing,rot_90)
  identity = objectid( (r,k,D,:P,DG_style,rot_90) )
  bubbles = PÎ›_bubbles(r,k,D)
  components = _basis_forms_components(D,k,DG_style,rot_90)
  return BarycentricPÎ›Indices(identity,bubbles,components)
end

function _generate_or_check_PÎ›_indices(r,k,D,DG_style,indices::BarycentricPÎ›Indices,rot_90)
  _check_PÎ›_indices(r,k,D,:P,DG_style,indices,rot_90)
  return indices
end

function _PÎ›_F_bubble_functions(r,k,D,F,w)
  N = D + 1
  bubble_functions = BubbleFunction[]
  empty_vec = Int[]
  for Î± in bernstein_terms(r,D)
    for J in _sorted_combinations(N,k)
      j = _minimum_or_one(setdiff(F,J))-1
      if issetequal(_support(Î±) âˆª J, F) && all(Î±[1:j] .== 0)
        w += 1
        Î±_id = bernstein_term_id(Î±)
        push!(bubble_functions, (w, Î±, Î±_id, J, empty_vec, empty_vec))
      end
    end
  end
  bubble_functions
end

"""
    PÎ›_bubbles(r,k,D)

Generates the indices caracterizing the basis function of `BarycentricPÎ›Basis`,
described in the Bernstein bases algorithm Developper notes of the official
documentation, and are used as follows:

    for (F, bubble_functions) in PÎ›_bubbles(r,k,D)
      for (w, Î±, Î±_id, J) in bubble_functions
        # ...
      end
    end
"""
function PÎ›_bubbles(r,k,D)
  bubbles = Bubble[]
  if r == 0
    F = [1:(D+1)...]
    Î± = zeros(Int,D+1)
    bubble_functions = BubbleFunction[]
    for i in 1:binomial(D,k)
      push!(bubble_functions, (i, Î±, 1, [], [], [])) # J has no meaning there
    end
    push!(bubbles, (F, bubble_functions))
    return bubbles
  end
  # r > 0
  w=0
  for d in k:D
    for F in _sorted_combinations(D+1, d+1)
      bubble_functions = _PÎ›_F_bubble_functions(r,k,D,F,w)
      isempty(bubble_functions) && continue
      push!(bubbles, (F, bubble_functions))
      w += length(bubble_functions)
    end
  end
  @check w == binomial(r+k,k)*binomial(D+r,D-k)
  bubbles
end

function _compute_PÎ›_basis_form_coefficient!(Î¨,r,k,::Val{D},b,vertices,indices) where D
  N = D+1
  Vk = Val(k)
  V = eltype(Î¨)

  iszero(r) && return _order_0_Î¨!(Î¨)

  T = eltype(V)
  Î±_prec = ntuple(_->-1, N)
  Ï†_Î±F = MMatrix{D,N,T}(undef)
  Î¨w = Mutable(V)(undef)
  @inbounds for (F, bubble_functions) in indices.bubbles
    for (w, Î±, _, J) in bubble_functions
      if Î± â‰  Î±_prec
        _update_Ï†_Î±F!(Ï†_Î±F,b,Î±,F,r)
        Î±_prec = Î±
      end

      for (I_id, I, I_sgn) in indices.components
        Î¨w[I_id] = I_sgn * _minor(Ï†_Î±F,I,J,Vk)
      end
      Î¨[w] = Î¨w
    end
  end
  nothing
end

@inline function _update_Ï†_Î±F!(Ï†_Î±F,b,Î±,F,r)
  M = b.cart_to_bary_matrix
  @inbounds for ci in CartesianIndices(Ï†_Î±F)
    i, j = ci[1], ci[2]
    mF = sum(M[Fl,i+1] for Fl in F; init=0)
    Ï†_Î±F[ci] = M[j,i+1] - Î±[j]*mF/r
  end
end

function _order_0_Î¨!(Î¨)
  V = eltype(Î¨)
  T = eltype(V)
  for w in eachindex(Î¨)
    Î¨[w] = ntuple( i -> T(i==w), length(V))
  end
  nothing
end

function _compute_PÎ›_basis_form_coefficient!(
  Î¨,r,k,::Val,b,vertices::Nothing,indices)

  Vk = Val(k)
  V = eltype(Î¨)
  T = eltype(V)
  Î¨w = Mutable(V)(undef)

  iszero(r) && return _order_0_Î¨!(Î¨)

  @inbounds for (F, bubble_functions) in indices.bubbles
    for (w, Î±, _, J) in bubble_functions
      for (I_id, I, I_sgn) in indices.components
        Î¨w[I_id] = I_sgn * _hat_Î¨(r,Vk,Î±,F,I,J,T)
      end
      Î¨[w] = Î¨w
    end
  end
  nothing
end

"""
    _hat_Î¨(r,::Val{k},Î±,F,I,J,T)::T

BarycentricPÎ›Basis.Î¨ matrix elements in the reference simplex, T is the scalar return type

This is actually not faster than computing the matrices and the minors
explicitely like when vertices are given, but might be usefull in case we want
to compute these at compile time one day.
"""
function _hat_Î¨(r,Vk::Val{k},Î±,F,I,J,::Type{T})::T where {T,k}
  @check sum(Î±) == r
  @check length(I) == length(J) == k

  iszero(k) && return one(T) # 0 forms

  @inbounds begin

    s = Int(isone(J[1]))
    n = count(i-> (J[i]-1)âˆ‰I, (1+s):k)

    n > 1 && return 0. # rank M_IJ inferior to 2

    p = _findfirst_val_or_zero(j-> (I[j]+1)âˆ‰J, 1, k)

    if isone(n)        # rank M_IJ is 1
      m = _findfirst_val_or_zero(i-> (J[i]-1)âˆ‰I, (s+1), k)
      u_p, v_m = _u(p,F,I), _v(m,Î±,J,r)
      sgn = _minusone_if_even_else_one(m+p+1)
      iszero(s) && return sgn*u_p*v_m

      q = _findfirst_val_or_zero(j-> (I[j]+s)âˆ‰J, (p+1), k)
      u_q = _u(q,F,I)
      sgn *= _minusone_if_even_else_one(q+1)
      return sgn * v_m * (u_q - u_p)
    end

    u, v = _u(F,I,Vk), _v(Î±,J,r,Vk)
    if iszero(s)
      return 1 + sum( u .* v )
    else
      Î¨_IJ = one(T)
      sum_v = v[1]
      for l in 1:p-1
        vlp = v[l+1]
        sum_v += vlp
        Î¨_IJ += vlp*u[l]
      end
      for l in (p+1):k
        vl = v[l]
        sum_v += vl
        Î¨_IJ += vl*u[l]
      end
      sgn = _minusone_if_even_else_one(p+1)
      return sgn * (Î¨_IJ - u[p]*sum_v)
    end

  end
  @unreachable
end

@propagate_inbounds _u(i::Int,F,I)   = Int(isone(F[1])) - Int(I[i]+1 in F)
@propagate_inbounds _u(F::Vector{Int},I,Vk) = ntuple(i->_u(i,F,I), Vk)
@propagate_inbounds _v(j::Int,Î±,J,r) = Î±[J[j]]/r
@propagate_inbounds _v(Î±::Vector{Int},J,r,Vk) = ntuple(j->_v(j,Î±,J,r), Vk)

# API

function _evaluate_nd!(
  b::BarycentricPÎ›Basis{D}, x,
  Ï‰::AbstractMatrix, i, cB,
  ::Val{r}) where {D,r}

  Î» = _cart_to_bary(x, _get_cart_to_bary_matrix(b))

  # _evaluate_nd!(::BernsteinBasisOnSimplex) without set_value
  cB[1] = 1
  _downwards_de_Casteljau_nD!(cB,Î»,Val(r),Val(D))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Î±_id) in bubble_functions
      Î¨w = b.Î¨[w]
      BÎ± = cB[Î±_id]
      Ï‰[i,w] = BÎ± * Î¨w
    end
  end
end

function _gradient_nd!(
  b::BarycentricPÎ›Basis{D}, x,
  âˆ‡Ï‰::AbstractMatrix, i, cB,
  âˆ‡B::AbstractMatrix{<:VectorValue{D}},
  s::MVector{D},
  ::Val{r}) where {D,r}

  _gradient_nd!(b.scalar_bernstein_basis, x, âˆ‡B, 1, cB, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Î±_id) in bubble_functions
      Î¨w = b.Î¨[w]
      âˆ‡BÎ± = âˆ‡B[1,Î±_id]
      âˆ‡Ï‰[i,w] = âˆ‡BÎ± âŠ— Î¨w
    end
  end
end

function _hessian_nd!(
  b::BarycentricPÎ›Basis{D}, x,
  HÏ‰::AbstractMatrix, i, cB,
  ::Nothing,
  HB::AbstractMatrix{<:TensorValue{D,D}},
  s::MMatrix{D,D},
  ::Val{r}) where {D,r}

  _hessian_nd!(b.scalar_bernstein_basis, x, HB, 1, cB, nothing, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Î±_id) in bubble_functions
      Î¨w = b.Î¨[w]
      HBÎ± = HB[1,Î±_id]
      HÏ‰[i,w] = HBÎ± âŠ— Î¨w
    end
  end
end


################################################################
# Combination, Bernstein term and Barycentric PÎ› bases helpers #
################################################################

# A combination is a set of positive integers sorted in increasing order
# a.k.a an increasing collection of indices in a range 1:D
#     F  = 1 â‰¤ F1 < ... < Fd â‰¤ D
# It is used to represent faces of polytopes (the indices iddentifying the
# vertices of the face) or a component of a k-form as in (1,3) ~ dxÂ¹âˆ§dxÂ³ .

"""
    _sorted_combinations(D,k)

Return a vector of all the combinations I_i of {1:`D`} of length `k`:

1 â‰¤ I\\_1 < ... < I\\_k â‰¤ `D`

sorted in right-digit to left-digit lexicographic order, e.g.

```julia
[ [1,2], [1,3], [2,3] ]  # for D=3, k=2\\
[ [1,2], [1,3], [2,3], [1,4], [2,4], [3,4] ]  # for D=4, k=2
```

This example shows that this order of sorted combinations of same length `k` is
independent of the dimension `D`, unlike with the usual (left-digit to right-digit)
lexicographic order where 14 would be smaller than 23.

So with the chosen order, 23 is always the third length-2 combination, not the `D`áµ—Ê°.
"""
function _sorted_combinations(D::Int,k::Int)
  iszero(k) &&  return Vector{Int}[ Int[] ]
  comp_rev_perm(tup) =  Int[D-tup[k-i+1]+1 for i in 1:k]
  inc_perms = combinations(1:D,k) .|> (tup -> comp_rev_perm(tup)) |> reverse
  return inc_perms
end

"""
    _combination_index(I)

Linear index of `I` amongst combinations of the same size `k`,
sorted in right-to-left lexicographic order. It depends on `k` but not on the
space dimension, see [`_sorted_combinations`](@ref).
"""
@inline function _combination_index(combi)
  k = length(combi)
  return sum( binomial(combi[i]-1, i) for i in 1:k; init=0) + 1
end

"""
    _complement(I, D)

Given a k-combination `I` of elements of `1:D`, returns the unique (`D`-k)
combination of `1:D` "`Icomp`" such that `I âˆª Icomp âŠ‡ 1:D`.
"""
function _complement(combi, D)
  k = length(combi)
  combi_comp = Vector{Int}(undef, D-k)
  curr_perm, curr_comp = 1, 1
  for i in 1:D
    if curr_perm â‰¤ k && combi[curr_perm] == i
      curr_perm += 1
    else
      combi_comp[curr_comp] = i
      curr_comp += 1
    end
  end
  combi_comp
end

"""
    _combination_sign(I)

Given a combination `I`, returns the sign of the permutation resulting from
the concatenation of `I` and its complement [`_complement(I)`](@ref _complement).
"""
function _combination_sign(combi)
  i, k, acc, delta = 1, 1, 0, 0
  while k <= length(combi)
    if combi[k] == i
      acc += delta
      k += 1
    else
      delta += 1
    end
    i += 1
  end
  return iseven(acc) ? 1 : -1
end

"""
    _sub_combinations_ids(J)

Return a vector containing the `k-1` combinations `J\\J[i]` for 1 â‰¤ i â‰¤ `k`,
where `k=length(J)`.
"""
function _sub_combinations_ids(combi)
  k = length(combi)
  sub_combi = MVector{k-1,Int}(undef)
  sub_combi_ids = Vector{Int}(undef, k)
  for i in 1:k
    sub_combi .= ntuple(j -> combi[j + Int(jâ‰¥i)],k-1)
    sub_combi_id = _combination_index(sub_combi)
    sub_combi_ids[i] = sub_combi_id
  end
  sub_combi_ids
end

"""
    _sup_multi_indices(Î±)

Given `Î±` a Bernstein term of length N, return the [`bernstein_term_id `](@ref)
of the N terms `Î±`+eáµ¢ for 1 â‰¤ i â‰¤ N in a Vector (in order of i increasing).
"""
function _sup_multi_indices(Î±)
  N = length(Î±)
  sup_Î± = MVector{N,Int}(undef)
  sup_Î±_ids = Vector{Int}(undef, N)
  for i in 1:N
    sup_Î± .=  ntuple(k -> Î±[k]+Int(k==i), N)
    sup_Î±_id = bernstein_term_id(sup_Î±)
    sup_Î±_ids[i] = sup_Î±_id
  end
  return sup_Î±_ids
end

"""
    _support(Î±)

Given a bernstein multi-index `Î±`, returns the set of indices `i` such that `Î±áµ¢`>0.
"""
function _support(Î±)
  s = Int[]
  for (i,Î±i) in enumerate(Î±)
    if Î±i > 0
      push!(s, i)
    end
  end
  s
end

"""
    _minor(M,I,J,::Val{k})

Computes the minor (determinant of sub-matrix) of the matrix M where the rows of
indices iâˆˆ`I` and column of indics jâˆˆ`J` are kept. `k` is the length of both `I`
and `J`.
"""
function _minor(M,I,J,::Val{k}) where k
  @check length(I) == length(J)
  @check I âŠ† axes(M)[1]
  @check J âŠ† axes(M)[2]

  T = eltype(M)
  m = MMatrix{k,k,T,k*k}(undef)
  for (i, Ii) in enumerate(take(I,k))
    for (j, Jj) in enumerate(take(J,k))
      @inbounds m[i,j] = M[Ii,Jj]
    end
  end
  det(m)
end

@propagate_inbounds function _minusone_if_even_else_one(i)
  iseven(i) ? -1 : 1
end

@propagate_inbounds function _findfirst_val_or_zero(pred, start, stop)
  r = findfirst(pred,start:stop)
  return isnothing(r) ? 0 : r+start-1
end

@propagate_inbounds function _minimum_or_one(s)
  maxint = typemax(Int)
  j = minimum(s, init=maxint)
  j = (j==maxint) ? 1 : j
end
