# The theory and notations used in this file are documented in detail in the
# Bernstein bases algorithms Developper notes of the official documentation.

"""
    FEEC_space_definition_checks(::Val{D}, T, r, k, F, rotate_90)

Check if the argument define a valid Finite Element Exterior Calculus (FEEC) polynomial space,
as defined in the Periodic Table of the Finite Elements, `F·µ£Œõ·µè` in dimension `D`.

The arguments are also described in [`FEEC_poly_basis`](@ref).
"""
function FEEC_space_definition_checks(
  ::Val{D},::Type{T},r::Int,k::Int,F::Symbol, rotate_90::Bool=false, diff_geo_calculus_style::Bool=false
) where {D,T}

  @check T<:Real "T needs to be <:Real since represents the scalar type, got $T"
  @check F in (:P‚Åª,:P,:Q‚Åª,:S) "F must be either :P‚Åª,:P,:Q‚Åª or :S, got $F."
  @check k in 0:D "The form order k must be in 0:D, got k=$k and D=$D."
  @check r ‚â• 0    "The polynomial order r must be positive, got $r."

  if diff_geo_calculus_style
    @notimplemented "A new MultiValue type and associated algebraic operations ‚àß/‚ãÜ/ùëë/Œ¥ need to be implemented to use form valued polynomials."
  elseif D>3 && ( 1 < k < D-1)
    @unreachable "Vector calculus proxy of differential form bases are only available for `k`=0,1,`D`-1 and `D`, got k=$k and D=$D."
  end

  if rotate_90 && !(!diff_geo_calculus_style && isone(k) && D==2)
    @warn """The `rotate_90` kwarg only makes sense for 2D vector proxied forms
              of degree 1, it will be ignored and may lead to errors.
              Got k=$k, D=$D for F=$F
          """
  end
  true
end

#######################
# PLambdaIndices type #
#######################

# Do print some PLambdaIndices generated by PŒõ_bubbles(r,k,D) in REPL before
# reading this...

# All types and fields "XX" below should be understood as "Indices_For_XX"

# One bubble function:
#               œâ_w  =      (  w,           Œ±, Œ±_id,           J,   sub_J_ids,  sup_Œ±_ids )
const BubbleFunction = Tuple{Int, Vector{Int},  Int, Vector{Int}, Vector{Int}, Vector{Int}}

# One bubble space associated to the d-dimensional face F
# bubble_d_F =      (          F,    F_bubble_functions )
const Bubble = Tuple{Vector{Int}, Vector{BubbleFunction}}

"""
    struct PLambdaIndices
      identity::UInt
      bubbles::Vector{Bubble}
      components::Vector{Tuple{ Int, Vector{Int}, Int}}
    end

For storing indices in `P(m)LambdaBasis`. The `bubbles` are generated by
[`PŒõ_bubbles`](@ref) or [`PmŒõ_bubbles`](@ref), the `components` by
[`_basis_forms_components`](@ref).
"""
struct PLambdaIndices
  # An objectid is stored here to keep track of what's inside and perform a
  # sanity check when reusing the indices elsewhere:
  #     identity = objectid( (r,k,D,:P,false,false) )
  # for a P·µ£Œõ·µè(‚ñ≥·¥∞) basis indices with vector-proxied components and rotate_90=false.
  identity::UInt

  # bubble indices given by P(m)Œõ_bubbles (can be filtered and renumbered to select subset of bubbles)
  # The BubbleFunction[1] "w" MUST be in increasing order when iterating over bubbles and bubble_functions
  bubbles::Vector{Bubble}

  # Indices for the components of a basis k-form or its vector calculus proxy,
  #                       (I_id,           I, sgnIcomp), see _basis_forms_components .
  components::Vector{Tuple{ Int, Vector{Int},      Int}}

  # Components "I" of the exterior derivative of a basis polynomial form
  # ext_deriv_components::Vector{Component}
end

function _check_PŒõ_indices(r,k,D,P,DG_style, indices::PLambdaIndices, rot_90)
  @check P==:P || P==:P‚Åª
  # Changing one of those requires re-computing all fields of PLambdaIndices,
  # otherwise wrong result or segfault due to @inbounds in evaluating functions
  # are expected
  @assert objectid( (r,k,D,P,DG_style,rot_90) ) == indices.identity
  @check begin
    ordered_bf_ids = [ bubfun[1] for bub in indices.bubbles for bubfun in bub[2] ]
    C = length(ordered_bf_ids)
    ordered_bf_ids == 1:C
  end "Invalid PLambdaIndices: bubble functions are not numbered from 1 to length(b) in the bubble indices"
end

"""
    _last_bubble_function_index(ids::PLambdaIndices)

The index of the last bubble function in `ids`, that is also the number of basis
polynomial defined by `ids`, and cardinal of the owning basis.
"""
function _last_bubble_function_index(ids::PLambdaIndices)
  isempty(ids.bubbles) && return 0
  return ids.bubbles[end][2][end][1]
end

function Base.show(io::IO, ::MIME"text/plain", indices::PLambdaIndices)
  if isempty(indices.bubbles)
    print(io,"Empty PŒõ basis indices")
    return
  end

  Œ± = indices.bubbles[1][2][1][2]
  J = indices.bubbles[1][2][1][4]
  I = indices.components[1][2]

  r = sum(Œ±)+length(J)-length(I)
  k = length(I)
  D = length(Œ±)-1
  is_Pm = r != sum(Œ±)
  println(io,"P·µ£Œõ·µè(‚ñ≥·¥∞) basis indices, r=$r k=$k D=$D")

  println()
  println(io,"Basis polynomial components")
  println(io,"\tI_id\t I\t I_sgn")
  for (I_id, I, I_sgn) in indices.components
    println(io,"\t$I_id\t $(join(I))\t $I_sgn")
  end

  println()
  println(io,"\tw \tŒ± \tŒ±_id \tJ",  is_Pm ? "\tsub_J_ids \tsup_Œ±_ids" : "")
  for (F, F_bubble) in indices.bubbles
    isempty(F_bubble) && continue

    println(io,"Bubble of face F=$(join(F))")
    for (w, Œ±, Œ±_id, J, sub_J_ids, sup_Œ±_ids) in F_bubble
      println(io,"\t$w \t$(join(Œ±)) \t$Œ±_id \t$(join(J)) \t$(join(sub_J_ids,",")) \t\t$(join(sup_Œ±_ids,","))")
    end
  end
  println()
  println(io,"P·µ£Œõ·µè(‚ñ≥·¥∞) basis indices, r=$r k=$k D=$D")
end


#####################################
# PmLambdaBasis nD polynomial bases #
#####################################

"""
    PmLambdaBasis{D,V,LN,B} <: PolynomialBasis{D,V,Bernstein}

Finite Element Exterior Calculus polynomial basis for the spaces P‚Åª`·µ£`Œõ`·¥∑` on
`D`-dimensional simplices, but with polynomial forms explicitely transformed
into vectors using the standard equivalence with usual vector calculus defined
in terms of the hodge star operator ‚ãÜ and the sharp map ‚ôØ, see
[`_basis_forms_components`](@ref) (the simplex is assumed Euclidean).

- `V` is `VectorValue{L,T}` where `L` is binomial(`D`,`k`),
- `B` is the concrete type of the `BernsteinBasisOnSimplex` necessary for the evaluation of the polynomials.

The number of basis polynomials is binomial(`r`+`k`-1,`k`)*binomial(`D`+`r`,`D`-`k`) if no filtered bubble indices are given.

Reference: D.N. Arnold, R.S. Falk & R. Winther, Geometric decompositions and local bases for spaces of finite element differential forms, CMAME, 2009
"""
struct PmLambdaBasis{D,V,LN,B} <: PolynomialBasis{D,V,Bernstein}
  r::Int
  k::Int
  scalar_bernstein_basis::B
  m::SVector{LN,V}
  _indices::PLambdaIndices

  function PmLambdaBasis{D}(::Type{T}, r, k, vertices=nothing;
        diff_geo_calculus_style=false, indices=nothing, rotate_90=false) where {D,T}

    FEEC_space_definition_checks(Val(D), T, r, k, :P‚Åª, rotate_90, diff_geo_calculus_style)
    _simplex_vertices_checks(Val(D), vertices)

    indices = _generate_or_check_PmŒõ_indices(r,k,D,diff_geo_calculus_style,indices,rotate_90)

    L = binomial(D,k) # Number of components of a basis form
    V = VectorValue{L,T} # To update once diff_geo_calculus_style is implemented

    b = BernsteinBasisOnSimplex{D}(T, r, vertices)
    B = typeof(b)
    LN = binomial(D+1,k) # Number of k-faces J of a D-dimensional tetrahedron
    m = zero(MVector{LN,V})
    _compute_PmŒõ_basis_coefficients!(m,Val(k),D,b,vertices,indices)

    if isone(L) && !diff_geo_calculus_style
      V = T
      m = reinterpret(T, m)
    end

    new{D,V,LN,B}(r,k,b,m,indices)
  end

  @doc """
      PmLambdaBasis(b::PmLambdaBasis, faces::Vector{Int}...)

  Create a new basis which is `b` restricted to the bubble spaces for F ‚àà `faces`.
  """
  function PmLambdaBasis(_b::PmLambdaBasis{D,V,LN,B}, faces::Vector{Int}...) where {D,V,LN,B}
    # Notation:‚ÄØ_old, new
    _indices = _b._indices
    _bubbles = _indices.bubbles
    bubbles = similar(_bubbles, length(faces))

    w = 1
    for (Fid, F) in enumerate(faces)
      F_id = findfirst(bub -> bub[1] == F, _bubbles)
      @assert !isnothing(F_id) "No bubble associated to face $F in the given basis"

      _F_bubfuns = _bubbles[F_id][2]
      F_bubfuns = similar(_F_bubfuns)
      for (i, _fun) in enumerate(_F_bubfuns)
        # re-use all Œ±,J, etc... to minimise allocation, just change w
        F_bubfuns[i] = (w, _fun[2:end]...)
        w += 1
      end
      bubbles[Fid] = (F, F_bubfuns)
    end

    indices = PLambdaIndices(_indices.identity, bubbles, _indices.components)
    new{D,V,LN,B}(_b.r, _b.k, _b.scalar_bernstein_basis, _b.m, indices)
  end

  function PmLambdaBasis{D,V,LN,B}() where {D,V,LN,B} # just for testvalue
    indices = _generate_or_check_PmŒõ_indices(1,0,0,false,nothing,false)
    new{D,V,LN,B}(0,0,testvalue(B),zero(SVector{LN,V}),indices)
  end
end

"""
    PmLambdaBasis(::Val{D}, T, r, k, vertices=nothing; kwargs...)

Constructors for [`PmLambdaBasis`](@ref) of scalar type `T`.
If `vertices` are specified, they must define a non-degenerate simplex, c.f. [`BernsteinBasisOnSimplex`](@ref).

The kwargs are the following:
- `indices::PLambdaIndices = nothing`: may be provided to avoid allocations of new indices, or to select specific bubbles spaces,
- `diff_geo_calculus_style = false`: set to `true` to choose `k`-form valued polynomials instead of vector valued polynomials (not implemented yet),
- `rotate_90 = false`: In 2`D` for `k`=1, `true` to apply a 90¬∞ rotation of the vector proxied polynomials ((x,y) -> (-y,x)), needed for Raviart-Thomas/BDM.
"""
function PmLambdaBasis(::Val{D},::Type{T},r,k,vertices=nothing; kwargs...) where {D,T}
  PmLambdaBasis{D}(T,r,k,vertices; kwargs...)
end

"""
    _DG_calculus_style(::V) = false

Temporary API to signal that the coefficient of `V`-valued polynomial forms
should be transformed into classic vector calulus components using Hodge star
operator.
"""
_DG_calculus_style(::V) where V = false

get_FEEC_poly_degree(b::PmLambdaBasis) = b.r
get_FEEC_form_degree(b::PmLambdaBasis) = b.k
get_FEEC_family(::PmLambdaBasis) = :P‚Åª

Base.size(b::PmLambdaBasis) = (_last_bubble_function_index(b._indices), )

function testvalue(::Type{PmLambdaBasis{D,V,LN,B}}) where {D,V,LN,B}
  PmLambdaBasis{D,V,LN,B}()
end

####################################
# PLambdaBasis nD polynomial bases #
####################################

"""
    PLambdaBasis{D,V,C,B} <: PolynomialBasis{D,V,Bernstein}

Finite Element Exterior Calculus polynomial basis for the spaces P`·µ£`Œõ`·¥∑` on
`D`-dimensional simplices, but with polynomial forms explicitely transformed
into vectors using the standard equivalence with usual vector calculus defined
in terms of the hodge star operator ‚ãÜ and the sharp map ‚ôØ, see
[`_basis_forms_components`](@ref) (the simplex is assumed Euclidean).

- `V` is `VectorValue{L,T}` where `L=binomial(D,k)`,
- `C` is the number of basis polynomials,
- `B` is the concrete type of the `BernsteinBasisOnSimplex` necessary for the evaluation of the polynomials.

`C` = binomial(`r`+`k`,`k`)*binomial(`D`+`r`,`D`-`k`) if no custom bubble indices are given.

Reference: D.N. Arnold, R.S. Falk & R. Winther, Geometric decompositions and local bases for spaces of finite element differential forms, CMAME, 2009
"""
struct PLambdaBasis{D,V,C,B} <: PolynomialBasis{D,V,Bernstein}
  r::Int
  k::Int
  scalar_bernstein_basis::B
  Œ®::SVector{C,V}
  _indices::PLambdaIndices

  function PLambdaBasis{D}(::Type{T}, r, k, vertices=nothing;
        diff_geo_calculus_style=false, indices=nothing, rotate_90=false) where {D,T}

    FEEC_space_definition_checks(Val(D), T, r, k, :P‚Åª, rotate_90, diff_geo_calculus_style)
    _simplex_vertices_checks(Val(D), vertices)

    indices = _generate_or_check_PŒõ_indices(r,k,D,diff_geo_calculus_style,indices,rotate_90)

    L = binomial(D,k) # Number of components of a basis form
    V = VectorValue{L,T} # To update once diff_geo_calculus_style is implemented
    C = _last_bubble_function_index(indices) # Cardinal of the basis

    b = BernsteinBasisOnSimplex{D}(T, r, vertices)
    B = typeof(b)
    Œ® = zero(MVector{C,V})
    _compute_PŒõ_basis_form_coefficient!(Œ®,r,k,Val(D),b,vertices,indices)

    if isone(L) && !diff_geo_calculus_style
      V = T
      Œ® = reinterpret(T, Œ®)
    end

    new{D,V,C,B}(r,k,b,Œ®,indices)
  end

  @doc """
      PLambdaBasis(b::PLambdaBasis, faces::Vector{Int}...)

  Create a new basis which is `b` restricted to the bubble spaces for F ‚àà `faces`.
  The faces are represented by some `Vector{Int}` of their vertices ids, like in
  [`PLambdaIndices`](@ref).
  """
  function PLambdaBasis(_b::PLambdaBasis{D,V,_C,B}, faces::Vector{Int}...) where {D,V,_C,B}
    # Notation:‚ÄØ_old, new
    _indices = _b._indices
    _bubbles = _indices.bubbles
    _Œ® = _b.Œ®

    bubbles = similar(_bubbles, length(faces))
    Œ® = zero(MVector{_C,V}) # cache of maximum possible size
    w = 1

    for (Fid, F) in enumerate(faces)
      F_id = findfirst(bub -> bub[1] == F, _bubbles)
      @assert !isnothing(F_id) "No bubble associated to face $F in the given basis"

      _F_bubfuns = _bubbles[F_id][2]
      F_bubfuns = similar(_F_bubfuns)
      for (i, _fun) in enumerate(_F_bubfuns)
        # re-use all Œ±,J, etc... to minimise allocation, just change w
        (_w, _fun_ids...) = _fun
        F_bubfuns[i] = (w, _fun_ids...)
        Œ®[w] = _Œ®[_w]
        w += 1
      end
      bubbles[Fid] = (F, F_bubfuns)
    end

    C = w-1
    Œ® = SVector{C,V}( Œ®[1:C] )
    indices = PLambdaIndices(_indices.identity, bubbles, _indices.components)
    new{D,V,C,B}(_b.r, _b.k, _b.scalar_bernstein_basis, Œ®, indices)
  end

  function PLambdaBasis{D,V,C,B}() where {D,V,C,B} # Just for testvalue
    indices = _generate_or_check_PŒõ_indices(1,0,0,false,nothing,false)
    new{D,V,C,B}(0,0,testvalue(B),zero(SVector{C,V}),indices)
  end
end

"""
    PLambdaBasis(::Val{D}, T, r, k, vertices=nothing; kwargs...)

Constructors for [`PLambdaBasis`](@ref) of scalar type `T`.
If `vertices` are specified, they must define a non-degenerate simplex, c.f. [`BernsteinBasisOnSimplex`](@ref).

The kwargs are the following:
- `indices::PLambdaIndices = nothing`: may be provided to avoid allocations of new indices, or to select specific bubbles spaces,
- `diff_geo_calculus_style = false`: set to `true` to choose `k`-form valued polynomials instead of vector valued polynomials (not implemented yet),
- `rotate_90 = false`: In 2`D` for `k`=1, `true` to apply a 90¬∞ rotation of the vector proxied polynomials ((x,y) -> (-y,x)), needed for Raviart-Thomas/BDM.
"""
function PLambdaBasis(::Val{D},::Type{T},r,k,vertices=nothing; kwargs...) where {D,T}
  PLambdaBasis{D}(T,r,k,vertices; kwargs...)
end

get_FEEC_poly_degree(b::PLambdaBasis) = b.r
get_FEEC_form_degree(b::PLambdaBasis) = b.k
get_FEEC_family(::PLambdaBasis) = :P

Base.size(::PLambdaBasis{D,V,C}) where {D,V,C} = (C, )

function testvalue(::Type{PLambdaBasis{D,V,C,B}}) where {D,V,C,B}
  PLambdaBasis{D,V,C,B}()
end

##########################
# Common Implementation  #
##########################

const PŒõBases = Union{PmLambdaBasis, PLambdaBasis}

"""
    get_bubbles(b::PmLambdaBasis)
    get_bubbles(b::PLambdaBasis)

Get the iterator over the bubble spaces in the geometric decomposition of `b`,
typically generated by [`PmŒõ_bubbles`](@ref) or [`PŒõ_bubbles`](@ref).

They can be vizualized using [`print_indices(b)`](@ref print_indices).
"""
get_bubbles(b::PŒõBases) = b._indices.bubbles
get_order(b::PŒõBases) = get_FEEC_poly_degree(b)

"""
    print_indices(b::P(m)LambdaBasis, out=stdout)

Prints the indices of the given PŒõ basis in `out` in a user friendly format.
"""
print_indices(b::PŒõBases, out=stdout) = show(out, MIME"text/plain"(), b._indices)

_get_cart_to_bary_matrix(b::PŒõBases) = b.scalar_bernstein_basis.cart_to_bary_matrix

function _return_cache(b::PŒõBases,x,::Type{G},::Val{N_deriv}) where {G,N_deriv}
  T = eltype(G)
  np = length(x)
  ndof = length(b)
  ndof_bernstein = length(b.scalar_bernstein_basis)

  r = CachedArray(zeros(G,(np,ndof)))
  # Cache for all scalar nD-Bernstein polynomials BŒ±
  cB = CachedVector(zeros(T,ndof_bernstein))
  # Cache for derivatives of BŒ± (‚àáBŒ± or HBŒ±)
  if N_deriv > 0
    DB = T
    xi = testitem(x)
    for _ in 1:N_deriv
      DB = gradient_type(DB,xi)
    end
    # Cache for N_deriv's derivatives all of scalar nD-Bernstein polynomials
    t = (( nothing for _ in 2:N_deriv)..., CachedArray(zeros(DB,(1,ndof_bernstein))))
    s = MArray{Tuple{size(DB)...},T}(undef)
  else
    t = ()
    s = nothing
  end
  (r, s, cB, t...)
end

function _setsize!(b::PŒõBases, np, œâ, t...)
  ndof = length(b)
  ndof_bernstein = length(b.scalar_bernstein_basis)
  setsize!(œâ,(np,ndof))
  setsize!(t[1],(ndof_bernstein,)) # this is cB
  if length(t) > 1
    setsize!(t[end],(1,ndof_bernstein)) # this is ‚àáB or HB
  end
end

function _get_static_parameters(b::PŒõBases)
  r = get_FEEC_poly_degree(b)
  return Val(r)
end

"""
    _basis_forms_components(D,k,DG_style,rotate_90)

If `DG_style==true`, return the triples (`I_id`, `I`, 1) for each D-dimensional
k-form components dx·¥µ = dx·¥µ¬π ‚àß dx·¥µ¬≤ ‚àß ... ‚àß dx·¥µ·µè where `I` is a combination of
1:`D` and `I_id = _combination_index(I)`. The triples are ordered like in
[`_sorted_combinations`](@ref) (`I_id` increasing).

If `DG_style`==false, the indices are changed to implement the vector proxy of
the differential forms œâ defined by:
- œâ‚ôØ    if `k` = 0 or 1
- (‚ãÜœâ)‚ôØ if `k` = `D`-1 or `D` and `k`>1
where ‚ãÜ is the hodge star operator and ‚ôØ the sharp map.

The triples become (`I_proxy_id`, `I`, `I_proxy_sgn`) with the same `I` (and in
the same order), such that the components of the vector proxy v of a `k`-form œâ are

    v[I_proxy_id] = I_proxy_sgn * œâ[I_id]

If `k` ‚àà {0,1,`D`}, the proxy is trivial. If `k`=`D`-1, ‚ôØ reverses the
components order and ‚ãÜ adds signs 1, -1, 1, -1 ...

If `rotate_90` is `true` and `k` is `1`, the (‚ãÜœâ)‚ôØ proxy is applied instead of œâ‚ôØ.
"""
function _basis_forms_components(D,k,DG_style,rot_90)
  components = Vector{Tuple{ Int, Vector{Int}, Int}}(undef, binomial(D,k))
  for (I_id, I) in enumerate(_sorted_combinations(D,k))
    # The rotation for 2D Raviart-Thomas/BDM is actually considering k to be D-1
    # rather than 1, that is applying ‚ãÜ.
    if DG_style || iszero(k) || isone(k) && !rot_90
      components[I_id] = (I_id, I, 1)
    else # if k == D, I = [1:D] and this is just (1, [], 1) (but that works)
      Icomp = _complement(I, D)
      Istar_id = _combination_index(Icomp)
      Istar_sgn = _combination_sign(I)
      components[I_id] = (Istar_id, I, Istar_sgn)
    end
  end
  components
end


################################
# PmLambdaBasis Implementation #
################################

function _generate_or_check_PmŒõ_indices(r,k,D,DG_style,::Nothing,rot_90)
  identity = objectid( (r,k,D,:P‚Åª,DG_style) )
  bubbles = PmŒõ_bubbles(r,k,D)
  components = _basis_forms_components(D,k,DG_style,rot_90)
  return PLambdaIndices(identity,bubbles,components)
end

function _generate_or_check_PmŒõ_indices(r,k,D,DG_style,indices::PLambdaIndices,rot_90)
  _check_PŒõ_indices(r,k,D,:P‚Åª,DG_style,indices,rot_90)
  return indices
end

function _PmŒõ_F_bubble_functions(r,k,D,F,w)
  N = D + 1
  ids = BubbleFunction[]
  for Œ± in bernstein_terms(r-1,D)
    sup_Œ±_ids = _sup_multi_indices(Œ±)
    for J in _sorted_combinations(N,k+1)
      sub_J_ids = _sub_combinations_ids(J)
      j = _minimum_or_one(J)-1
      if issetequal(_support(Œ±) ‚à™ J, F) && all(Œ±[1:j] .== 0)
        w += 1
        Œ±_id = bernstein_term_id(Œ±)
        push!(ids, (w, Œ±, Œ±_id, J, sub_J_ids, sup_Œ±_ids))
      end
    end
  end
  ids
end

"""
    PmŒõ_bubbles(r,k,D)

Generates the indices caracterizing the basis function of `PmLambdaBasis`,
described in the Bernstein bases algorithm Developper notes of the official
documentation, and are used as follows:

    for (F, bubble_functions) in PmŒõ_bubbles(r,k,D)
      for (w, Œ±, Œ±_id, J, sub_J_ids, sup_Œ±_ids) in bubble_functions
        # ...
      end
    end
"""
function PmŒõ_bubbles(r,k,D)
  w=0
  bubbles = Bubble[]
  for d in k:D
    for F in _sorted_combinations(D+1, d+1)
      bubble_functions = _PmŒõ_F_bubble_functions(r,k,D,F,w)
      isempty(bubble_functions) && continue
      push!(bubbles, (F, bubble_functions))
      w += length(bubble_functions)
    end
  end
  @check w == binomial(r+k-1,k)*binomial(D+r,D-k)
  bubbles
end

function _compute_PmŒõ_basis_coefficients!(m,::Val{k},D,b,vertices,indices) where k
  V = eltype(m)
  M = transpose(b.cart_to_bary_matrix[:,2:end])
  m_J = Mutable(V)(undef)
  @inbounds for (J_id, J) in enumerate(_sorted_combinations(D+1,k))
    for (I_id, I, I_sgn) in indices.components
      m_J[I_id] = I_sgn * _minor(M,I,J,Val(k))
    end
    m[J_id] = m_J
  end
  nothing
end

function _compute_PmŒõ_basis_coefficients!(
  m,::Val{k},D,b,vertices::Nothing,indices) where k

  if iszero(k) # so V is scalar, no change of basis
    m .= 1
    return nothing
  end

  V = eltype(m)
  m_J = Mutable(V)(undef)
  @inbounds for (J_id, J) in enumerate(_sorted_combinations(D+1,k))
    s = Int(isone(J[1]))
    for (I_id, I, I_sgn) in indices.components
      n = count(i-> (J[i]-1)‚àâI, (1+s):k)
      if iszero(n)
        p = _findfirst_val_or_zero(j-> (I[j]+1)‚àâJ, 1, k)
        m_J[I_id] = I_sgn*_minusone_if_even_else_one(p+1)
      else
        m_J[I_id] = 0
      end
    end
    m[J_id] = m_J
  end
  nothing
end

# API

function _evaluate_nd!(
  b::PmLambdaBasis{D}, x,
  œâ::AbstractMatrix, i, cB,
  ::Val{r}) where {D,r}

  V = eltype(œâ)
  Œª = _cart_to_bary(x, _get_cart_to_bary_matrix(b))

  # _evaluate_nd!(::BernsteinBasisOnSimplex) without set_value
  cB[1] = 1
  _downwards_de_Casteljau_nD!(cB,Œª,Val(r-1),Val(D))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Œ±_id, J, sub_J_ids) in bubble_functions
      BŒ± = cB[Œ±_id]
      œâ_w = zero(V)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Œª_j = Œª[J[l]]
        m_J_l = b.m[J_sub_Jl_id]

        œâ_w += flipsign(Œª_j,sgnl) * m_J_l
      end

      œâ[i,w] = BŒ± * œâ_w
    end
  end
end

function _gradient_nd!(
  b::PmLambdaBasis{D}, x,
  ‚àáœâ::AbstractMatrix{G}, i, cB,
  ‚àáB::AbstractMatrix{<:VectorValue{D}},
  s::MVector{D},
  ::Val{r}) where {D,G,r}

  _gradient_nd!(b.scalar_bernstein_basis, x, ‚àáB, 1, cB, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, Œ±, _, J, sub_J_ids, sup_Œ±_ids) in bubble_functions
      ‚àáœâ_w = zero(G)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Jl = J[l]
        Œ±_pJl_id = sup_Œ±_ids[Jl]

        ‚àáBŒ±_pJl = ‚àáB[1,Œ±_pJl_id]
        c_Œ±_Jl = (Œ±[Jl]+1) * sgnl / r
        m_J_l = b.m[J_sub_Jl_id]

        ‚àáœâ_w += (c_Œ±_Jl * ‚àáBŒ±_pJl) ‚äó m_J_l
      end

      ‚àáœâ[i,w] = ‚àáœâ_w
    end
  end
end

function _hessian_nd!(
  b::PmLambdaBasis{D}, x,
  Hœâ::AbstractMatrix{G}, i, cB,
  ::Nothing,
  HB::AbstractMatrix{<:TensorValue{D,D}},
  s::MMatrix{D,D},
  ::Val{r}) where {D,G,r}

  _hessian_nd!(b.scalar_bernstein_basis, x, HB, 1, cB, nothing, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, Œ±, _, J, sub_J_ids, sup_Œ±_ids) in bubble_functions
      Hœâ_w = zero(G)

      for (l, J_sub_Jl_id) in enumerate(sub_J_ids)
        sgnl = _minusone_if_even_else_one(l)
        Jl = J[l]
        Œ±_pJl_id = sup_Œ±_ids[Jl]

        HB_Œ±Jl = HB[1,Œ±_pJl_id]
        c_Œ±Jl = (Œ±[Jl]+1) * sgnl / r
        m_Jl = b.m[J_sub_Jl_id]

        Hœâ_w += (c_Œ±Jl * HB_Œ±Jl) ‚äó m_Jl
      end

      Hœâ[i,w] = Hœâ_w
    end
  end
end


###############################
# PLambdaBasis Implementation #
###############################

function _generate_or_check_PŒõ_indices(r,k,D,DG_style,::Nothing,rot_90)
  identity = objectid( (r,k,D,:P,DG_style) )
  bubbles = PŒõ_bubbles(r,k,D)
  components = _basis_forms_components(D,k,DG_style,rot_90)
  return PLambdaIndices(identity,bubbles,components)
end

function _generate_or_check_PŒõ_indices(r,k,D,DG_style,indices::PLambdaIndices,rot_90)
  _check_PŒõ_indices(r,k,D,:P,DG_style,indices,rot_90)
  return indices
end

function _PŒõ_F_bubble_functions(r,k,D,F,w)
  N = D + 1
  bubble_functions = BubbleFunction[]
  empty_vec = Int[]
  for Œ± in bernstein_terms(r,D)
    for J in _sorted_combinations(N,k)
      j = _minimum_or_one(setdiff(F,J))-1
      if issetequal(_support(Œ±) ‚à™ J, F) && all(Œ±[1:j] .== 0)
        w += 1
        Œ±_id = bernstein_term_id(Œ±)
        push!(bubble_functions, (w, Œ±, Œ±_id, J, empty_vec, empty_vec))
      end
    end
  end
  bubble_functions
end

"""
    PŒõ_bubbles(r,k,D)

Generates the indices caracterizing the basis function of `PLambdaBasis`,
described in the Bernstein bases algorithm Developper notes of the official
documentation, and are used as follows:

    for (F, bubble_functions) in PŒõ_bubbles(r,k,D)
      for (w, Œ±, Œ±_id, J) in bubble_functions
        # ...
      end
    end
"""
function PŒõ_bubbles(r,k,D)
  bubbles = Bubble[]
  if r == 0
    F = [1:(D+1)...]
    Œ± = zeros(Int,D+1)
    bubble_functions = BubbleFunction[]
    for i in 1:binomial(D,k)
      push!(bubble_functions, (i, Œ±, 1, [], [], [])) # J has no meaning there
    end
    push!(bubbles, (F, bubble_functions))
    return bubbles
  end
  # r > 0
  w=0
  for d in k:D
    for F in _sorted_combinations(D+1, d+1)
      bubble_functions = _PŒõ_F_bubble_functions(r,k,D,F,w)
      isempty(bubble_functions) && continue
      push!(bubbles, (F, bubble_functions))
      w += length(bubble_functions)
    end
  end
  @check w == binomial(r+k,k)*binomial(D+r,D-k)
  bubbles
end

function _compute_PŒõ_basis_form_coefficient!(Œ®,r,k,::Val{D},b,vertices,indices) where D
  N = D+1
  Vk = Val(k)
  V = eltype(Œ®)

  iszero(r) && return _order_0_Œ®!(Œ®)

  T = eltype(V)
  Œ±_prec = ntuple(_->-1, N)
  œÜ_Œ±F = MMatrix{D,N,T}(undef)
  Œ®w = Mutable(V)(undef)
  @inbounds for (F, bubble_functions) in indices.bubbles
    for (w, Œ±, _, J) in bubble_functions
      if Œ± ‚â† Œ±_prec
        _update_œÜ_Œ±F!(œÜ_Œ±F,b,Œ±,F,r)
        Œ±_prec = Œ±
      end

      for (I_id, I, I_sgn) in indices.components
        Œ®w[I_id] = I_sgn * _minor(œÜ_Œ±F,I,J,Vk)
      end
      Œ®[w] = Œ®w
    end
  end
  nothing
end

@inline function _update_œÜ_Œ±F!(œÜ_Œ±F,b,Œ±,F,r)
  M = b.cart_to_bary_matrix
  @inbounds for ci in CartesianIndices(œÜ_Œ±F)
    i, j = ci[1], ci[2]
    mF = sum(M[Fl,i+1] for Fl in F; init=0)
    œÜ_Œ±F[ci] = M[j,i+1] - Œ±[j]*mF/r
  end
end

function _order_0_Œ®!(Œ®)
  V = eltype(Œ®)
  T = eltype(V)
  for w in eachindex(Œ®)
    Œ®[w] = ntuple( i -> T(i==w), length(V))
  end
  nothing
end

function _compute_PŒõ_basis_form_coefficient!(
  Œ®,r,k,::Val,b,vertices::Nothing,indices)

  Vk = Val(k)
  V = eltype(Œ®)
  T = eltype(V)
  Œ®w = Mutable(V)(undef)

  iszero(r) && return _order_0_Œ®!(Œ®)

  @inbounds for (F, bubble_functions) in indices.bubbles
    for (w, Œ±, _, J) in bubble_functions
      for (I_id, I, I_sgn) in indices.components
        Œ®w[I_id] = I_sgn * _hat_Œ®(r,Vk,Œ±,F,I,J,T)
      end
      Œ®[w] = Œ®w
    end
  end
  nothing
end

"""
    _hat_Œ®(r,::Val{k},Œ±,F,I,J,T)::T

PLambdaBasis.Œ® matrix elements in the reference simplex, T is the scalar return type

This is actually not faster than computing the matrices and the minors
explicitely like when vertices are given, but might be usefull in case we want
to compute these at compile time one day.
"""
function _hat_Œ®(r,Vk::Val{k},Œ±,F,I,J,::Type{T})::T where {T,k}
  @check sum(Œ±) == r
  @check length(I) == length(J) == k

  iszero(k) && return one(T) # 0 forms

  @inbounds begin

    s = Int(isone(J[1]))
    n = count(i-> (J[i]-1)‚àâI, (1+s):k)

    n > 1 && return 0. # rank M_IJ inferior to 2

    p = _findfirst_val_or_zero(j-> (I[j]+1)‚àâJ, 1, k)

    if isone(n)        # rank M_IJ is 1
      m = _findfirst_val_or_zero(i-> (J[i]-1)‚àâI, (s+1), k)
      u_p, v_m = _u(p,F,I), _v(m,Œ±,J,r)
      sgn = _minusone_if_even_else_one(m+p+1)
      iszero(s) && return sgn*u_p*v_m

      q = _findfirst_val_or_zero(j-> (I[j]+s)‚àâJ, (p+1), k)
      u_q = _u(q,F,I)
      sgn *= _minusone_if_even_else_one(q+1)
      return sgn * v_m * (u_q - u_p)
    end

    u, v = _u(F,I,Vk), _v(Œ±,J,r,Vk)
    if iszero(s)
      return 1 + sum( u .* v )
    else
      Œ®_IJ = one(T)
      sum_v = v[1]
      for l in 1:p-1
        vlp = v[l+1]
        sum_v += vlp
        Œ®_IJ += vlp*u[l]
      end
      for l in (p+1):k
        vl = v[l]
        sum_v += vl
        Œ®_IJ += vl*u[l]
      end
      sgn = _minusone_if_even_else_one(p+1)
      return sgn * (Œ®_IJ - u[p]*sum_v)
    end

  end
  @unreachable
end

@propagate_inbounds _u(i::Int,F,I)   = Int(isone(F[1])) - Int(I[i]+1 in F)
@propagate_inbounds _u(F::Vector{Int},I,Vk) = ntuple(i->_u(i,F,I), Vk)
@propagate_inbounds _v(j::Int,Œ±,J,r) = Œ±[J[j]]/r
@propagate_inbounds _v(Œ±::Vector{Int},J,r,Vk) = ntuple(j->_v(j,Œ±,J,r), Vk)

# API

function _evaluate_nd!(
  b::PLambdaBasis{D}, x,
  œâ::AbstractMatrix, i, cB,
  ::Val{r}) where {D,r}

  Œª = _cart_to_bary(x, _get_cart_to_bary_matrix(b))

  # _evaluate_nd!(::BernsteinBasisOnSimplex) without set_value
  cB[1] = 1
  _downwards_de_Casteljau_nD!(cB,Œª,Val(r),Val(D))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Œ±_id) in bubble_functions
      Œ®w = b.Œ®[w]
      BŒ± = cB[Œ±_id]
      œâ[i,w] = BŒ± * Œ®w
    end
  end
end

function _gradient_nd!(
  b::PLambdaBasis{D}, x,
  ‚àáœâ::AbstractMatrix, i, cB,
  ‚àáB::AbstractMatrix{<:VectorValue{D}},
  s::MVector{D},
  ::Val{r}) where {D,r}

  _gradient_nd!(b.scalar_bernstein_basis, x, ‚àáB, 1, cB, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Œ±_id) in bubble_functions
      Œ®w = b.Œ®[w]
      ‚àáBŒ± = ‚àáB[1,Œ±_id]
      ‚àáœâ[i,w] = ‚àáBŒ± ‚äó Œ®w
    end
  end
end

function _hessian_nd!(
  b::PLambdaBasis{D}, x,
  Hœâ::AbstractMatrix, i, cB,
  ::Nothing,
  HB::AbstractMatrix{<:TensorValue{D,D}},
  s::MMatrix{D,D},
  ::Val{r}) where {D,r}

  _hessian_nd!(b.scalar_bernstein_basis, x, HB, 1, cB, nothing, nothing, s, Val(r))

  @inbounds for (_, bubble_functions) in get_bubbles(b)
    for (w, _, Œ±_id) in bubble_functions
      Œ®w = b.Œ®[w]
      HBŒ± = HB[1,Œ±_id]
      Hœâ[i,w] = HBŒ± ‚äó Œ®w
    end
  end
end


#########################################################
# Combination, Bernstein term and PLambda bases helpers #
#########################################################

# A combination is a set of positive integers sorted in increasing order
# a.k.a an increasing collection of indices in a range 1:D
#     F  = 1 ‚â§ F1 < ... < Fd ‚â§ D
# It is used to represent faces of polytopes (the indices iddentifying the
# vertices of the face) or a component of a k-form as in (1,3) ~ dx¬π‚àßdx¬≥ .

"""
    _sorted_combinations(D,k)

Return a vector of all the combinations I_i of {1:`D`} of length `k`:

1 ‚â§ I\\_1 < ... < I\\_k ‚â§ `D`

sorted in right-digit to left-digit lexicographic order, e.g.

```julia
[ [1,2], [1,3], [2,3] ]  # for D=3, k=2\\
[ [1,2], [1,3], [2,3], [1,4], [2,4], [3,4] ]  # for D=4, k=2
```

This example shows that this order of sorted combinations of same length `k` is
independent of the dimension `D`, unlike with the usual (left-digit to right-digit)
lexicographic order where 14 would be smaller than 23.

So with the chosen order, 23 is always the third length-2 combination, not the `D`·µó ∞.
"""
function _sorted_combinations(D::Int,k::Int)
  iszero(k) &&  return Vector{Int}[ Int[] ]
  comp_rev_perm(tup) =  Int[D-tup[k-i+1]+1 for i in 1:k]
  inc_perms = combinations(1:D,k) .|> (tup -> comp_rev_perm(tup)) |> reverse
  return inc_perms
end

"""
    _combination_index(I)

Linear index of `I` amongst combinations of the same size `k`,
sorted in right-to-left lexicographic order. It depends on `k` but not on the
space dimension, see [`_sorted_combinations`](@ref).
"""
@inline function _combination_index(combi)
  k = length(combi)
  return sum( binomial(combi[i]-1, i) for i in 1:k; init=0) + 1
end

"""
    _complement(I, D)

Given a k-combination `I` of elements of `1:D`, returns the unique (`D`-k)
combination of `1:D` "`Icomp`" such that `I ‚à™ Icomp ‚äá 1:D`.
"""
function _complement(combi, D)
  k = length(combi)
  combi_comp = Vector{Int}(undef, D-k)
  curr_perm, curr_comp = 1, 1
  for i in 1:D
    if curr_perm ‚â§ k && combi[curr_perm] == i
      curr_perm += 1
    else
      combi_comp[curr_comp] = i
      curr_comp += 1
    end
  end
  combi_comp
end

"""
    _combination_sign(I)

Given a combination `I`, returns the sign of the permutation resulting from
the concatenation of `I` and its complement [`_complement(I)`](@ref _complement).
"""
function _combination_sign(combi)
  i, k, acc, delta = 1, 1, 0, 0
  while k <= length(combi)
    if combi[k] == i
      acc += delta
      k += 1
    else
      delta += 1
    end
    i += 1
  end
  return iseven(acc) ? 1 : -1
end

"""
    _sub_combinations_ids(J)

Return a vector containing the `k-1` combinations `J\\J[i]` for 1 ‚â§ i ‚â§ `k`,
where `k=length(J)`.
"""
function _sub_combinations_ids(combi)
  k = length(combi)
  sub_combi = MVector{k-1,Int}(undef)
  sub_combi_ids = Vector{Int}(undef, k)
  for i in 1:k
    sub_combi .= ntuple(j -> combi[j + Int(j‚â•i)],k-1)
    sub_combi_id = _combination_index(sub_combi)
    sub_combi_ids[i] = sub_combi_id
  end
  sub_combi_ids
end

"""
    _sup_multi_indices(Œ±)

Given `Œ±` a Bernstein term of length N, return the [`bernstein_term_id `](@ref)
of the N terms `Œ±`+e·µ¢ for 1 ‚â§ i ‚â§ N in a Vector (in order of i increasing).
"""
function _sup_multi_indices(Œ±)
  N = length(Œ±)
  sup_Œ± = MVector{N,Int}(undef)
  sup_Œ±_ids = Vector{Int}(undef, N)
  for i in 1:N
    sup_Œ± .=  ntuple(k -> Œ±[k]+Int(k==i), N)
    sup_Œ±_id = bernstein_term_id(sup_Œ±)
    sup_Œ±_ids[i] = sup_Œ±_id
  end
  return sup_Œ±_ids
end

"""
    _support(Œ±)

Given a bernstein multi-index `Œ±`, returns the set of indices `i` such that `Œ±·µ¢`>0.
"""
function _support(Œ±)
  s = Int[]
  for (i,Œ±i) in enumerate(Œ±)
    if Œ±i > 0
      push!(s, i)
    end
  end
  s
end

"""
    _minor(M,I,J,::Val{k})

Computes the minor (determinant of sub-matrix) of the matrix M where the rows of
indices i‚àà`I` and column of indics j‚àà`J` are kept. `k` is the length of both `I`
and `J`.
"""
function _minor(M,I,J,::Val{k}) where k
  @check length(I) == length(J)
  @check I ‚äÜ axes(M)[1]
  @check J ‚äÜ axes(M)[2]

  T = eltype(M)
  m = MMatrix{k,k,T,k*k}(undef)
  for (i, Ii) in enumerate(take(I,k))
    for (j, Jj) in enumerate(take(J,k))
      @inbounds m[i,j] = M[Ii,Jj]
    end
  end
  det(m)
end

@propagate_inbounds function _minusone_if_even_else_one(i)
  iseven(i) ? -1 : 1
end

@propagate_inbounds function _findfirst_val_or_zero(pred, start, stop)
  r = findfirst(pred,start:stop)
  return isnothing(r) ? 0 : r+start-1
end

@propagate_inbounds function _minimum_or_one(s)
  maxint = typemax(Int)
  j = minimum(s, init=maxint)
  j = (j==maxint) ? 1 : j
end
