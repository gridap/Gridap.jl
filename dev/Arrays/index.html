<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gridap.Arrays · Gridap.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gridap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../Gridap/">Gridap</a></li><li><a class="tocitem" href="../Helpers/">Gridap.Helpers</a></li><li><a class="tocitem" href="../Io/">Gridap.Io</a></li><li><a class="tocitem" href="../Algebra/">Gridap.Algebra</a></li><li class="is-active"><a class="tocitem" href>Gridap.Arrays</a></li><li><a class="tocitem" href="../TensorValues/">Gridap.TensorValues</a></li><li><a class="tocitem" href="../Fields/">Gridap.Fields</a></li><li><a class="tocitem" href="../Polynomials/">Gridap.Polynomials</a></li><li><a class="tocitem" href="../ReferenceFEs/">Gridap.ReferenceFEs</a></li><li><a class="tocitem" href="../Geometry/">Gridap.Geometry</a></li><li><a class="tocitem" href="../CellData/">Gridap.CellData</a></li><li><a class="tocitem" href="../Visualization/">Gridap.Visualization</a></li><li><a class="tocitem" href="../FESpaces/">Gridap.FESpaces</a></li><li><a class="tocitem" href="../MultiField/">Gridap.MultiField</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gridap.Arrays</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gridap.Arrays</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Gridap.jl/blob/master/docs/src/Arrays.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Gridap.Arrays"><a class="docs-heading-anchor" href="#Gridap.Arrays">Gridap.Arrays</a><a id="Gridap.Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Gridap.Arrays" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays" href="#Gridap.Arrays"><code>Gridap.Arrays</code></a> — <span class="docstring-category">Module</span></header><section><div><p>This module provides:</p><ul><li>An extension of the <code>AbstractArray</code> interface in order to properly deal with mutable caches.</li><li>A mechanism to generate lazy arrays resulting from operations between arrays.</li><li>A collection of concrete implementations of <code>AbstractArray</code>.</li></ul><p>The exported names in this module are:</p><ul><li><a href="@ref"><code>AddEntriesMap</code></a></li><li><a href="@ref"><code>AppendedArray</code></a></li><li><a href="#Gridap.Arrays.Broadcasting"><code>Broadcasting</code></a></li><li><a href="#Gridap.Arrays.CachedArray"><code>CachedArray</code></a></li><li><a href="#Gridap.Arrays.CachedMatrix"><code>CachedMatrix</code></a></li><li><a href="#Gridap.Arrays.CachedVector"><code>CachedVector</code></a></li><li><a href="#Gridap.Arrays.CompressedArray"><code>CompressedArray</code></a></li><li><a href="@ref"><code>FilterMap</code></a></li><li><a href="#Gridap.Arrays.IdentityVector"><code>IdentityVector</code></a></li><li><a href="#Gridap.Arrays.LazyArray"><code>LazyArray</code></a></li><li><a href="#Gridap.Arrays.Map"><code>Map</code></a></li><li><a href="@ref"><code>MulAddMap</code></a></li><li><a href="#Gridap.Arrays.Operation"><code>Operation</code></a></li><li><a href="#Gridap.Arrays.PosNegPartition"><code>PosNegPartition</code></a></li><li><a href="#Gridap.Arrays.PosNegReindex"><code>PosNegReindex</code></a></li><li><a href="#Gridap.Arrays.Reindex"><code>Reindex</code></a></li><li><a href="#Gridap.Arrays.SubVector"><code>SubVector</code></a></li><li><a href="#Gridap.Arrays.Table"><code>Table</code></a></li><li><a href="@ref"><code>TouchEntriesMap</code></a></li><li><a href="@ref"><code>TreeNode</code></a></li><li><a href="#Gridap.Arrays.UNSET"><code>UNSET</code></a></li><li><a href="@ref"><code>VectorWithEntryInserted</code></a></li><li><a href="@ref"><code>VectorWithEntryRemoved</code></a></li><li><a href="#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>append_ptrs</code></a></li><li><a href="#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>append_ptrs!</code></a></li><li><a href="#Gridap.Arrays.append_tables_globally-Union{Tuple{Vararg{Gridap.Arrays.Table{T, Vd, Vp}, N} where N}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}"><code>append_tables_globally</code></a></li><li><a href="#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}"><code>append_tables_locally</code></a></li><li><a href="#Gridap.Arrays.array_cache-Tuple{AbstractArray}"><code>array_cache</code></a></li><li><a href="@ref"><code>autodiff_array_gradient</code></a></li><li><a href="@ref"><code>autodiff_array_hessian</code></a></li><li><a href="@ref"><code>autodiff_array_jacobian</code></a></li><li><a href="#Gridap.Arrays.collect1d-Tuple{Any}"><code>collect1d</code></a></li><li><a href="#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}"><code>empty_table</code></a></li><li><a href="#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any, N} where N}"><code>evaluate</code></a></li><li><a href="#Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any, N} where N}"><code>evaluate!</code></a></li><li><a href="#Gridap.Arrays.find_inverse_index_map"><code>find_inverse_index_map</code></a></li><li><a href="#Gridap.Arrays.find_inverse_index_map!-Tuple{Any, Any}"><code>find_inverse_index_map!</code></a></li><li><a href="#Gridap.Arrays.find_local_index-Tuple{Any, Any}"><code>find_local_index</code></a></li><li><a href="#Gridap.Arrays.flatten_partition"><code>flatten_partition</code></a></li><li><a href="#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var&quot;#s43&quot;, N} where {var&quot;#s43&quot;&lt;:(AbstractArray{T, N} where N), N}}, Tuple{T}} where T"><code>generate_data_and_ptrs</code></a></li><li><a href="#Gridap.Arrays.get_array-Tuple{AbstractArray}"><code>get_array</code></a></li><li><a href="#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}"><code>get_data_eltype</code></a></li><li><a href="@ref"><code>get_local_item</code></a></li><li><a href="#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}"><code>get_ptrs_eltype</code></a></li><li><a href="#Gridap.Arrays.getindex!-Tuple{Any, AbstractArray, Vararg{Any, N} where N}"><code>getindex!</code></a></li><li><a href="#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}"><code>identity_table</code></a></li><li><a href="#Gridap.Arrays.inverse_map-Tuple{Any}"><code>inverse_map</code></a></li><li><a href="#Gridap.Arrays.lazy_append-Tuple{AbstractArray, AbstractArray}"><code>lazy_append</code></a></li><li><a href="#Gridap.Arrays.lazy_map-Tuple{Any, Type, Vararg{AbstractArray, N} where N}"><code>lazy_map</code></a></li><li><a href="#Gridap.Arrays.lazy_split-Tuple{AbstractArray, Integer}"><code>lazy_split</code></a></li><li><a href="../Algebra/#Gridap.Algebra.length_to_ptrs!-Tuple{AbstractArray{var&quot;#s2&quot;, N} where {var&quot;#s2&quot;&lt;:Integer, N}}"><code>length_to_ptrs!</code></a></li><li><a href="#Gridap.Arrays.pair_arrays-Tuple{AbstractArray, AbstractArray}"><code>pair_arrays</code></a></li><li><a href="@ref"><code>print_op_tree</code></a></li><li><a href="#Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any, N} where N}"><code>return_cache</code></a></li><li><a href="#Gridap.Arrays.return_type-Tuple{Any, Vararg{Any, N} where N}"><code>return_type</code></a></li><li><a href="@ref"><code>return_value</code></a></li><li><a href="../Algebra/#Gridap.Algebra.rewind_ptrs!-Tuple{AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Integer}"><code>rewind_ptrs!</code></a></li><li><a href="#Gridap.Arrays.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{Gridap.Arrays.CachedArray{T, N, A} where A&lt;:AbstractArray{T, N}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>setsize!</code></a></li><li><a href="@ref"><code>similar_tree_node</code></a></li><li><a href="#Gridap.Arrays.test_array-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}, Any}} where {T, S, N}"><code>test_array</code></a></li><li><a href="#Gridap.Arrays.test_map-Tuple{Any, Any, Vararg{Any, N} where N}"><code>test_map</code></a></li><li><a href="#Gridap.Arrays.testargs-Tuple{Any, Vararg{Any, N} where N}"><code>testargs</code></a></li><li><a href="#Gridap.Arrays.testitem-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>testitem</code></a></li><li><a href="#Gridap.Arrays.testvalue"><code>testvalue</code></a></li><li><a href="#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var&quot;#s41&quot;, N} where {var&quot;#s41&quot;&lt;:(Tuple{var&quot;#s40&quot;, var&quot;#s39&quot;} where {var&quot;#s40&quot;, var&quot;#s39&quot;}), N}}"><code>unpair_arrays</code></a></li><li><a href="@ref"><code>∑</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Arrays.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.UNSET" href="#Gridap.Arrays.UNSET"><code>Gridap.Arrays.UNSET</code></a> — <span class="docstring-category">Constant</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Broadcasting" href="#Gridap.Arrays.Broadcasting"><code>Gridap.Arrays.Broadcasting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Broadcasting(f)</code></pre><p>Returns a mapping that represents the &quot;broadcasted&quot; version of the function <code>f</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Gridap.Arrays

a = [3,2]
b = [2,1]

bm = Broadcasting(+)

c = evaluate(bm,a,b)

println(c)

# output
[5, 3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L123-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedArray" href="#Gridap.Arrays.CachedArray"><code>Gridap.Arrays.CachedArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct CachedArray{T, N, A&lt;:AbstractArray{T, N}} &lt;: AbstractArray{T, N}</code></pre><p>Type providing a re-sizable array.</p><p>The size of a <code>CachedArray</code> is changed via the <a href="#Gridap.Arrays.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{Gridap.Arrays.CachedArray{T, N, A} where A&lt;:AbstractArray{T, N}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>setsize!</code></a> function.</p><p>A <code>CachedArray</code> can be build with the constructors</p><ul><li><a href="#Gridap.Arrays.CachedArray"><code>CachedArray(a::AbstractArray)</code></a></li><li><a href="#Gridap.Arrays.CachedArray-Tuple{Any, Any}"><code>CachedArray(T,N)</code></a></li></ul><pre><code class="language-julia">using Gridap.Arrays
# Create an empty CachedArray
a = CachedArray(Float64,2)
# Resize to new shape (2,3)
setsize!(a,(2,3))
size(a)
# output
(2, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedArray-Tuple{Any, Any}" href="#Gridap.Arrays.CachedArray-Tuple{Any, Any}"><code>Gridap.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedArray(T,N)</code></pre><p>Constructs an empty <code>CachedArray</code> of element type <code>T</code> and <code>N</code> dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedArray-Union{Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A&lt;:AbstractArray{T, N}}" href="#Gridap.Arrays.CachedArray-Union{Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A&lt;:AbstractArray{T, N}}"><code>Gridap.Arrays.CachedArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedArray(a::AbstractArray)</code></pre><p>Constructs a <code>CachedArray</code> from a given array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedMatrix" href="#Gridap.Arrays.CachedMatrix"><code>Gridap.Arrays.CachedMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const CachedMatrix{T,A} = CachedArray{T,2,A}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedMatrix-Tuple{AbstractMatrix{T} where T}" href="#Gridap.Arrays.CachedMatrix-Tuple{AbstractMatrix{T} where T}"><code>Gridap.Arrays.CachedMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedMatrix(a)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedMatrix-Tuple{Any}" href="#Gridap.Arrays.CachedMatrix-Tuple{Any}"><code>Gridap.Arrays.CachedMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedMatrix(T)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedVector" href="#Gridap.Arrays.CachedVector"><code>Gridap.Arrays.CachedVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const CachedVector{T,A} = CachedArray{T,1,A}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L45-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedVector-Tuple{AbstractVector{T} where T}" href="#Gridap.Arrays.CachedVector-Tuple{AbstractVector{T} where T}"><code>Gridap.Arrays.CachedVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedVector(a)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CachedVector-Tuple{Any}" href="#Gridap.Arrays.CachedVector-Tuple{Any}"><code>Gridap.Arrays.CachedVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CachedVector(T)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CompressedArray" href="#Gridap.Arrays.CompressedArray"><code>Gridap.Arrays.CompressedArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CompressedArray{T,N,A,P} &lt;: AbstractArray{T,N}
  values::A
  ptrs::P
end</code></pre><p>Type representing an array with a reduced set of values. The array is represented by a short array of values, namely the field <code>values</code>, and a large array of indices, namely the field <code>ptrs</code>. The <code>i</code>-th component of the resulting array is defined as <code>values[ptrs[i]]</code>. The type parameters <code>A</code>, and <code>P</code> are restricted to be array types by the inner constructor of this <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CompressedArrays.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.CompressedArray-Tuple{AbstractArray, AbstractArray}" href="#Gridap.Arrays.CompressedArray-Tuple{AbstractArray, AbstractArray}"><code>Gridap.Arrays.CompressedArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CompressedArray(values::AbstractArray,ptrs::AbstractArray)</code></pre><p>Creates a <code>CompressedArray</code> object by the given arrays of <code>values</code> and <code>ptrs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CompressedArrays.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.IdentityVector" href="#Gridap.Arrays.IdentityVector"><code>Gridap.Arrays.IdentityVector</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/IdentityVectors.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.LazyArray" href="#Gridap.Arrays.LazyArray"><code>Gridap.Arrays.LazyArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Subtype of <code>AbstractArray</code> which is the result of <code>lazy_map</code>. It represents the result of lazy_mapping a <code>Map</code> to a set of arrays that contain the mapping arguments. This struct makes use of the cache provided by the mapping in order to compute its indices (thus allowing to prevent allocation). The array is lazy, i.e., the values are only computed on demand. It extends the <code>AbstractArray</code> API with two methods:</p><p><code>array_cache(a::AbstractArray)</code>    <code>getindex!(cache,a::AbstractArray,i...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/LazyArrays.jl#L82-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Map" href="#Gridap.Arrays.Map"><code>Gridap.Arrays.Map</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing a function (mapping) that provides a cache and an in-place evaluation for performance. This is the type to be used in the <a href="#Gridap.Arrays.lazy_map-Tuple{Any, Type, Vararg{AbstractArray, N} where N}"><code>lazy_map</code></a> function.</p><p>Derived types must implement the following method:</p><ul><li><a href="#Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any, N} where N}"><code>evaluate!(cache,k,x...)</code></a></li></ul><p>and optionally these ones:</p><ul><li><a href="#Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any, N} where N}"><code>return_cache(k,x...)</code></a></li><li><a href="#Gridap.Arrays.return_type-Tuple{Any, Vararg{Any, N} where N}"><code>return_type(k,x...)</code></a></li></ul><p>The mapping interface can be tested with the <a href="#Gridap.Arrays.test_map-Tuple{Any, Any, Vararg{Any, N} where N}"><code>test_map</code></a> function.</p><p>Note that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from <code>Map</code>. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from <code>Map</code>. For instance, a default implementation is available for <code>Function</code> objects.  However, we recommend that new types inherit from <code>Map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Operation" href="#Gridap.Arrays.Operation"><code>Gridap.Arrays.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Operation(op)</code></pre><p>Retuns the map that results after applying an operation <code>f</code> over a set of map(s) <code>args</code>. That is <code>Operation(f)(args)(x...)</code> is formally defined as <code>f(map(a-&gt;a(x...),args)...)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Gridap.Arrays

fa(x) = x.*x
fb(x) = sqrt.(x)

x = collect(0:5)

fab = Operation(fa)(fb)
c = evaluate(fab,x)

println(c)

# output
[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L244-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.OperationMap" href="#Gridap.Arrays.OperationMap"><code>Gridap.Arrays.OperationMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OperationMap(f,args)</code></pre><p>Returns a mapping that represents the result of applying the function <code>f</code> to the arguments in the tuple <code>args</code>. That is, <code>OperationMap(f,args)(x...)</code> is formally defined as <code>f(map(a-&gt;a(x...),args)...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L213-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.PosNegPartition" href="#Gridap.Arrays.PosNegPartition"><code>Gridap.Arrays.PosNegPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct representing a binary partition of a range of indices</p><p>Using this allows one to do a number of important optimizations when working with <code>PosNegReindex</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/PosNegReindex.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.PosNegReindex" href="#Gridap.Arrays.PosNegReindex"><code>Gridap.Arrays.PosNegReindex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PosNegReindex(values_pos,values_neg)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/PosNegReindex.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Reindex" href="#Gridap.Arrays.Reindex"><code>Gridap.Arrays.Reindex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Reindex(values) -&gt; Map</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Reindex.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.SubVector" href="#Gridap.Arrays.SubVector"><code>Gridap.Arrays.SubVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SubVector{T,A&lt;:AbstractVector{T}} &lt;: AbstractVector{T}
  vector::A
  pini::Int
  pend::Int
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/SubVectors.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Table" href="#Gridap.Arrays.Table"><code>Gridap.Arrays.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> struct Table{T,Vd&lt;:AbstractVector{T},Vp&lt;:AbstractVector} &lt;: AbstractVector{Vector{T}}
    data::Vd
    ptrs::Vp
 end</code></pre><p>Type representing a list of lists (i.e., a table) in compressed format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.Table-Tuple{AbstractArray{var&quot;#s42&quot;, N} where {var&quot;#s42&quot;&lt;:AbstractArray, N}}" href="#Gridap.Arrays.Table-Tuple{AbstractArray{var&quot;#s42&quot;, N} where {var&quot;#s42&quot;&lt;:AbstractArray, N}}"><code>Gridap.Arrays.Table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Table(a::AbstractArray{&lt;:AbstractArray})</code></pre><p>Build a table from a vector of vectors. If the inputs are multidimensional arrays instead of vectors, they are flattened.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T" href="#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>Gridap.Arrays.append_ptrs!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T" href="#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>Gridap.Arrays.append_ptrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append_ptrs(pa,pb)</code></pre><p>Append two vectors of pointers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_tables_globally-Union{Tuple{Vararg{Gridap.Arrays.Table{T, Vd, Vp}, N} where N}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}" href="#Gridap.Arrays.append_tables_globally-Union{Tuple{Vararg{Gridap.Arrays.Table{T, Vd, Vp}, N} where N}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}"><code>Gridap.Arrays.append_tables_globally</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}" href="#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}"><code>Gridap.Arrays.append_tables_locally</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table, N} where N}" href="#Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table, N} where N}"><code>Gridap.Arrays.append_tables_locally</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append_tables_locally(tables::Table...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L258-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.array_cache-Tuple{AbstractArray}" href="#Gridap.Arrays.array_cache-Tuple{AbstractArray}"><code>Gridap.Arrays.array_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array_cache(a::AbstractArray)</code></pre><p>Returns a cache object to be used in the <a href="#Gridap.Arrays.getindex!-Tuple{Any, AbstractArray, Vararg{Any, N} where N}"><code>getindex!</code></a> function. It defaults to</p><pre><code class="language-none">array_cache(a::T) where T = nothing</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(false)</code>, and</p><pre><code class="language-none">function array_cache(a::T) where T
  hash = Dict{UInt,Any}()
  array_cache(hash,a)
end</code></pre><p>for types <code>T</code> such that <code>uses_hash(T) == Val(true)</code>, see the <a href="#Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:AbstractArray}"><code>uses_hash</code></a> function. In the later case, the type <code>T</code> should implement the following signature:</p><pre><code class="language-none">array_cache(hash::Dict,a::AbstractArray)</code></pre><p>where we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object <code>a</code> has already built a cache and re-use it as follows</p><pre><code class="language-none">id = objectid(a)
if haskey(hash,id)
  cache = hash[id] # Reuse cache
else
  cache = ... # Build a new cache depending on your needs
  hash[id] = cache # Register the cache in the hash table
end</code></pre><p>This mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L53-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.collect1d-Tuple{Any}" href="#Gridap.Arrays.collect1d-Tuple{Any}"><code>Gridap.Arrays.collect1d</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect1d(a)</code></pre><p>Equivalent to</p><pre><code class="language-none">[a[i] for in 1:length(a)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L322-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}" href="#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}"><code>Gridap.Arrays.empty_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">empty_table(::Type{T},::Type{P}, l::Integer) where {T,P}
empty_table(l::Integer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L53-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any, N} where N}" href="#Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any, N} where N}"><code>Gridap.Arrays.evaluate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate!(cache,f,x...)</code></pre><p>Applies the mapping <code>f</code> at the arguments <code>x...</code> using the scratch data provided in the given <code>cache</code> object. The <code>cache</code> object is built with the <a href="#Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any, N} where N}"><code>return_cache</code></a> function using arguments of the same type as in <code>x</code>. In general, the returned value <code>y</code> can share some part of its state with the <code>cache</code> object. If the result of two or more calls to this function need to be accessed simultaneously (e.g., in multi-threading), create and use several <code>cache</code> objects (e.g., one cache per thread).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L35-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any, N} where N}" href="#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any, N} where N}"><code>Gridap.Arrays.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate(f,x...)</code></pre><p>evaluates the mapping <code>f</code> at the arguments in <code>x</code> by creating a temporary cache internally. This functions is equivalent to</p><pre><code class="language-jl">cache = return_cache(f,x...)
evaluate!(cache,f,x...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L75-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.find_inverse_index_map" href="#Gridap.Arrays.find_inverse_index_map"><code>Gridap.Arrays.find_inverse_index_map</code></a> — <span class="docstring-category">Function</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.find_inverse_index_map!-Tuple{Any, Any}" href="#Gridap.Arrays.find_inverse_index_map!-Tuple{Any, Any}"><code>Gridap.Arrays.find_inverse_index_map!</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.find_local_index-Tuple{Any, Any}" href="#Gridap.Arrays.find_local_index-Tuple{Any, Any}"><code>Gridap.Arrays.find_local_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_local_index(a_to_b, b_to_la_to_a)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L353-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.flatten_partition" href="#Gridap.Arrays.flatten_partition"><code>Gridap.Arrays.flatten_partition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten_partition(a_to_bs::Table,nb::Integer)
flatten_partition(a_to_bs::Table)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L387-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var&quot;#s43&quot;, N} where {var&quot;#s43&quot;&lt;:(AbstractArray{T, N} where N), N}}, Tuple{T}} where T" href="#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{var&quot;#s43&quot;, N} where {var&quot;#s43&quot;&lt;:(AbstractArray{T, N} where N), N}}, Tuple{T}} where T"><code>Gridap.Arrays.generate_data_and_ptrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">data, ptrs = generate_data_and_ptrs(vv)</code></pre><p>Given a vector of vectors, compress it and return the corresponding data and and ptrs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_array-Tuple{AbstractArray}" href="#Gridap.Arrays.get_array-Tuple{AbstractArray}"><code>Gridap.Arrays.get_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_array(a::AbstractArray)</code></pre><p>Returns <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L225-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}" href="#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}"><code>Gridap.Arrays.get_data_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}" href="#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}"><code>Gridap.Arrays.get_ptrs_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.getindex!-Tuple{Any, AbstractArray, Vararg{Any, N} where N}" href="#Gridap.Arrays.getindex!-Tuple{Any, AbstractArray, Vararg{Any, N} where N}"><code>Gridap.Arrays.getindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex!(cache,a::AbstractArray,i...)</code></pre><p>Returns the item of the array <code>a</code> associated with index <code>i</code> by (possibly) using the scratch data passed in the <code>cache</code> object.</p><p>It defaults to</p><pre><code class="language-none">getindex!(cache,a::AbstractArray,i...) = a[i...]</code></pre><p>As for standard Julia arrays, the user needs to implement only one of the following signatures depending on the <code>IndexStyle</code> of the array.</p><pre><code class="language-none">getindex!(cache,a::AbstractArray,i::Integer)
getindex!(cache,a::AbstractArray{T,N},i::Vararg{Integer,N}) where {T,N}</code></pre><p><strong>Examples</strong></p><p>Iterating over an array using the <code>getindex!</code> function</p><pre><code class="language-julia">using Gridap.Arrays

a = collect(10:15)

cache = array_cache(a)
for i in eachindex(a)
  ai = getindex!(cache,a,i)
  println(&quot;$i -&gt; $ai&quot;)
end

# output
1 -&gt; 10
2 -&gt; 11
3 -&gt; 12
4 -&gt; 13
5 -&gt; 14
6 -&gt; 15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L1-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}" href="#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}"><code>Gridap.Arrays.identity_table</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Tables.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.inverse_map-Tuple{Any}" href="#Gridap.Arrays.inverse_map-Tuple{Any}"><code>Gridap.Arrays.inverse_map</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.lazy_append-Tuple{AbstractArray, AbstractArray}" href="#Gridap.Arrays.lazy_append-Tuple{AbstractArray, AbstractArray}"><code>Gridap.Arrays.lazy_append</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/AppendedArrays.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.lazy_map-Tuple{Any, Type, Vararg{AbstractArray, N} where N}" href="#Gridap.Arrays.lazy_map-Tuple{Any, Type, Vararg{AbstractArray, N} where N}"><code>Gridap.Arrays.lazy_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lazy_map(f,::Type{T},a::AbstractArray...) where T</code></pre><p>Like <a href="#Gridap.Arrays.lazy_map-Tuple{Any, Vararg{AbstractArray, N} where N}"><code>lazy_map(f,a::AbstractArray...)</code></a>, but the user provides the element type of the resulting array in order to circumvent type inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/LazyArrays.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.lazy_map-Tuple{Any, Vararg{AbstractArray, N} where N}" href="#Gridap.Arrays.lazy_map-Tuple{Any, Vararg{AbstractArray, N} where N}"><code>Gridap.Arrays.lazy_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lazy_map(f,a::AbstractArray...) -&gt; AbstractArray</code></pre><p>Applies the <code>Map</code> (or <code>Function</code>) <code>f</code> to the entries of the arrays in <code>a</code> (see the definition of <a href="#Gridap.Arrays.Map"><code>Map</code></a>).</p><p>The resulting array <code>r</code> is such that <code>r[i]</code> equals to <code>evaluate(f,ai...)</code> where <code>ai</code> is the tuple containing the <code>i</code>-th entry of the arrays in <code>a</code> (see function <a href="#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any, N} where N}"><code>evaluate</code></a> for more details). In other words, the resulting array is numerically equivalent to:</p><pre><code class="language-none">map( (x...)-&gt;evaluate(f,x...), a...)</code></pre><p><strong>Examples</strong></p><p>Using a function as mapping</p><pre><code class="language-julia">using Gridap.Arrays

a = collect(0:5)
b = collect(10:15)

c = lazy_map(+,a,b)

println(c)

# output
[10, 12, 14, 16, 18, 20]</code></pre><p>Using a user-defined mapping</p><pre><code class="language-julia">using Gridap.Arrays
import Gridap.Arrays: evaluate!

a = collect(0:5)
b = collect(10:15)

struct MySum &lt;: Map end

evaluate!(cache,::MySum,x,y) = x + y

k = MySum()

c = lazy_map(k,a,b)

println(c)

# output
[10, 12, 14, 16, 18, 20]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/LazyArrays.jl#L1-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.lazy_split-Tuple{AbstractArray, Integer}" href="#Gridap.Arrays.lazy_split-Tuple{AbstractArray, Integer}"><code>Gridap.Arrays.lazy_split</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/AppendedArrays.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.pair_arrays-Tuple{AbstractArray, AbstractArray}" href="#Gridap.Arrays.pair_arrays-Tuple{AbstractArray, AbstractArray}"><code>Gridap.Arrays.pair_arrays</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/ArrayPairs.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any, N} where N}" href="#Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any, N} where N}"><code>Gridap.Arrays.return_cache</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">return_cache(f,x...)</code></pre><p>Returns the <code>cache</code> needed to lazy_map mapping <code>f</code> with arguments of the same type as the objects in <code>x</code>. This function returns <code>nothing</code> by default, i.e., no cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L26-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.return_type-Tuple{Any, Vararg{Any, N} where N}" href="#Gridap.Arrays.return_type-Tuple{Any, Vararg{Any, N} where N}"><code>Gridap.Arrays.return_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">return_type(f,x...)</code></pre><p>Returns the type of the result of calling mapping <code>f</code> with arguments of the types of the objects <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{Gridap.Arrays.CachedArray{T, N, A} where A&lt;:AbstractArray{T, N}, Tuple{Vararg{Int64, N}}}} where {T, N}" href="#Gridap.Arrays.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{Gridap.Arrays.CachedArray{T, N, A} where A&lt;:AbstractArray{T, N}, Tuple{Vararg{Int64, N}}}} where {T, N}"><code>Gridap.Arrays.setsize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setsize!(a, s)
</code></pre><p>Changes the size of the <code>CachedArray</code> <code>a</code> to the size described the the tuple <code>s</code>. After calling <code>setsize!</code>, the array can store uninitialized values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/CachedArrays.jl#L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.test_array-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}, Any}} where {T, S, N}" href="#Gridap.Arrays.test_array-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}, Any}} where {T, S, N}"><code>Gridap.Arrays.test_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">test_array(
  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}</code></pre><p>Checks if the entries in <code>a</code> and <code>b</code> are equal using the comparison function <code>cmp</code>. It also stresses the new methods added to the <code>AbstractArray</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L236-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.test_map-Tuple{Any, Any, Vararg{Any, N} where N}" href="#Gridap.Arrays.test_map-Tuple{Any, Any, Vararg{Any, N} where N}"><code>Gridap.Arrays.test_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">test_map(y,f,x...;cmp=(==))</code></pre><p>Function used to test if the mapping <code>f</code> has been implemented correctly. <code>f</code> is a <code>Map</code> sub-type, <code>x</code> is a tuple in the domain of the mapping and <code>y</code> is the expected result. Function <code>cmp</code> is used to compare the computed result with the expected one. The checks are done with the <code>@test</code> macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.testargs-Tuple{Any, Vararg{Any, N} where N}" href="#Gridap.Arrays.testargs-Tuple{Any, Vararg{Any, N} where N}"><code>Gridap.Arrays.testargs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">testargs(f,x...)</code></pre><p>The default implementation of this function is <code>testargs(f,x...) = x</code>. One can overload it in order to use <code>lazy_map</code> with 0-length array and maps with non-trivial domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Maps.jl#L66-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.testitem-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T" href="#Gridap.Arrays.testitem-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>Gridap.Arrays.testitem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns an arbitrary instance of <code>eltype(a)</code>. The default returned value is the first entry in the array if <code>length(a)&gt;0</code> and <code>testvalue(eltype(a))</code> if <code>length(a)==0</code> See the <a href="#Gridap.Arrays.testvalue"><code>testvalue</code></a> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using Gridap.Arrays

a = collect(3:10)
ai = testitem(a)

b = Int[]
bi = testitem(b)

(ai, bi)

# output
(3, 0)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.testvalue" href="#Gridap.Arrays.testvalue"><code>Gridap.Arrays.testvalue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testvalue(::Type{T}) where T</code></pre><p>Returns an arbitrary instance of type <code>T</code>. It defaults to <code>zero(T)</code> for non-array types and to an empty array for array types. It can be overloaded for new types <code>T</code> if <code>zero(T)</code> does not makes sense. This function is used to compute  <a href="#Gridap.Arrays.testitem-Union{Tuple{AbstractArray{T, N} where N}, Tuple{T}} where T"><code>testitem</code></a> for 0-length arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var&quot;#s41&quot;, N} where {var&quot;#s41&quot;&lt;:(Tuple{var&quot;#s40&quot;, var&quot;#s39&quot;} where {var&quot;#s40&quot;, var&quot;#s39&quot;}), N}}" href="#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{var&quot;#s41&quot;, N} where {var&quot;#s41&quot;&lt;:(Tuple{var&quot;#s40&quot;, var&quot;#s39&quot;} where {var&quot;#s40&quot;, var&quot;#s39&quot;}), N}}"><code>Gridap.Arrays.unpair_arrays</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/ArrayPairs.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:AbstractArray}" href="#Gridap.Arrays.uses_hash-Tuple{Type{var&quot;#s43&quot;} where var&quot;#s43&quot;&lt;:AbstractArray}"><code>Gridap.Arrays.uses_hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uses_hash(::Type{&lt;:AbstractArray})</code></pre><p>This function is used to specify if the type <code>T</code> uses the hash-based mechanism to reuse caches.  It should return either <code>Val(true)</code> or <code>Val(false)</code>. It defaults to</p><pre><code class="language-none">uses_hash(::Type{&lt;:AbstractArray}) = Val(false)</code></pre><p>Once this function is defined for the type <code>T</code> it can also be called on instances of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/2add52760c7a255dc2014f15546276898947073e/src/Arrays/Interface.jl#L95-L107">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Algebra/">« Gridap.Algebra</a><a class="docs-footer-nextpage" href="../TensorValues/">Gridap.TensorValues »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 18 November 2021 15:58">Thursday 18 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
