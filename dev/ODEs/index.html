<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gridap.ODEs · Gridap.jl</title><meta name="title" content="Gridap.ODEs · Gridap.jl"/><meta property="og:title" content="Gridap.ODEs · Gridap.jl"/><meta property="twitter:title" content="Gridap.ODEs · Gridap.jl"/><meta name="description" content="Documentation for Gridap.jl."/><meta property="og:description" content="Documentation for Gridap.jl."/><meta property="twitter:description" content="Documentation for Gridap.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gridap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Gridap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../Gridap/">Gridap</a></li><li><a class="tocitem" href="../Helpers/">Gridap.Helpers</a></li><li><a class="tocitem" href="../Io/">Gridap.Io</a></li><li><a class="tocitem" href="../Algebra/">Gridap.Algebra</a></li><li><a class="tocitem" href="../Arrays/">Gridap.Arrays</a></li><li><a class="tocitem" href="../TensorValues/">Gridap.TensorValues</a></li><li><a class="tocitem" href="../Fields/">Gridap.Fields</a></li><li><a class="tocitem" href="../Polynomials/">Gridap.Polynomials</a></li><li><a class="tocitem" href="../ReferenceFEs/">Gridap.ReferenceFEs</a></li><li><a class="tocitem" href="../Geometry/">Gridap.Geometry</a></li><li><a class="tocitem" href="../CellData/">Gridap.CellData</a></li><li><a class="tocitem" href="../Visualization/">Gridap.Visualization</a></li><li><a class="tocitem" href="../FESpaces/">Gridap.FESpaces</a></li><li><a class="tocitem" href="../MultiField/">Gridap.MultiField</a></li><li class="is-active"><a class="tocitem" href>Gridap.ODEs</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Classification-of-ODEs-and-numerical-schemes"><span>Classification of ODEs and numerical schemes</span></a></li><li><a class="tocitem" href="#Classification-of-ODEs"><span>Classification of ODEs</span></a></li><li><a class="tocitem" href="#Classification-of-numerical-schemes"><span>Classification of numerical schemes</span></a></li><li><a class="tocitem" href="#Classification-of-systems-of-equations"><span>Classification of systems of equations</span></a></li><li><a class="tocitem" href="#Reuse-across-iterations"><span>Reuse across iterations</span></a></li><li class="toplevel"><a class="tocitem" href="#High-level-API-in-Gridap"><span>High-level API in Gridap</span></a></li><li><a class="tocitem" href="#Finite-element-spaces"><span>Finite element spaces</span></a></li><li><a class="tocitem" href="#Cell-fields"><span>Cell fields</span></a></li><li><a class="tocitem" href="#Finite-element-operators"><span>Finite element operators</span></a></li><li><a class="tocitem" href="#The-TimeSpaceFunction-constructor"><span>The <code>TimeSpaceFunction</code> constructor</span></a></li><li><a class="tocitem" href="#Solver-and-solution"><span>Solver and solution</span></a></li><li class="toplevel"><a class="tocitem" href="#Low-level-implementation"><span>Low-level implementation</span></a></li><li><a class="tocitem" href="#ODE-operators"><span>ODE operators</span></a></li><li><a class="tocitem" href="#ODE-solvers"><span>ODE solvers</span></a></li><li><a class="tocitem" href="#Stage-operator"><span>Stage operator</span></a></li><li><a class="tocitem" href="#ODE-solution"><span>ODE solution</span></a></li><li class="toplevel"><a class="tocitem" href="#Numerical-schemes-formulation-and-implementation"><span>Numerical schemes formulation and implementation</span></a></li><li><a class="tocitem" href="#\\theta-method"><span><span>$\theta$</span>-method</span></a></li><li><a class="tocitem" href="#Generalised-\\alpha-scheme-for-first-order-ODEs"><span>Generalised-<span>$\alpha$</span> scheme for first-order ODEs</span></a></li><li><a class="tocitem" href="#Runge-Kutta"><span>Runge-Kutta</span></a></li><li><a class="tocitem" href="#Implicit-Explicit-Runge-Kutta"><span>Implicit-Explicit Runge-Kutta</span></a></li><li><a class="tocitem" href="#Generalised-\\alpha-scheme-for-second-order-ODEs"><span>Generalised-<span>$\alpha$</span> scheme for second-order ODEs</span></a></li><li class="toplevel"><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../Adaptivity/">Gridap.Adaptivity</a></li><li><span class="tocitem">Developper notes</span><ul><li><a class="tocitem" href="../dev-notes/block-assemblers/">Block Assemblers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gridap.ODEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gridap.ODEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gridap/Gridap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gridap/Gridap.jl/blob/master/docs/src/ODEs.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Gridap.ODEs"><a class="docs-heading-anchor" href="#Gridap.ODEs">Gridap.ODEs</a><a id="Gridap.ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Gridap.ODEs" title="Permalink"></a></h1><p>We consider an initial value problem written in the form</p><p class="math-container">\[\left\{\begin{array}{rcll}\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) &amp;=&amp; \boldsymbol{0}_{d}, \\ \partial_{t}^{k} \boldsymbol{u}(t_{0}) &amp;=&amp; \boldsymbol{u}_{0}^{k} &amp; 0 \leq k \leq n-1,\end{array}\right.\]</p><p>where</p><ul><li><span>$\boldsymbol{u}: \mathbb{R} \to \mathbb{R}^{d}$</span> is the unknown of the problem,</li><li><span>$n \in \mathbb{N}$</span> is the order of the ODE,</li><li><span>$t_{0} \in \mathbb{R}$</span> is the initial time and <span>$\{\boldsymbol{u}_{0}^{k}\}_{0 \leq k \leq n-1} \in (\mathbb{R}^{d})^{n-1}$</span> are the initial conditions, and</li><li><span>$\boldsymbol{r}: \mathbb{R} \times (\mathbb{R}^{d})^{n} \to \mathbb{R}^{d}$</span> is the residual.</li></ul><blockquote><p>We illustrate these notations on the semi-discretisation of the heat equation. It is a first-order ODE so we have <span>$n = 1$</span>, and <span>$d$</span> is the number of degrees of freedom. The residual and initial condition have the form</p><p class="math-container">\[\boldsymbol{r}(t, \boldsymbol{u}, \dot{\boldsymbol{u}}) \doteq \boldsymbol{M} \dot{\boldsymbol{u}} + \boldsymbol{K}(t) \boldsymbol{u} - \boldsymbol{f}(t), \qquad \boldsymbol{u}(t_{0}) = \boldsymbol{u}_{0}^{0},\]</p><p>where <span>$\boldsymbol{M} \in \mathbb{R}^{d \times d}$</span> is the mass matrix, <span>$\boldsymbol{K}: \mathbb{R} \to \mathbb{R}^{d \times d}$</span> is the stiffness matrix, <span>$\boldsymbol{f}: \mathbb{R} \to \mathbb{R}^{d}$</span> is the forcing term, and <span>$\boldsymbol{u}_{0}^{0}$</span> is the initial condition.</p></blockquote><p>Suppose that we are willing to approximate <span>$\boldsymbol{u}$</span> at a time <span>$t_{F} &gt; t_{0}$</span>. A numerical scheme splits the time interval <span>$[t_{0}, t_{F}]$</span> into smaller intervals <span>$[t_{n}, t_{n+1}]$</span> (that do not have to be of equal length) and propagates the information at time <span>$t_{n}$</span> to time <span>$t_{n+1}$</span>. More formally, we consider a general framework consisting of a starting, an update, and a finishing map defined as follows</p><ul><li>The <strong>starting map</strong> <span>$\mathcal{I}: (\mathbb{R}^{d})^{n} \to (\mathbb{R}^{d})^{s}$</span> converts the initial conditions into <span>$s$</span> state vectors, where <span>$s \geq n$</span>.</li><li>The <strong>marching map</strong> <span>$\mathcal{U}: \mathbb{R} \times (\mathbb{R}^{d})^{s} \to (\mathbb{R}^{d})^{s}$</span> updates the state vectors from time <span>$t_{n}$</span> to time <span>$t_{n+1}$</span>.</li><li>The <strong>finishing map</strong> <span>$\mathcal{F}: \mathbb{R} \times (\mathbb{R}^{d})^{s} \to \mathbb{R}^{d}$</span> converts the state vectors into the evaluation of <span>$\boldsymbol{u}$</span> at the current time.</li></ul><blockquote><p>In the simplest case, the time step <span>$h = h_{n} = t_{n+1} - t_{n}$</span> is prescribed and constant across all iterations. The state vectors are simply the initial conditions, i.e. <span>$s = n$</span> and <span>$\mathcal{I} = \mathrm{id}$</span>, and assuming that the initial conditions are given by increasing order of time derivative, <span>$\mathcal{F}$</span> returns its first input.</p><p>Some schemes need nontrivial starting and finishing maps. (See the generalised-<span>$\alpha$</span> schemes below.) When higher-order derivatives can be retrieved from the state vectors, it is also possible to take another definition for <span>$\mathcal{F}$</span> so that it returns the evaluation of <span>$\boldsymbol{u}$</span> and higher-order derivatives at the current time.</p></blockquote><p>These three maps need to be designed such that the following recurrence produces approximations of <span>$\boldsymbol{u}$</span> at the times of interest <span>$t_{n}$</span></p><p class="math-container">\[\left\{\begin{array}{lcl}
\left\{\boldsymbol{s}\right\}_{n+1} &amp;=&amp; \mathcal{U}(h_{n}, \left\{\boldsymbol{s}\right\}_{n}) \\
\left\{\boldsymbol{s}\right\}_{0} &amp;=&amp; \mathcal{I}(\boldsymbol{u}_{0}^{0}, \ldots, \boldsymbol{u}_{0}^{n-1})
\end{array}\right., \qquad \boldsymbol{u}_{n} = \mathcal{F}(\left\{\boldsymbol{s}\right\}_{n}).\]</p><p>More precisely, we would like <span>$\boldsymbol{u}_{n}$</span> to be close to <span>$\boldsymbol{u}(t_{n})$</span>. Here the notation <span>$\{\boldsymbol{s}\}_{n}$</span> stands for the state vector, i.e. a vector of <span>$s$</span> vectors: <span>$\{\boldsymbol{s}\}_{n} = (\boldsymbol{s}_{n, i})_{1 \leq i \leq s}$</span>. In particular, we notice that we need the exactness condition</p><p class="math-container">\[\mathcal{F} \circ \mathcal{I}(\boldsymbol{u}_{0}^{0}, \ldots, \boldsymbol{u}_{0}^{n-1}) = \boldsymbol{u}_{0}.\]</p><p>This is a condition on the design of the pair (<span>$\mathcal{I}$</span>, <span>$\mathcal{F}$</span>).</p><h1 id="Classification-of-ODEs-and-numerical-schemes"><a class="docs-heading-anchor" href="#Classification-of-ODEs-and-numerical-schemes">Classification of ODEs and numerical schemes</a><a id="Classification-of-ODEs-and-numerical-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-ODEs-and-numerical-schemes" title="Permalink"></a></h1><p>Essentially, a numerical scheme converts a (continuous) ODE into (discrete) nonlinear systems of equations. These systems of equations can be linear under special conditions on the nature of the ODE and the numerical scheme. Since numerical methods for linear and nonlinear systems of equations can be quite different in terms of cost and implementation, we are interested in solving linear systems whenever possible. This leads us to perform the following classifications.</p><h2 id="Classification-of-ODEs"><a class="docs-heading-anchor" href="#Classification-of-ODEs">Classification of ODEs</a><a id="Classification-of-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-ODEs" title="Permalink"></a></h2><p>We define a few nonlinearity types based on the expression of the residual.</p><ul><li><strong>Nonlinear</strong>. Nothing special can be said about the residual.</li><li><strong>Quasilinear</strong>. The residual is linear with respect to the highest-order time derivative and the corresponding linear form may depend on time and lower-order time derivatives, i.e.</li></ul><p class="math-container">\[\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \boldsymbol{M}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}) \partial_{t}^{n} \boldsymbol{u} + \boldsymbol{f}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}).\]</p><p>We call the matrix <span>$\boldsymbol{M}: \mathbb{R} \to \mathbb{R}^{d \times d}$</span> the mass matrix. In particular, a quasilinear ODE is a nonlinear ODE.</p><ul><li><strong>Semilinear</strong>. The residual is quasilinear and the mass matrix may only depend on time, i.e.</li></ul><p class="math-container">\[\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \boldsymbol{M}(t) \partial_{t}^{n} \boldsymbol{u} + \boldsymbol{f}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}).\]</p><p>In particular, a semilinear ODE is a quasilinear ODE.</p><ul><li><strong>Linear</strong>. The residual is linear with respect to all time derivatives, i.e.</li></ul><p class="math-container">\[\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \sum_{0 \leq k \leq n} \boldsymbol{A}_{k}(t) \partial_{t}^{k} \boldsymbol{u} - \boldsymbol{f}(t).\]</p><p>We refer to the matrix <span>$\boldsymbol{A}_{k}: \mathbb{R} \to \mathbb{R}^{d \times d}$</span> as the <span>$k$</span>-th linear form of the residual. We may still define the mass matrix <span>$\boldsymbol{M} = \boldsymbol{A}_{n}$</span>. Note that the term independent of <span>$u$</span>, i.e. the forcing term, is subtracted from the residual. This aligns with standard conventions, and in particular with those of <code>AffineFEOperator</code> (see example in <em>Finite element operators</em> below, in the construction of a <code>TransientLinearFEOperator</code>). In particular, a linear ODE is a semilinear ODE.</p><blockquote><p>Note that for residuals of order zero (i.e. &quot;standard&quot; systems of equations), the definitions of quasilinear, semilinear, and linear coincide.</p></blockquote><p>We consider an extra ODE type that is motivated by stiff problems. We say that an ODE has an implicit-explicit (IMEX) decomposition if it be can written as the sum of a residual of order <span>$n$</span> and another residual of order <span>$n-1$</span>, i.e.</p><p class="math-container">\[\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \boldsymbol{r}_{\text{implicit}}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) + \boldsymbol{r}_{\text{explicit}}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}).\]</p><p>The decomposition takes the form above so that the mass matrix of the global residual is fully contained in the implicit part. The table below indicates the type of the corresponding global ODE.</p><table><tr><th style="text-align: right">Explicit \ Implicit</th><th style="text-align: right">Nonlinear</th><th style="text-align: right">Quasilinear</th><th style="text-align: right">Semilinear</th><th style="text-align: right">Linear</th></tr><tr><td style="text-align: right">Nonlinear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Quasilinear</td><td style="text-align: right">Semilinear</td><td style="text-align: right">Semilinear</td></tr><tr><td style="text-align: right">Linear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Quasilinear</td><td style="text-align: right">Semilinear</td><td style="text-align: right">Linear</td></tr></table><p>In particular, for the global residual to be linear, both the implicit and explicit parts need to be linear too.</p><blockquote><p>In the special case where the implicit part is linear and the explicit part is quasilinear or semilinear, we could, in theory, identify two linear forms for the global residual. However, introducing this difference would call for an order-dependent classification of ODEs and this would create (infinitely) many new types. Since numerical schemes can rarely take advantage of this extra structure in practice, we still say that the global residual is semilinear in these cases.</p></blockquote><h2 id="Classification-of-numerical-schemes"><a class="docs-heading-anchor" href="#Classification-of-numerical-schemes">Classification of numerical schemes</a><a id="Classification-of-numerical-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-numerical-schemes" title="Permalink"></a></h2><p>We introduce a classification of numerical schemes based on where they evaluate the residual during the state update.</p><ul><li>If it is possible (up to a change of variables) to write the system of equations for the state update as evaluations of the residual at known values (that depend on the solution at the current time) for all but the highest-order derivative, we say that the scheme is explicit.</li><li>Otherwise, we say that the scheme is implicit.</li></ul><blockquote><p>For example, when solving a first-order ODE, the state update would involve solving one or more equations of the type </p><p class="math-container">\[\boldsymbol{r}(t_{k}, \boldsymbol{u}_{k}(\boldsymbol{x}), \boldsymbol{v}_{k}(\boldsymbol{x})) = \boldsymbol{0},\]</p><p>where <span>$\boldsymbol{x}$</span> and the unknown of the state update. The scheme is explicit if it is possible to introduce a change of variables such that <span>$\boldsymbol{u}_{k}$</span> does not depend on <span>$\boldsymbol{x}$</span>. Otherwise, it is implicit.</p></blockquote><h2 id="Classification-of-systems-of-equations"><a class="docs-heading-anchor" href="#Classification-of-systems-of-equations">Classification of systems of equations</a><a id="Classification-of-systems-of-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-systems-of-equations" title="Permalink"></a></h2><p>It is advantageous to introduce this classification of ODE and numerical schemes because the system of equations arising from the discretisation of the ODE by a numerical scheme will be linear or nonlinear depending on whether the scheme is explicit, implicit, or implicit-explicit, and on the type of the ODE. More precisely, we have the following table.</p><table><tr><th style="text-align: right"></th><th style="text-align: right">Nonlinear</th><th style="text-align: right">Quasilinear</th><th style="text-align: right">Semilinear</th><th style="text-align: right">Linear</th></tr><tr><td style="text-align: right">Explicit</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Linear</td><td style="text-align: right">Linear</td><td style="text-align: right">Linear</td></tr><tr><td style="text-align: right">Implicit</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Linear</td></tr></table><p>When the system is linear, another important practical consideration is whether the matrix of the system is constant across iterations or not. This is important because a linear solver typically performs a factorisation of the matrix, and this operation may only be performed once if the matrix is constant.</p><ul><li>If the linear system comes from an explicit scheme, the matrix of the system is constant if the mass matrix is. This means that the ODE has to be quasilinear.</li><li>If the linear system comes from an implicit scheme, all the linear forms must be constant for the system to have a constant matrix.</li></ul><h2 id="Reuse-across-iterations"><a class="docs-heading-anchor" href="#Reuse-across-iterations">Reuse across iterations</a><a id="Reuse-across-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Reuse-across-iterations" title="Permalink"></a></h2><p>For performance reasons, it is thus important that the ODE be described in the most specific way. In particular, we consider that the mass term of a quasilinear ODE is not constant, because if it is, the ODE is semilinear. We enable the user to specify the following constant annotations:</p><ul><li>For nonlinear and quasilinear ODE, no quantity can be described as constant.</li><li>For a semilinear ODE, whether the mass term is constant.</li><li>For a linear ODE, whether all the linear forms are constant.</li></ul><p>If a linear form is constant, regardless of whether the numerical scheme relies on a linear or nonlinear system, it is always possible to compute the jacobian of the residual with respect to the corresponding time derivative only once and retrieve it in subsequent computations of the jacobian.</p><h1 id="High-level-API-in-Gridap"><a class="docs-heading-anchor" href="#High-level-API-in-Gridap">High-level API in Gridap</a><a id="High-level-API-in-Gridap-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-API-in-Gridap" title="Permalink"></a></h1><p>The ODE module of <code>Gridap</code> relies on the following structure.</p><h2 id="Finite-element-spaces"><a class="docs-heading-anchor" href="#Finite-element-spaces">Finite element spaces</a><a id="Finite-element-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-spaces" title="Permalink"></a></h2><p>The time-dependent counterpart of <code>TrialFESpace</code> is <code>TransientTrialFESpace</code>. It is built from a standard <code>TestFESpace</code> and is equipped with time-dependent Dirichlet boundary conditions.</p><blockquote><p>By definition, test spaces have zero Dirichlet boundary conditions so they need not be seen as time-dependent objects.</p></blockquote><p>A <code>TransientTrialFESpace</code> can be evaluated at any time derivative order, and the corresponding Dirichlet values are the time derivatives of the Dirichlet boundary conditions.</p><p>For example, the following creates a transient <code>FESpace</code> and evaluates its first two time derivatives.</p><pre><code class="nohighlight hljs">g(t) = x -&gt; x[1] + x[2] * t
V = FESpace(model, reffe, dirichlet_tags=&quot;boundary&quot;)
U = TransientTrialFESpace (V, g)

t0 = 0.0
U0 = U(t0)

∂tU = ∂t(U)
∂tU0 = ∂tU(t0)

∂ttU = ∂tt(U) # or ∂ttU = ∂t(∂t(U))
∂ttU0 = ∂ttU(t0)</code></pre><h2 id="Cell-fields"><a class="docs-heading-anchor" href="#Cell-fields">Cell fields</a><a id="Cell-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-fields" title="Permalink"></a></h2><p>The time-dependent equivalent of <code>CellField</code> is <code>TransientCellField</code>. It stores the cell field itself together with its derivatives up to the order of the ODE.</p><p>For example, the following creates a <code>TransientCellField</code> with two time derivatives.</p><pre><code class="nohighlight hljs">u0 = zero(get_free_dof_values(U0))
∂tu0 = zero(get_free_dof_values(∂tU0))
∂ttu0 = zero(get_free_dof_values(∂ttU0))
u = TransientCellField(u0, (∂tu0, ∂ttu0))</code></pre><h2 id="Finite-element-operators"><a class="docs-heading-anchor" href="#Finite-element-operators">Finite element operators</a><a id="Finite-element-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-operators" title="Permalink"></a></h2><p>The time-dependent analog of <code>FEOperator</code> is <code>TransientFEOperator</code>. It has the following constructors based on the nonlinearity type of the underlying ODE.</p><ul><li><code>TransientFEOperator(res, jacs, trial, test)</code> and <code>TransientFEOperator(res, trial, test; order)</code> for the version with automatic jacobians. The residual is expected to have the signature <code>residual(t, u, v)</code>.</li><li><code>TransientQuasilinearFEOperator(mass, res, jacs, trial, test)</code> and <code>TransientQuasilinearFEOperator(mass, res, trial, test; order)</code> for the version with automatic jacobians. The mass and residual are expected to have the signatures <code>mass(t, u, dtNu, v)</code> and <code>residual(t, u, v)</code>, i.e. the mass is written as a linear form of the highest-order time derivative <code>dtNu</code>. In this setting, the mass matrix is supposed to depend on lower-order time derivatives, so <code>u</code> is provided for the nonlinearity of the mass matrix.</li><li><code>TransientSemilinearFEOperator(mass, res, jacs, trial, test; constant_mass)</code> and <code>TransientSemilinearFEOperator(mass, res, trial, test; order, constant_mass)</code> for the version with automatic jacobians. (The jacobian with respect to <span>$\partial_{t}^{n} \boldsymbol{u}$</span> is simply the mass term). The mass and residual are expected to have the signatures <code>mass(t, dtNu, v)</code> and <code>residual(t, u, v)</code>, where here again <code>dtNu</code> is the highest-order derivative. In particular, the mass is specified as a linear form of <code>dtNu</code>.</li><li><code>TransientLinearFEOperator(forms, res, jacs, trial, test; constant_forms)</code> and <code>TransientLinearFEOperator(forms, res, trial, test; constant_forms)</code> for the version with automatic jacobians. (In fact, the jacobians are simply the forms themselves). The forms and residual are expected to have the signatures <code>form_k(t, dtku, v)</code> and <code>residual(t, v)</code>, i.e. <code>form_k</code> is a linear form of the <span>$k$</span>-th order derivative, and the residual does not depend on <code>u</code>.</li></ul><p>It is important to note that all the terms are gathered in the residual, including the forcing term. In the common case where the ODE is linear, the residual is only the forcing term, and it is subtracted from the bilinear forms (see example below).</p><p>Here, in the signature of the residual, <code>t</code> is the time at which the residual is evaluated, <code>u</code> is a function in the trial space, and <code>v</code> is a test function. Time derivatives of <code>u</code> can be included in the residual via the <code>∂t</code> operator, applied as many times as needed, or using the shortcut <code>∂t(u, N)</code>.</p><p>Let us take the heat equation as an example. The original ODE is</p><p class="math-container">\[\partial_{t} u - \nabla \cdot (\kappa(t) \nabla u) = f(t),\]</p><p>where <span>$\kappa$</span> is the (time-dependent) thermal conductivity and <span>$f$</span> is the forcing term. We readily obtain the weak form</p><p class="math-container">\[\int_{\Omega} v \partial_{t} u(t) + \nabla v \cdot (\kappa(t) \nabla u(t)) \ \mathrm{d} \Omega = \int_{\Omega} v f(t) \ \mathrm{d} \Omega.\]</p><p>It could be described as follows.</p><ul><li>As a <code>TransientFEOperator</code>:</li></ul><pre><code class="nohighlight hljs">res(t, u, v) = ∫( v ⋅ ∂t(u) + ∇(v) ⋅ (κ(t) ⋅ ∇(u)) - v ⋅ f(t) ) dΩ
TransientFEOperator(res, U, V)</code></pre><ul><li>As a <code>TransientQuasilinearFEOperator</code>:</li></ul><pre><code class="nohighlight hljs">mass(t, u, dtNu, v) = ∫( v ⋅ dtNu ) dΩ
res(t, u, v) = ∫( ∇(v) ⋅ (κ(t) ⋅ ∇(u)) - v ⋅ f(t) ) dΩ
TransientQuasilinearFEOperator(mass, res, U, V)</code></pre><ul><li>As a <code>TransientSemilinearFEOperator</code>:</li></ul><pre><code class="nohighlight hljs">mass(t, dtu, v) = ∫( v ⋅ dtu ) dΩ
res(t, u, v) = ∫( ∇(v) ⋅ (κ(t) ⋅ ∇(u)) - v ⋅ f(t) ) dΩ
TransientSemilinearFEOperator(mass, res, U, V, constant_mass=true)</code></pre><ul><li>As a <code>TransientLinearFEOperator</code>:</li></ul><pre><code class="nohighlight hljs">stiffness(t, u, v) = ∫( ∇(v) ⋅ (κ(t) ⋅ ∇(u)) ) dΩ
mass(t, dtu, v) = ∫( v ⋅ dtu ) dΩ
res(t, u, v) = ∫( v ⋅ f(t) ) dΩ
TransientLinearFEOperator((stiffness, mass), res, U, V, constant_forms=(false, true))</code></pre><p>If <span>$\kappa$</span> is constant, the keyword <code>constant_forms</code> could be replaced by <code>(true, true)</code>.</p><h2 id="The-TimeSpaceFunction-constructor"><a class="docs-heading-anchor" href="#The-TimeSpaceFunction-constructor">The <code>TimeSpaceFunction</code> constructor</a><a id="The-TimeSpaceFunction-constructor-1"></a><a class="docs-heading-anchor-permalink" href="#The-TimeSpaceFunction-constructor" title="Permalink"></a></h2><p>Apply differential operators on a function that depends on time and space is somewhat cumbersome. Let <code>f</code> be a function of time and space, and <code>g(t) = x -&gt; f(t, x)</code> (as in the prescription of the boundary conditions <code>g</code> above). Applying the operator <span>$\partial_{t} - \Delta$</span>  to <code>g</code> and evaluating at <span>$(t, x)$</span> is written <code>∂t(g)(t)(x) - Δ(g(t))(x)</code>.</p><p>The constructor <code>TimeSpaceFunction</code> allows for simpler notations: let <code>h = TimeSpaceFunction(g)</code>. The object <code>h</code> is a functor that supports the notations </p><ul><li><code>op(h)</code>: a <code>TimeSpaceFunction</code> representing both <code>t -&gt; x -&gt; op(f)(t, x)</code> and <code>(t, x) -&gt; op(f)(t, x)</code>,</li><li><code>op(h)(t)</code>: a function of space representing <code>x -&gt; op(f)(t, x)</code></li><li><code>op(h)(t, x)</code>: the quantity <code>op(f)(t, x)</code> (this notation is equivalent to <code>op(h)(t)(x)</code>),</li></ul><p>for all spatial and temporal differential operator, i.e. <code>op</code> in <code>(time_derivative, gradient, symmetric_gradient, divergence, curl, laplacian)</code> and their symbolic aliases (<code>∂t</code>, <code>∂tt</code>, <code>∇</code>, ...). The operator above applied to <code>h</code> and evaluated at <code>(t, x)</code> can be conveniently written <code>∂t(h)(t, x) - Δ(h)(t, x)</code>.</p><h2 id="Solver-and-solution"><a class="docs-heading-anchor" href="#Solver-and-solution">Solver and solution</a><a id="Solver-and-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-and-solution" title="Permalink"></a></h2><p>The next step is to choose an ODE solver (see below for a full list) and specify the boundary conditions. The solution can then be iterated over until the final time is reached.</p><p>For example, to use the <span>$\theta$</span>-method with a nonlinear solver, one could write</p><pre><code class="nohighlight hljs">t0 = 0.0
tF = 1.0
dt = 0.1
uh0 = interpolate_everywhere(t0, U(t0))

res(t, u, v) = ∫( v ⋅ ∂t(u) + ∇(v) ⋅ (κ(t) ⋅ ∇(u)) - v ⋅ f(t) ) dΩ
jac(t, u, du, v) = ∫( ∇(v) ⋅ (κ(t) ⋅ ∇(du)) ) dΩ
jac_t(t, u, dtu, v) = ∫( v ⋅ dtu ) dΩ
tfeop = TransientFEOperator(res, (jac, jac_t), U, V)

ls = LUSolver()
nls = NLSolver(ls, show_trace=true, method=:newton, iterations=10)
odeslvr = ThetaMethod(nls, dt, 0.5)

sol = solve(odeslvr, tfeop, t0, tF, uh0)
for (tn, un) in enumerate(sol)
    # ...
end</code></pre><h1 id="Low-level-implementation"><a class="docs-heading-anchor" href="#Low-level-implementation">Low-level implementation</a><a id="Low-level-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-implementation" title="Permalink"></a></h1><p>We now briefly describe the low-level implementation of the ODE module in <code>Gridap</code>.</p><h2 id="ODE-operators"><a class="docs-heading-anchor" href="#ODE-operators">ODE operators</a><a id="ODE-operators-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-operators" title="Permalink"></a></h2><p>The <code>ODEOperator</code> type represents an ODE according to the description above. It implements the <code>NonlinearOperator</code> interface, which enables the computation of residuals and jacobians.</p><p>The algebraic equivalent of <code>TransientFEOperator</code> is an <code>ODEOpFromTFEOp</code>, which is a subtype of <code>ODEOperator</code>. Conceptually, <code>ODEOpFromTFEOp</code> can be thought of as an assembled <code>TransientFEOperator</code>, i.e. it deals with vectors of degrees of freedom. This operator comes with a cache (<code>ODEOpFromTFEOpCache</code>) that stores the transient space, its evaluation at the current time step, a cache for the <code>TransientFEOperator</code> itself (if any), and the constant forms (if any).</p><blockquote><p>For now <code>TransientFEOperator</code> does not implement the <code>FEOperator</code> interface, i.e. it is not possible to evaluate residuals and jacobians directly on it. Rather, they are meant to be evaluated on the <code>ODEOpFromFEOp</code>. This is to cut down on the number of conversions between a <code>TransientCellField</code> and its vectors of degrees of freedom (one per time derivative). Indeed, when linear forms are constant, no conversion is needed as the jacobian matrix will be stored.</p></blockquote><h2 id="ODE-solvers"><a class="docs-heading-anchor" href="#ODE-solvers">ODE solvers</a><a id="ODE-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-solvers" title="Permalink"></a></h2><p>An ODE solver has to implement the following interface.</p><ul><li><code>allocate_odecache(odeslvr, odeop, t0, us0)</code>. This function allocates a cache that can be reused across the three functions <code>ode_start</code>, <code>ode_march!</code>, and <code>ode_finish!</code>. In particular, it is necessary to call <code>allocate_odeopcache</code> within this function, so as to instantiate the <code>ODEOpFromTFEOpCache</code> and be able to update the Dirichlet boundary conditions in the subsequent functions.</li><li><code>ode_start(odeslvr, odeop, t0, us0, odecache)</code>. This function creates the state vectors from the initial conditions. By default, this is the identity.</li><li><code>ode_march!(stateF, odeslvr, odeop, t0, state0, odecache)</code>. This is the update map that evolves the state vectors.</li><li><code>ode_finish!(uF, odeslvr, odeop, t0, tF, stateF, odecache)</code>. This function converts the state vectors into the evaluation of the solution at the current time step. By default, this copies the first state vector into <code>uF</code>.</li></ul><h2 id="Stage-operator"><a class="docs-heading-anchor" href="#Stage-operator">Stage operator</a><a id="Stage-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-operator" title="Permalink"></a></h2><p>A <code>StageOperator</code> represents the linear or nonlinear operator that a numerical scheme relies on to evolve the state vector. It is essentially a special kind of <code>NonlinearOperator</code> but it overwrites the behaviour of nonlinear and linear solvers to take advantage of the matrix of a linear system being constant. The following subtypes of <code>StageOperator</code> are the building blocks of all numerical schemes.</p><ul><li><code>LinearStageOperator</code> represents the system <span>$\boldsymbol{J} \boldsymbol{x} + \boldsymbol{r} = \boldsymbol{0}$</span>, and can build <span>$\boldsymbol{J}$</span> and <span>$\boldsymbol{r}$</span> by evaluating the residual at a given point.</li><li><code>NonlinearStageOperator</code> represents <span>$\boldsymbol{r}(\boldsymbol{t}, \boldsymbol{\ell}_{0}(\boldsymbol{x}), \ldots, \boldsymbol{\ell}_{N}(\boldsymbol{x})) = \boldsymbol{0}$</span>, where it is assumed that all the <span>$\boldsymbol{\ell}_{k}(\boldsymbol{x})$</span> are linear in <span>$\boldsymbol{x}$</span>.</li></ul><h2 id="ODE-solution"><a class="docs-heading-anchor" href="#ODE-solution">ODE solution</a><a id="ODE-solution-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-solution" title="Permalink"></a></h2><p>This type is a simple wrapper around an <code>ODEOperator</code>, an <code>ODESolver</code>, and initial conditions that can be iterated on to evolve the ODE.</p><h1 id="Numerical-schemes-formulation-and-implementation"><a class="docs-heading-anchor" href="#Numerical-schemes-formulation-and-implementation">Numerical schemes formulation and implementation</a><a id="Numerical-schemes-formulation-and-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-schemes-formulation-and-implementation" title="Permalink"></a></h1><p>We conclude this note by describing some numerical schemes and their implementation in <code>Gridap</code>.</p><p>Suppose that the scheme has been evolved up to time <span>$t_{n}$</span> already and that the state vectors <span>$\{\boldsymbol{s}\}_{n}$</span> are known. We are willing to evolve the ODE up to time <span>$t_{n+1} &gt; t_{n}$</span>, i.e. compute the state vectors <span>$\{\boldsymbol{s}\}_{n+1}$</span>. Generally speaking, a numerical scheme constructs an approximation of the map <span>$\{\boldsymbol{s}\}_{n} \to \{\boldsymbol{s}\}_{n+1}$</span> by solving one or more relationships of the type</p><p class="math-container">\[\boldsymbol{r}(t_{i}, \Delta_{i}^{0}(\{\boldsymbol{s}\}_{n}, \{\boldsymbol{s}\}_{n+1}), \ldots, \Delta_{i}^{n}(\{\boldsymbol{s}\}_{n}, \{\boldsymbol{s}\}_{n+1})) = \boldsymbol{0},\]</p><p>where <span>$t_{i}$</span> is an intermediate time and <span>$\Delta_{i}^{k}$</span> are discrete operators that approximates the <span>$k$</span>-th order time derivative of <span>$\boldsymbol{u}$</span> at time <span>$t_{i}$</span>.</p><p>We now describe the numerical schemes implemented in <code>Gridap</code> using this framework. It is usually convenient to perform a change of variables so that the unknown <span>$\boldsymbol{x}$</span> has the dimension of the highest-order time derivative of <span>$\boldsymbol{u}$</span>, i.e. <span>$[\boldsymbol{x}] = [t]^{-n} [\boldsymbol{u}]$</span> (where <span>$[\bullet]$</span> stands for &quot;the dimension of <span>$\bullet$</span>&quot;). We always perform such a change of variable in practice.</p><p>We also briefly characterise these schemes in terms of their order and linear stability.</p><h2 id="\\theta-method"><a class="docs-heading-anchor" href="#\\theta-method"><span>$\theta$</span>-method</a><a id="\\theta-method-1"></a><a class="docs-heading-anchor-permalink" href="#\\theta-method" title="Permalink"></a></h2><p>This scheme is used to solve first-order ODEs and relies on the simple state vector <span>$\{\boldsymbol{s}(t)\} = \{\boldsymbol{u}(t)\}$</span>. This means that the starting and finishing procedures are simply the identity.</p><p>The <span>$\theta$</span>-method relies on the following approximation</p><p class="math-container">\[\boldsymbol{u}(t_{n+1}) = \boldsymbol{u}(t_{n}) + \int_{t_{n}}^{t_{n+1}} \partial_{t} \boldsymbol{u}(t) \ \mathrm{d} t \approx \boldsymbol{u}(t_{n}) + h_{n} \partial_{t} \boldsymbol{u}(t_{n + \theta}),\]</p><p>where we have introduced the intermediate time <span>$t_{n + \theta} \doteq (1 - \theta) t_{n} + \theta t_{n+1}$</span>. By replacing <span>$\boldsymbol{u}(t_{n})$</span> and <span>$\boldsymbol{u}(t_{n+1})$</span> by their discrete equivalents, we have <span>$\partial_{t} \boldsymbol{u}(t_{n + \theta}) \approx \frac{1}{h} (\boldsymbol{u}_{n+1} - \boldsymbol{u}_{n})$</span>. This quantity is found by enforcing that the residual is zero at <span>$t_{n + \theta}$</span>. In that sense, the <span>$\theta$</span>-method can be framed as a collocation method at <span>$t_{n + \theta}$</span>. For that purpose, we use the same quadrature rule as above to approximate <span>$\boldsymbol{u}(t_{n + \theta})$</span>, i.e. <span>$\boldsymbol{u}(t_{n + \theta}) \approx \boldsymbol{u}_{n} + \theta h_{n} \partial_{t} \boldsymbol{u}(t_{n + \theta})$</span>. Using the notations of the framework above, we have defined</p><p class="math-container">\[\begin{align*}
t_{1} &amp;= (1 - \theta) t_{n} + \theta t_{n+1}, \\
\Delta_{1}^{0} &amp;= (1 - \theta) \boldsymbol{u}_{n} + \theta \boldsymbol{u}_{n+1}, \\
\Delta_{1}^{1} &amp;= \frac{1}{h} (\boldsymbol{u}_{n+1} - \boldsymbol{u}_{n}).
\end{align*}\]</p><p>To summarize and to be more concrete, let <span>$\boldsymbol{x} = \frac{1}{h} (\boldsymbol{u}_{n+1} - \boldsymbol{u}_{n})$</span>. The <span>$\theta$</span>-method solves the following stage operator</p><p class="math-container">\[\boldsymbol{r}(t_{n} + \theta h_{n}, \boldsymbol{u}_{n} + \theta h_{n} \boldsymbol{x}, \boldsymbol{x}) = \boldsymbol{0},\]</p><p>and sets <span>$\boldsymbol{u}_{n+1} = \boldsymbol{u}_{n} + h_{n} \boldsymbol{x}$</span>. The output state is simply <span>$\{\boldsymbol{s}\}_{n+1} = \{\boldsymbol{u}_{n+1}\}$</span>.</p><h5 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h5><p>Since this scheme uses <span>$\boldsymbol{u}(t)$</span> as its only state vector, the amplification matrix has dimension one, and its coefficient is the stabilisation function, given by</p><p class="math-container">\[\rho(z) = \frac{1 + (1 - \theta) z}{1 - \theta z}.\]</p><p>We plug the Taylor expansion of <span>$\boldsymbol{u}_{n+1}$</span> around <span>$\boldsymbol{u}_{n}$</span> in <span>$\boldsymbol{u}_{n+1} = \rho(z) \boldsymbol{u}_{n}$</span> and obtain the exactness condition <span>$\rho(z) - \exp(z) = 0$</span>. We then seek to match as many coefficients in the Taylor expansion of both sides to obtain order conditions. We readily obtain the following expansion</p><p class="math-container">\[\rho(z) - \exp(z) = \sum_{k \geq 0} \left[\theta^{k} - \frac{1}{(k+1)!}\right] z^{k+1}.\]</p><p>The order conditions are as follows.</p><ul><li><strong>Order 0 and 1</strong>. The first two coefficients are always zero, so the method has at least order one.</li><li><strong>Order 2</strong>. The third coefficient is <span>$\theta - \frac{1}{2}$</span>, and it is zero when <span>$\theta = \frac{1}{2}$</span>. This value of <span>$\theta$</span> corresponds to a second-order scheme. The next coefficient is <span>$\theta^{2} - \frac{1}{6}$</span>, so this method cannot reach order three.</li></ul><p>By looking at the behaviour of the stability function at infinity, we find that the scheme is <span>$L$</span>-stable only when <span>$\theta = 1$</span>. We determine whether the scheme is <span>$A$</span>-stable or not by looking at stability region. We distinguish three cases based on the value of <span>$\theta$</span>.</p><ul><li><span>$\theta &lt; \frac{1}{2}$</span>. The stability region is the circle of radius <span>$\frac{1}{1 - 2 \theta}$</span> centered at <span>$\left(\frac{-1}{1 - 2 \theta}, 0\right)$</span>. In particular, it is not <span>$A$</span>-stable. The special case <span>$\theta = 0$</span> is known as the Forward Euler scheme, which is the only explicit scheme of the <span>$\theta$</span>-method family.</li><li><span>$\theta = \frac{1}{2}$</span>. The stability region is the whole left complex plane, so the scheme is <span>$A$</span>-stable. This case is known as the implicit midpoint scheme. </li><li><span>$\theta &gt; \frac{1}{2}$</span>. The stability region is the whole complex plane except the circle of radius <span>$\frac{1}{2 \theta - 1}$</span> centered at <span>$\left(\frac{1}{2 \theta - 1}, 0\right)$</span>. In particular, the scheme is <span>$A$</span>-stable. The special case <span>$\theta = 1$</span> is known as the Backward Euler scheme. </li></ul><h2 id="Generalised-\\alpha-scheme-for-first-order-ODEs"><a class="docs-heading-anchor" href="#Generalised-\\alpha-scheme-for-first-order-ODEs">Generalised-<span>$\alpha$</span> scheme for first-order ODEs</a><a id="Generalised-\\alpha-scheme-for-first-order-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Generalised-\\alpha-scheme-for-first-order-ODEs" title="Permalink"></a></h2><p>This scheme relies on the state vector <span>$\{\boldsymbol{s}(t)\} = \{\boldsymbol{u}(t), \partial_{t} \boldsymbol{u}(t)\}$</span>. In particular, it needs a nontrivial starting procedure that evaluates <span>$\partial_{t} \boldsymbol{u}(t_{0})$</span> by enforcing a zero residual at <span>$t_{0}$</span>. The finaliser can still return the first vector of the state vectors. For convenience, let <span>$\partial_{t} \boldsymbol{u}_{n}$</span> denote the approximation <span>$\partial_{t} \boldsymbol{u}(t_{n})$</span>.</p><blockquote><p>Alternatively, the initial velocity can be provided manually: when calling <code>solve(odeslvr, tfeop, t0, tF, uhs0)</code>, set <code>uhs0 = (u0, v0, a0)</code> instead of <code>uhs0 = (u0, v0)</code>. This is useful when enforcing a zero initial residual would lead to a singular system.</p></blockquote><p>This method extends the <span>$\theta$</span>-method by considering the two-point quadrature rule</p><p class="math-container">\[\boldsymbol{u}(t_{n+1}) = \boldsymbol{u}_{n} + \int_{t_{n}}^{t_{n+1}} \partial_{t} \boldsymbol{u}(t) \ \mathrm{d} t \approx \boldsymbol{u}_{n} + h_{n} [(1 - \gamma) \partial_{t} \boldsymbol{u}(t_{n}) + \gamma \partial_{t} \boldsymbol{u}(t_{n+1})],\]</p><p>where <span>$0 \leq \gamma \leq 1$</span> is a free parameter. The question is now how to estimate <span>$\partial_{t} \boldsymbol{u}(t_{n+1})$</span>. This is achieved by enforcing a zero residual at <span>$t_{n + \alpha_{F}} \doteq (1 - \alpha_{F}) t_{n} + \alpha_{F} t_{n+1}$</span>, where <span>$0 \leq \alpha_{F} \leq 1$</span> is another free parameter. The value of <span>$\boldsymbol{u}$</span> at that time, <span>$\boldsymbol{u}_{n + \alpha_{F}}$</span>, is obtained by the same linear combination of <span>$\boldsymbol{u}$</span> at <span>$t_{n}$</span> and <span>$t_{n+1}$</span>. Regarding <span>$\partial_{t} \boldsymbol{u}$</span>, it is taken as a linear combination weighted by another free parameter <span>$0 &lt; \alpha_{M} \leq 1$</span> of the time derivative at times <span>$t_{n}$</span> and <span>$t_{n+1}$</span>. Note that <span>$\alpha_{M}$</span> cannot be zero. Altogether, we have defined the discrete operators</p><p class="math-container">\[\begin{align*}
t_{1} &amp;= (1 - \alpha_{F}) t_{n} +  \alpha_{F} t_{n+1}, \\
\Delta_{1}^{0} &amp;= (1 - \alpha_{F}) \boldsymbol{u}_{n} + \alpha_{F} \boldsymbol{u}_{n+1}, \\
\Delta_{1}^{1} &amp;= (1 - \alpha_{M}) \partial_{t} \boldsymbol{u}_{n} + \alpha_{M} \partial_{t} \boldsymbol{u}_{n+1}.
\end{align*}\]</p><p>In more concrete terms, we solve the following system:</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n + \alpha_{F}}, \boldsymbol{u}_{n + \alpha_{F}}, \partial_{t} \boldsymbol{u}_{n + \alpha_{M}}), \\
t_{n + \alpha_{F}} &amp;= (1 - \alpha_{F}) t_{n} + \alpha_{F} t_{n+1}, \\
\boldsymbol{u}_{n + \alpha_{F}} &amp;= (1 - \alpha_{F}) \boldsymbol{u}_{n} + \alpha_{F} \boldsymbol{u}_{n+1}, \\
\partial_{t} \boldsymbol{u}_{n + \alpha_{M}} &amp;= (1 - \alpha_{M}) \partial_{t} \boldsymbol{u}_{n} + \alpha_{M} \partial_{t} \boldsymbol{u}_{n+1}, \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + h_{n} [(1 - \gamma) \partial_{t} \boldsymbol{u}_{n} + \gamma \boldsymbol{x}], \\
\partial_{t} \boldsymbol{u}_{n+1} &amp;= \boldsymbol{x}.
\end{align*}\]</p><p>The state vector is updated to <span>$\{\boldsymbol{s}\}_{n+1} = \{\boldsymbol{u}_{n+1}, \partial_{t} \boldsymbol{u}_{n+1}\}$</span>.</p><h5 id="Analysis-2"><a class="docs-heading-anchor" href="#Analysis-2">Analysis</a><a class="docs-heading-anchor-permalink" href="#Analysis-2" title="Permalink"></a></h5><p>The amplification matrix for the state vector is</p><p class="math-container">\[\boldsymbol{A}(z) = \frac{1}{\alpha_{M} - \alpha_{F} \gamma z} \begin{bmatrix}\alpha_{M} + (1 - \alpha_{F}) \gamma z &amp; \alpha_{M} - \gamma \\ z &amp; \alpha_{M} - 1 + \alpha_{F} (1 - \gamma) z\end{bmatrix}.\]</p><p>It is then immediate to see that <span>$\boldsymbol{u}_{n+1} = \mathrm{tr}(\boldsymbol{A}) \boldsymbol{u}_{n} - \det(\boldsymbol{A}) \boldsymbol{u}_{n-1}$</span>. This time, plugging the Taylor expansion of <span>$\boldsymbol{u}_{n+1}$</span> and <span>$\boldsymbol{u}_{n-1}$</span> around <span>$\boldsymbol{u}_{n}$</span> in this expression, the exactness condition is <span>$\mathrm{tr}(\boldsymbol{A}(z)) - \det(\boldsymbol{A}(z)) \exp(-z) - \exp(z) = 0$</span>. To simplify the analysis, we write the trace and determinant of <span>$\boldsymbol{A}$</span> as follows</p><p class="math-container">\[\mathrm{tr}(\boldsymbol{A}(z)) = a + \frac{b}{1 - c z}, \qquad \det(\boldsymbol{A}(z)) = d + \frac{e}{1 - c z},\]</p><p>where</p><p class="math-container">\[\begin{align*}
a &amp;= 2 - \frac{1}{\alpha_{F}} - \frac{1}{\gamma}, \\
b &amp;= \frac{1}{\alpha_{F}} + \frac{1}{\gamma} - \frac{1}{\alpha_{M}}, \\
c &amp;= \frac{\alpha_{F} \gamma}{\alpha_{M}}, \\
d &amp;= \frac{(1 - \alpha_{F}) (1 - \gamma)}{\alpha_{F} \gamma}, \\
e &amp;= \frac{\alpha_{M} (\alpha_{F} + \gamma - 1) - \alpha_{F} \gamma}{\alpha_{F} \alpha_{M} \gamma}.
\end{align*}\]</p><p>Next, we obtain the Taylor expansion of the exactness condition and find</p><p class="math-container">\[(a + b - d - e - 1) + \sum_{k \geq 1} \left(b c^{k} - \frac{1}{k!} - \frac{(-1)^{k}}{k!} d - \sum_{0 \leq l \leq k} e c^{(k - l)}\frac{(-1)^{l}}{l!}\right) z^{k} = 0.\]</p><p>The order conditions are as follows.</p><ul><li><strong>Order 0 and 1</strong>. The first two coefficients are always zero, so the method is at least of order <span>$2$</span>.</li><li><strong>Order 2</strong>. The third coefficient has a zero at <span>$\gamma = \frac{1}{2} + \alpha_{M} - \alpha_{F}$</span>.</li><li><strong>Order 3</strong>. The fourth coefficient has a zero at <span>$\alpha_{M} = \frac{1 + 6 \alpha_{F} - 12 \alpha_{F}^{2}}{6(1 - 2 \alpha_{F})}$</span> (provided that <span>$\alpha_{F} \neq \frac{1}{2}$</span>). In that case we simplify <span>$\gamma$</span> into <span>$\gamma = \frac{2 - 3 \alpha_{F}}{3(1 - 2 \alpha_{F})}$</span>.</li><li><strong>Order 4</strong>. The fifth coefficient has zeros at <span>$\alpha_{F} = \frac{3 \pm \sqrt{3}}{6}$</span> and poles at <span>$\alpha_{F} = \frac{3 \pm \sqrt{21}}{12}$</span>. The corresponding values of <span>$\alpha_{M}$</span> and <span>$\gamma$</span> are <span>$\alpha_{M} = \frac{1}{2}$</span>, <span>$\gamma = \frac{3 \mp \sqrt{3}}{6}$</span>.</li></ul><p>We finally study the stability in the extreme cases <span>$|z| \to 0$</span> and <span>$|z| \to +\infty$</span>. We want the spectral radius of the amplification matrix to be smaller than one so that perturbations are damped away.</p><ul><li>When <span>$|z| \to 0$</span>, we have <span>$\rho(\boldsymbol{A}(z)) \to \max\{1, \left|1 - \frac{1}{\alpha_{M}}\right|\}$</span>.</li><li>When <span>$|z| \to +\infty$</span>, we have <span>$\rho(\boldsymbol{A}(z)) \to \max\{\left|1 - \frac{1}{\alpha_{F}}\right|, \left|1 - \frac{1}{\gamma}\right|\}$</span>.</li></ul><p>We thus require <span>$\alpha_{M} \geq \frac{1}{2}$</span>, <span>$\alpha_{F} \geq \frac{1}{2}$</span> and <span>$\gamma \geq \frac{1}{2}$</span> to ensure stability. In particular when the scheme has order <span>$3$</span>, the stability conditions become <span>$\alpha_{M} \geq \alpha_{F} \geq \frac{1}{2}$</span>. We verify that the scheme is unstable whenever it has an order greater than <span>$3$</span>. We notice that <span>$L$</span>-stability is only achieved when <span>$\alpha_{F} = 1$</span> and <span>$\gamma = 1$</span>. The corresponding value of <span>$\alpha_{M}$</span> for a third-order scheme is <span>$\alpha_{M} = \frac{3}{2}$</span>.</p><p>This scheme was originally devised to control the damping of high frequencies. One parameterisation consists in prescribing the eigenvalues at <span>$|z| \to +\infty$</span>, and this leads to</p><p class="math-container">\[\alpha_{F} = \gamma = \frac{1}{1 + \rho_{\infty}}, \qquad \alpha_{M} = \frac{3 - \rho_{\infty}}{2 (1 + \rho_{\infty})},\]</p><p>where <span>$\rho_{\infty}$</span> is the spectral radius at infinity. Setting <span>$\rho_{\infty}$</span> cuts all the highest frequencies in one step, whereas taking <span>$\rho_{\infty} = 1$</span> preserves high frequencies.</p><h2 id="Runge-Kutta"><a class="docs-heading-anchor" href="#Runge-Kutta">Runge-Kutta</a><a id="Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#Runge-Kutta" title="Permalink"></a></h2><p>Runge-Kutta methods are multi-stage, i.e. they build estimates of <span>$\boldsymbol{u}$</span> at intermediate times between <span>$t_{n}$</span> and <span>$t_{n+1}$</span>. They can be written as follows</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n} + c_{i} h_{n} , \boldsymbol{u}_{n} + \sum_{1 \leq j \leq s} a_{ij} h_{n} \boldsymbol{x}_{j}, \boldsymbol{x}_{i}), &amp; 1 \leq i \leq p \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + \sum_{1 \leq i \leq p} b_{i} h_{n} \boldsymbol{x}_{i},
\end{align*}\]</p><p>where <span>$p$</span> is the number of stages, <span>$\boldsymbol{A} = (a_{ij})_{1 \leq i, j \leq p}$</span> is a matrix of free parameters, <span>$\boldsymbol{b} = (b_{i})_{1 \leq i \leq p}$</span> and <span>$\boldsymbol{c} = (c_{i})_{1 \leq i \leq p}$</span> are two vectors of free parameters. The stage unknowns <span>$(\boldsymbol{x}_{i})_{1 \leq i \leq p}$</span> are involved in a coupled system of equations. This system can take a simpler form when the matrix <span>$\boldsymbol{A}$</span> has a particular structure.</p><ul><li>When <span>$\boldsymbol{A}$</span> is lower triangular, the equations are decoupled and can thus be solved sequentially. These schemes are called Diagonally-Implicit Runge-Kutta (DIRK). If the diagonal coefficients of the matrix <span>$\boldsymbol{A}$</span> are the same, the method is called Singly-Diagonally Implicit (SDIRK).</li><li>If the diagonal coefficients are also zero, the method is explicit. These schemes are called Explicit Runge-Kutta (EXRK).</li></ul><p><strong>Implementation details</strong> It is particularly advantageous to save the factorisation of the matrices of the stage operators for Runge-Kutta methods. This is always possible when the method is explicit and the mass matrix is constant, in which case all the stage matrices are the mass matrix. When the method is diagonally-implicit and the stiffness and mass matrices are constant, the matrices of the stage operators are <span>$\boldsymbol{M} + a_{ii} h_{n} \boldsymbol{K}$</span>. In particular, if two diagonal coefficients coincide, the corresponding operators will have the same matrix. We implement these reuse strategies by storing them in <code>CompressedArray</code>s, and introducing a map <code>i -&gt; NumericalSetup</code>.</p><h5 id="Analysis-3"><a class="docs-heading-anchor" href="#Analysis-3">Analysis</a><a class="docs-heading-anchor-permalink" href="#Analysis-3" title="Permalink"></a></h5><p>The stability function of a Runge-Kutta scheme is</p><p class="math-container">\[\rho(z) = 1 + z \boldsymbol{b}^{T} (\boldsymbol{I} - z \boldsymbol{A})^{-1} \boldsymbol{1}.\]</p><p>The analysis of Runge-Kutta methods is well-established but we only derive order conditions for schemes with one, two, or three stages in the diagonally-implicit case.</p><ul><li><p><strong>One stage</strong>. These schemes coincide with the <span>$\theta$</span>-method presented above.</p></li><li><p><strong>Two stages</strong>. We solve the order conditions given by the differential trees and find the following families of tableaus of orders two and three</p></li></ul><p class="math-container">\[\def\arraystretch{1.5}
\begin{array}{c|cc}
\alpha &amp; \alpha &amp; \\
\beta &amp; \beta - \hat{\beta} &amp; \hat{\beta} \\ \hline
&amp; \frac{2 \beta - 1}{2 (\beta - \alpha)} &amp; \frac{1 - 2 \alpha}{2 (\beta - \alpha)}
\end{array}, \qquad
\begin{array}{c|cc}
\frac{1}{2} - \frac{\sqrt{3}}{6} \frac{1}{\lambda} &amp; \frac{1}{2} - \frac{\sqrt{3}}{6} \frac{1}{\lambda} &amp; \\
\frac{1}{2} + \frac{\sqrt{3}}{6} \lambda &amp; \frac{\sqrt{3}}{3} \lambda &amp; \frac{1}{2} - \frac{\sqrt{3}}{6} \lambda \\ \hline
&amp; \frac{\lambda^{2}}{\lambda^{2} + 1} &amp; \frac{1}{\lambda^{2} + 1}.
\end{array}\]</p><ul><li><strong>Three stages</strong>. We only solve the explicit schemes in full generality. We find three families of order three</li></ul><p class="math-container">\[\def\arraystretch{1.5}
\begin{array}{c|cc}
0 &amp; \\
\alpha &amp; \alpha &amp; \\
\beta &amp; \beta - \frac{\beta (\beta - \alpha)}{\alpha (2 - 3\alpha)} &amp; \frac{\beta (\beta - \alpha)}{ \alpha(2 - 3 \alpha)} \\ \hline
&amp; 1 - \frac{3 (\beta + \alpha) - 2}{6 \alpha \beta} &amp; \frac{3 \beta - 2}{6 \alpha (\beta - \alpha)} &amp; \frac{2 - 3 \alpha}{6 \beta (\beta - \alpha)}
\end{array}, \qquad
\begin{array}{c|cc}
0 &amp; \\
\frac{2}{3} &amp; \frac{2}{3} &amp; \\
\frac{2}{3} &amp; \frac{2}{3} - \frac{1}{4 \alpha} &amp; \frac{1}{4 \alpha} \\ \hline
&amp; \frac{1}{4} &amp; \frac{3}{4} - \alpha &amp; \alpha
\end{array}, \qquad
\begin{array}{c|cc}
0 &amp; \\
\frac{2}{3} &amp; \frac{2}{3} &amp; \\
0 &amp; -\frac{1}{4 \alpha} &amp; \frac{1}{4 \alpha} \\ \hline
&amp; \frac{1}{4} - \alpha &amp; \frac{3}{4} &amp; \alpha
\end{array}.\]</p><h2 id="Implicit-Explicit-Runge-Kutta"><a class="docs-heading-anchor" href="#Implicit-Explicit-Runge-Kutta">Implicit-Explicit Runge-Kutta</a><a id="Implicit-Explicit-Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Explicit-Runge-Kutta" title="Permalink"></a></h2><p>When the residual has an implicit-explicit decomposition, usually because we can identify a stiff part that we want to solve implicitly and a nonstiff part that we want to solve explicitly, the Runge-Kutta method reads as follows</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n} + c_{i} h_{n}, \boldsymbol{u}_{n} + \sum_{1 \leq j \leq i-1} (a_{i, j} h_{n} \boldsymbol{x}_{j} + \hat{a}_{i, j} h_{n} \hat{\boldsymbol{x}}_{j}) + a_{i, i} h_{n} \boldsymbol{x}_{i}, \boldsymbol{x}_{i}), \\
\boldsymbol{0} &amp;= \hat{\boldsymbol{r}}(t_{n} + c_{i} h_{n}, \boldsymbol{u}_{n} + \sum_{1 \leq j \leq i-1} (a_{i, j} h_{n} \boldsymbol{x}_{j} + \hat{a}_{i, j} h_{n} \hat{\boldsymbol{x}}_{j}) + a_{i, i} h_{n} \boldsymbol{x}_{i}, \hat{\boldsymbol{x}}_{i}), &amp; 1 \leq i \leq p \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + \sum_{1 \leq i \leq p} (b_{i} h_{n} \boldsymbol{x}_{i} + \hat{b}_{i} h_{n} \hat{\boldsymbol{x}}_{i}).
\end{align*}\]</p><p>In these expressions, quantities that wear a hat are the explicit counterparts of the implicit quantity with the same name. The implicit and explicit stages are alternated, i.e. the implicit and explicit stage unknowns <span>$\boldsymbol{x}_{i}$</span> and <span>$\hat{\boldsymbol{x}}_{i}$</span> are solved alternatively. As seen above, we require that the nodes <span>$c_{i}$</span> of the implicit and explicit tableaus coincide. This implies that the first step for the implicit part is actually explicit.</p><p><strong>Implementation details</strong> Many methods can be created by padding a DIRK tableau with zeros to give it an additional step. In this case, the first stage for the implicit part does not need to be solved, as all linear combinations give it a zero weight. As an example, an <span>$L$</span>-stable, <span>$2$</span>-stage, second-order SDIRK IMEX scheme is given by</p><p class="math-container">\[\def\arraystretch{1.5}
\begin{array}{c|ccc}
0 &amp; 0 &amp; &amp; \\
\frac{2 - \sqrt{2}}{2} &amp; 0 &amp; \frac{2 - \sqrt{2}}{2} &amp; \\
1 &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; \frac{2 - \sqrt{2}}{2} \\ \hline
 &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; \frac{2 - \sqrt{2}}{2}
\end{array}, \qquad
\begin{array}{c|ccc}
0 &amp; &amp; &amp; \\
\frac{2 - \sqrt{2}}{2} &amp; \frac{2 - \sqrt{2}}{2} &amp; &amp; \\
1 &amp; -\frac{\sqrt{2}}{2} &amp; 1 + \frac{\sqrt{2}}{2} &amp; \\ \hline
 &amp; -\frac{\sqrt{2}}{2} &amp; 1 + \frac{\sqrt{2}}{2} &amp;
\end{array}.\]</p><p>We note that the first column of the matrix and the first weight are all zero, so the first stage for the implicit part does not need to be solved.</p><h2 id="Generalised-\\alpha-scheme-for-second-order-ODEs"><a class="docs-heading-anchor" href="#Generalised-\\alpha-scheme-for-second-order-ODEs">Generalised-<span>$\alpha$</span> scheme for second-order ODEs</a><a id="Generalised-\\alpha-scheme-for-second-order-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Generalised-\\alpha-scheme-for-second-order-ODEs" title="Permalink"></a></h2><p>This scheme relies on the state vector <span>$\{\boldsymbol{s}(t)\} = \{\boldsymbol{u}(t), \partial_{t} \boldsymbol{u}(t), \partial_{tt} \boldsymbol{u}(t)\}$</span>. It needs a nontrivial starting procedure that evaluates <span>$\partial_{tt} \boldsymbol{u}(t_{0})$</span> by enforcing a zero residual at <span>$t_{0}$</span>. The finaliser can still return the first vector of the state vectors. For convenience, let <span>$\partial_{tt} \boldsymbol{u}_{n}$</span> denote the approximation <span>$\partial_{tt} \boldsymbol{u}(t_{n})$</span>.</p><blockquote><p>The initial acceleration can alternatively be provided manually: when calling <code>solve(odeslvr, tfeop, t0, tF, uhs0)</code>, set <code>uhs0 = (u0, v0, a0)</code> instead of <code>uhs0 = (u0, v0)</code>. This is useful when enforcing a zero initial residual would lead to a singular system.</p></blockquote><p>This method is built out of the following update rule</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n + 1 - \alpha_{F}}, \boldsymbol{u}_{n + 1 - \alpha_{F}}, \partial_{t} \boldsymbol{u}_{n + 1 - \alpha_{F}}, \partial_{tt} \boldsymbol{u}_{n + 1 - \alpha_{M}}), \\
t_{n + 1 - \alpha_{F}} &amp;= \alpha_{F} t_{n} + (1 - \alpha_{F}) t_{n+1}, \\
\boldsymbol{u}_{n + 1 - \alpha_{F}} &amp;= \alpha_{F} \boldsymbol{u}_{n} + (1 - \alpha_{F}) \boldsymbol{u}_{n+1}, \\
\partial_{t} \boldsymbol{u}_{n + 1 - \alpha_{F}} &amp;= \alpha_{F} \partial_{t} \boldsymbol{u}_{n} + (1 - \alpha_{F}) \partial_{t} \boldsymbol{u}_{n+1}, \\
\partial_{tt} \boldsymbol{u}_{n + 1 - \alpha_{M}} &amp;= \alpha_{M} \partial_{tt} \boldsymbol{u}_{n} + (1 - \alpha_{M}) \partial_{tt} \boldsymbol{u}_{n+1}, \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + h_{n} \partial_{t} \boldsymbol{u}_{n} + \frac{1}{2} h_{n}^{2} [(1 - 2 \beta) \partial_{tt} \boldsymbol{u}_{n} + 2 \beta \boldsymbol{x}] \\
\partial_{t} \boldsymbol{u}_{n+1} &amp;= \partial_{t} \boldsymbol{u}_{n} + h_{n} [(1 - \gamma) \partial_{tt} \boldsymbol{u}_{n} + \gamma \boldsymbol{x}], \\
\partial_{tt} \boldsymbol{u}_{n+1} &amp;= \boldsymbol{x}
\end{align*}\]</p><p>The state vector is then updated to <span>$\{\boldsymbol{s}\}_{n+1} = \{\boldsymbol{u}_{n+1}, \partial_{t} \boldsymbol{u}_{n+1}, \partial_{tt} \boldsymbol{u}_{n+1}\}$</span>.</p><h5 id="Analysis-4"><a class="docs-heading-anchor" href="#Analysis-4">Analysis</a><a class="docs-heading-anchor-permalink" href="#Analysis-4" title="Permalink"></a></h5><p>The amplification matrix for the state vector is</p><p class="math-container">\[\boldsymbol{A}(z) = \frac{1}{\overline{\alpha_{M}} + \overline{\alpha_{F}} \beta z^{2}} \begin{bmatrix}
\overline{\alpha_{M}} - \alpha_{F} \beta z^{2} &amp; \overline{\alpha_{M}} &amp; \overline{\beta} \overline{\alpha_{M}} - \beta \alpha_{M} \\
-\gamma z^{2} &amp; \overline{\alpha_{M}} + \overline{\alpha_{F}} (\beta - \gamma) z^{2} &amp; \overline{\alpha_{M}} \ \overline{\gamma} - \alpha_{M} \gamma + \overline{\alpha_{F}} [\overline{\gamma} \beta - \overline{\beta} \gamma] z^{2} \\
-z^{2} &amp; -\overline{\alpha_{F}} z^{2} &amp; -\alpha_{M} - \overline{\alpha_{F}} \overline{\beta} z^{2}
\end{bmatrix},\]</p><p>where <span>$\overline{\alpha_{M}} = 1 - \alpha_{M}$</span>, <span>$\overline{\alpha_{F}} = 1 - \alpha_{F}$</span>, <span>$\overline{\gamma} = 1 - \gamma$</span> and <span>$\overline{\beta} = \frac{1}{2}(1 - 2 \beta)$</span>. Here again, we immediately see that <span>$\boldsymbol{u}_{n+1}$</span> satisfies the recurrence</p><p class="math-container">\[\boldsymbol{u}_{n+1} = \mathrm{tr}(\boldsymbol{A}(z)) \boldsymbol{u}_{n} - \frac{1}{2} (\mathrm{tr}(\boldsymbol{A}(z))^{2} - \mathrm{tr}(\boldsymbol{A}(z)^{2})) \boldsymbol{u}_{n-1} + \det(\boldsymbol{A}(z)) \boldsymbol{u}_{n-2}.\]</p><p>By plugging the Taylor expansion of <span>$\boldsymbol{u}$</span> at times <span>$t_{n+1}$</span>, <span>$t_{n-1}$</span> and <span>$t_{n-2}$</span>, we obtain the exactness condition</p><p class="math-container">\[\cos(z) = \mathrm{tr}(\boldsymbol{A}(z)) - \frac{1}{2} (\mathrm{tr}(\boldsymbol{A}(z))^{2} - \mathrm{tr}(\boldsymbol{A}(z)^{2})) \cos(z) + \det(\boldsymbol{A}(z)) \cos(2z).\]</p><p>These conditions are hard to examine analytically, but one can verify that this scheme is at least of order <span>$1$</span>. Second-order is achieved by setting <span>$\gamma = \frac{1}{2} - \alpha_{M} + \alpha_{F}$</span>.</p><p>It is easier to consider the limit cases <span>$|z| \to 0$</span> and <span>$|z| \to +\infty$</span> and look at the eigenvalues of the amplification matrix.</p><ul><li>When <span>$|z| \to 0$</span>, we find <span>$\rho(\boldsymbol{A}(z)) = \max\left\{1, \left|\frac{\alpha_{M}}{1 - \alpha_{M}}\right|\right\}$</span>.</li><li>When <span>$|z| \to +\infty$</span>, we find <span>$\rho(\boldsymbol{A}(z)) = \max\left\{\left|\frac{\alpha_{F}}{1 - \alpha_{F}}\right|, \left|\frac{4 \beta - (1 + 2 \gamma) \pm \sqrt{(1 + 2 \gamma)^{2} - 16 \beta}}{4 \beta}\right|\right\}$</span>.</li></ul><p>For all these eigenvalues to have a modulus smaller than one, we need <span>$\alpha_{M} \leq \frac{1}{2}$</span>, <span>$\alpha_{F} \leq \frac{1}{2}$</span>, <span>$\gamma \geq \frac{1}{2}$</span>, i.e. <span>$\alpha_{F} \geq \alpha_{M}$</span> and <span>$\beta \geq \frac{1}{2} \gamma$</span>. Since dissipation of high-frequency is maximised when the eigenvalues are real at infinity, we also impose <span>$\beta = \frac{1}{16} (1 + 2 \gamma)^{2}$</span>, i.e. <span>$\beta = \frac{1}{4} (1 - \alpha_{M} + \alpha_{F})^{2}$</span>.</p><p>This method was also designed to damp high-frequency perturbations so it is common practice to parameter this scheme in terms of its spectral radius.</p><ul><li>The Hilbert-Huges-Taylor-<span>$\alpha$</span> (HHT-<span>$\alpha$</span>) method is obtained by setting <span>$\alpha_{M} = 0$</span>, <span>$\alpha_{F} = \frac{1 - \rho_{\infty}}{1 + \rho_{\infty}}$</span>.</li><li>The Wood-Bossak-Zienkiewicz-<span>$\alpha$</span> (WBZ-<span>$\alpha$</span>) method is recovered by setting <span>$\alpha_{F} = 0$</span> and <span>$\alpha_{M} = \frac{\rho_{\infty} - 1}{\rho_{\infty} + 1}$</span>.</li><li>The standard generalised-<span>$\alpha$</span> method is obtained by setting <span>$\alpha_{M} = \frac{2 \rho_{\infty - 1}}{\rho_{\infty} + 1}$</span>, <span>$\alpha_{F} = \frac{\rho_{\infty}}{\rho_{\infty} + 1}$</span>.</li><li>The Newmark method corresponds to <span>$\alpha_{F} = \alpha_{M} = 0$</span>. In this case, the values of <span>$\beta$</span> and <span>$\gamma$</span> are usually chosen as <span>$\beta = 0$</span>, <span>$\gamma = \frac{1}{2}$</span> (explicit central difference scheme), or <span>$\beta = \frac{1}{4}$</span> and <span>$\gamma = \frac{1}{2}$</span> (midpoint rule).</li></ul><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs" href="#Gridap.ODEs"><code>Gridap.ODEs</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>The exported names are</p><ul><li><a href="#Gridap.ODEs.AbstractLinearODE"><code>AbstractLinearODE</code></a></li><li><a href="#Gridap.ODEs.AbstractQuasilinearODE"><code>AbstractQuasilinearODE</code></a></li><li><a href="#Gridap.ODEs.AbstractSemilinearODE"><code>AbstractSemilinearODE</code></a></li><li><a href="#Gridap.ODEs.AbstractTableau"><code>AbstractTableau</code></a></li><li><a href="@ref"><code>BackwardEuler</code></a></li><li><a href="#Gridap.ODEs.ButcherTableau"><code>ButcherTableau</code></a></li><li><a href="#Gridap.ODEs.DiagonallyImplicitTableau"><code>DiagonallyImplicitTableau</code></a></li><li><a href="#Gridap.ODEs.EmbeddedTableau"><code>EmbeddedTableau</code></a></li><li><a href="#Gridap.ODEs.ExplicitTableau"><code>ExplicitTableau</code></a></li><li><a href="#Gridap.ODEs.ForwardEuler"><code>ForwardEuler</code></a></li><li><a href="#Gridap.ODEs.FullyImplicitTableau"><code>FullyImplicitTableau</code></a></li><li><a href="#Gridap.ODEs.GeneralizedAlpha1"><code>GeneralizedAlpha1</code></a></li><li><a href="#Gridap.ODEs.GeneralizedAlpha2"><code>GeneralizedAlpha2</code></a></li><li><a href="#Gridap.ODEs.GenericIMEXODEOperator"><code>GenericIMEXODEOperator</code></a></li><li><a href="#Gridap.ODEs.GenericODESolution"><code>GenericODESolution</code></a></li><li><a href="#Gridap.ODEs.GenericTableau"><code>GenericTableau</code></a></li><li><a href="#Gridap.ODEs.GenericTransientIMEXFEOperator"><code>GenericTransientIMEXFEOperator</code></a></li><li><a href="#Gridap.ODEs.IMEXODEOperator"><code>IMEXODEOperator</code></a></li><li><a href="#Gridap.ODEs.IMEXTableau"><code>IMEXTableau</code></a></li><li><a href="#Gridap.ODEs.ImplicitExplicitTableau"><code>ImplicitExplicitTableau</code></a></li><li><a href="#Gridap.ODEs.ImplicitTableau"><code>ImplicitTableau</code></a></li><li><a href="@ref"><code>LinearODE</code></a></li><li><a href="#Gridap.ODEs.LinearStageOperator"><code>LinearStageOperator</code></a></li><li><a href="@ref"><code>MidPoint</code></a></li><li><a href="@ref"><code>Newmark</code></a></li><li><a href="@ref"><code>NonlinearODE</code></a></li><li><a href="#Gridap.ODEs.NonlinearStageOperator"><code>NonlinearStageOperator</code></a></li><li><a href="#Gridap.ODEs.ODEOpFromTFEOp"><code>ODEOpFromTFEOp</code></a></li><li><a href="#Gridap.ODEs.ODEOpFromTFEOpCache"><code>ODEOpFromTFEOpCache</code></a></li><li><a href="#Gridap.ODEs.ODEOperator"><code>ODEOperator</code></a></li><li><a href="#Gridap.ODEs.ODEOperatorType"><code>ODEOperatorType</code></a></li><li><a href="#Gridap.ODEs.ODESolution"><code>ODESolution</code></a></li><li><a href="#Gridap.ODEs.ODESolver"><code>ODESolver</code></a></li><li><a href="@ref"><code>QuasilinearODE</code></a></li><li><a href="@ref"><code>RungeKutta</code></a></li><li><a href="@ref"><code>SemilinearODE</code></a></li><li><a href="#Gridap.ODEs.StageOperator"><code>StageOperator</code></a></li><li><a href="#Gridap.ODEs.TableauName"><code>TableauName</code></a></li><li><a href="#Gridap.ODEs.TableauType"><code>TableauType</code></a></li><li><a href="#Gridap.ODEs.ThetaMethod"><code>ThetaMethod</code></a></li><li><a href="#Gridap.ODEs.TimeSpaceFunction"><code>TimeSpaceFunction</code></a></li><li><a href="#Gridap.ODEs.TransientCellField"><code>TransientCellField</code></a></li><li><a href="#Gridap.ODEs.TransientFEBasis"><code>TransientFEBasis</code></a></li><li><a href="#Gridap.ODEs.TransientFEOpFromWeakForm"><code>TransientFEOpFromWeakForm</code></a></li><li><a href="#Gridap.ODEs.TransientFEOperator"><code>TransientFEOperator</code></a></li><li><a href="#Gridap.ODEs.TransientFESolution"><code>TransientFESolution</code></a></li><li><a href="#Gridap.ODEs.TransientIMEXFEOperator"><code>TransientIMEXFEOperator</code></a></li><li><a href="#Gridap.ODEs.TransientLinearFEOpFromWeakForm"><code>TransientLinearFEOpFromWeakForm</code></a></li><li><a href="@ref"><code>TransientLinearFEOperator</code></a></li><li><a href="#Gridap.ODEs.TransientMultiFieldCellField"><code>TransientMultiFieldCellField</code></a></li><li><a href="@ref"><code>TransientMultiFieldFESpace</code></a></li><li><a href="#Gridap.ODEs.TransientQuasilinearFEOpFromWeakForm"><code>TransientQuasilinearFEOpFromWeakForm</code></a></li><li><a href="@ref"><code>TransientQuasilinearFEOperator</code></a></li><li><a href="#Gridap.ODEs.TransientSemilinearFEOpFromWeakForm"><code>TransientSemilinearFEOpFromWeakForm</code></a></li><li><a href="@ref"><code>TransientSemilinearFEOperator</code></a></li><li><a href="#Gridap.ODEs.TransientSingleFieldCellField"><code>TransientSingleFieldCellField</code></a></li><li><a href="#Gridap.ODEs.TransientTrialFESpace"><code>TransientTrialFESpace</code></a></li><li><a href="#Gridap.ODEs.allocate_odecache-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>allocate_odecache</code></a></li><li><a href="#Gridap.ODEs.allocate_odeopcache-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}"><code>allocate_odeopcache</code></a></li><li><a href="#Gridap.ODEs.allocate_space-Tuple{TransientTrialFESpace}"><code>allocate_space</code></a></li><li><a href="#Gridap.ODEs.allocate_tfeopcache-Tuple{TransientFEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>allocate_tfeopcache</code></a></li><li><a href="@ref"><code>available_imex_tableaus</code></a></li><li><a href="@ref"><code>available_tableaus</code></a></li><li><a href="#Gridap.ODEs.get_assembler-Tuple{TransientFEOperator}"><code>get_assembler</code></a></li><li><a href="#Gridap.ODEs.get_embedded_order-Tuple{Gridap.ODEs.EmbeddedTableau}"><code>get_embedded_order</code></a></li><li><a href="#Gridap.ODEs.get_embedded_weights-Tuple{Gridap.ODEs.EmbeddedTableau}"><code>get_embedded_weights</code></a></li><li><a href="#Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>get_forms</code></a></li><li><a href="#Gridap.ODEs.get_imex_operators-Tuple{Gridap.ODEs.IMEXODEOperator}"><code>get_imex_operators</code></a></li><li><a href="@ref"><code>get_imex_tableaus</code></a></li><li><a href="#Gridap.ODEs.get_jacs-Tuple{TransientFEOperator}"><code>get_jacs</code></a></li><li><a href="#Gridap.ODEs.get_num_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>get_num_forms</code></a></li><li><a href="#Gridap.ODEs.get_res-Tuple{TransientFEOperator}"><code>get_res</code></a></li><li><a href="#Gridap.ODEs.is_form_constant-Tuple{Gridap.ODEs.ODEOperator, Integer}"><code>is_form_constant</code></a></li><li><a href="@ref"><code>is_padded</code></a></li><li><a href="#Gridap.ODEs.jacobian_add!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}"><code>jacobian_add!</code></a></li><li><a href="@ref"><code>massless_residual_weights</code></a></li><li><a href="#Gridap.ODEs.ode_finish!-Tuple{AbstractVector, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Any, Tuple{Vararg{AbstractVector}}, Any}"><code>ode_finish!</code></a></li><li><a href="#Gridap.ODEs.ode_march!-Tuple{Tuple{Vararg{AbstractVector}}, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>ode_march!</code></a></li><li><a href="#Gridap.ODEs.ode_start-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>ode_start</code></a></li><li><a href="#Gridap.ODEs.test_ode_operator-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}"><code>test_ode_operator</code></a></li><li><a href="#Gridap.ODEs.test_ode_solution-Tuple{Gridap.ODEs.ODESolution}"><code>test_ode_solution</code></a></li><li><a href="#Gridap.ODEs.test_ode_solver-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>test_ode_solver</code></a></li><li><a href="#Gridap.ODEs.test_tfe_operator-Tuple{TransientFEOperator, Real, Gridap.ODEs.TransientCellField}"><code>test_tfe_operator</code></a></li><li><a href="#Gridap.ODEs.test_tfe_solution-Tuple{Gridap.ODEs.TransientFESolution}"><code>test_tfe_solution</code></a></li><li><a href="#Gridap.ODEs.test_tfe_solver-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}"><code>test_tfe_solver</code></a></li><li><a href="#Gridap.ODEs.test_tfe_space-Tuple{FESpace}"><code>test_tfe_space</code></a></li><li><a href="#Gridap.ODEs.time_derivative-Tuple{Any, Val{0}}"><code>time_derivative</code></a></li><li><a href="#Gridap.ODEs.update_odeopcache!-Tuple{Any, Gridap.ODEs.ODEOperator, Real, Vararg{Any}}"><code>update_odeopcache!</code></a></li><li><a href="#Gridap.ODEs.update_tfeopcache!-Tuple{Any, TransientFEOperator, Real}"><code>update_tfeopcache!</code></a></li><li><a href="#Gridap.ODEs.∂t-Tuple{Any}"><code>∂t</code></a></li><li><a href="#Gridap.ODEs.∂tt-Tuple{Any}"><code>∂tt</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEs.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.AbstractLinearODE" href="#Gridap.ODEs.AbstractLinearODE"><code>Gridap.ODEs.AbstractLinearODE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractLinearODE &lt;: AbstractSemilinearODE end</code></pre><p>ODE operator whose residual is linear with respect to all time derivatives, i.e.</p><pre><code class="nohighlight hljs">residual(t, ∂t^0[u], ..., ∂t^N[u]) = ∑_{0 ≤ k ≤ N} A_k(t) ∂t^k[u] - res(t),</code></pre><p>where <code>N</code> is the order of the ODE operator, and <code>∂t^k[u]</code> is the <code>k</code>-th-order time derivative of <code>u</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L42-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.AbstractQuasilinearODE" href="#Gridap.ODEs.AbstractQuasilinearODE"><code>Gridap.ODEs.AbstractQuasilinearODE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractQuasilinearODE &lt;: ODEOperatorType end</code></pre><p>ODE operator whose residual is linear with respect to the highest-order time derivative, i.e.</p><pre><code class="nohighlight hljs">residual(t, ∂t^0[u], ..., ∂t^N[u]) = mass(t, ∂t^0[u], ..., ∂t^(N-1)[u]) ∂t^N[u]
                                   +  res(t, ∂t^0[u], ..., ∂t^(N-1)[u]),</code></pre><p>where <code>N</code> is the order of the ODE operator, <code>∂t^k[u]</code> is the <code>k</code>-th-order time derivative of <code>u</code>, and both <code>mass</code> and <code>res</code> have order <code>N-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L12-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.AbstractSemilinearODE" href="#Gridap.ODEs.AbstractSemilinearODE"><code>Gridap.ODEs.AbstractSemilinearODE</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSemilinearODE &lt;: AbstractQuasilinearODE end</code></pre><p>ODE operator whose residual is linear with respect to the highest-order time derivative, and whose mass matrix only depend on time, i.e.</p><pre><code class="nohighlight hljs">residual(t, ∂t^0[u], ..., ∂t^N[u]) = mass(t) ∂t^N[u]
                                   +  res(t, ∂t^0[u], ..., ∂t^(N-1)[u]),</code></pre><p>where <code>N</code> is the order of the ODE operator, <code>∂t^k[u]</code> is the <code>k</code>-th-order time derivative of <code>u</code>, <code>mass</code> is independent of <code>u</code> and <code>res</code> has order <code>N-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L27-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.AbstractTableau" href="#Gridap.ODEs.AbstractTableau"><code>Gridap.ODEs.AbstractTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractTableau{T} &lt;: GridapType end</code></pre><p>Type that stores the Butcher tableau corresponding to a Runge-Kutta scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIMRungeKutta" href="#Gridap.ODEs.DIMRungeKutta"><code>Gridap.ODEs.DIMRungeKutta</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DIMRungeKutta &lt;: ODESolver end</code></pre><p>Diagonally-implicit Runge-Kutta ODE solver.</p><pre><code class="nohighlight hljs">residual(tx, ux, vx) = 0,

tx = t_n + c[i] * dt
ux = u_n + dt * ∑_{1 ≤ j &lt; i} A[i, j] * slopes[j] + dt * A[i, i] * x
vx = x,

u_(n+1) = u_n + dt * ∑_{1 ≤ i ≤ s} b[i] * slopes[i].</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/RungeKuttaDIM.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_CrankNicolson_2_2" href="#Gridap.ODEs.DIRK_CrankNicolson_2_2"><code>Gridap.ODEs.DIRK_CrankNicolson_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_CrankNicolson_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_LobattoIIIA_2_2" href="#Gridap.ODEs.DIRK_LobattoIIIA_2_2"><code>Gridap.ODEs.DIRK_LobattoIIIA_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_LobattoIIIA_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L84-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_LobattoIIIC_3_4" href="#Gridap.ODEs.DIRK_LobattoIIIC_3_4"><code>Gridap.ODEs.DIRK_LobattoIIIC_3_4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_LobattoIIIC_3_4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L312-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_RadauII_2_3" href="#Gridap.ODEs.DIRK_RadauII_2_3"><code>Gridap.ODEs.DIRK_RadauII_2_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_RadauII_2_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L114-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_RadauI_2_3" href="#Gridap.ODEs.DIRK_RadauI_2_3"><code>Gridap.ODEs.DIRK_RadauI_2_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_RadauI_2_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L96-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_TRBDF_3_2" href="#Gridap.ODEs.DIRK_TRBDF_3_2"><code>Gridap.ODEs.DIRK_TRBDF_3_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_TRBDF_3_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L195-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DIRK_TRX_3_2" href="#Gridap.ODEs.DIRK_TRX_3_2"><code>Gridap.ODEs.DIRK_TRX_3_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DIRK_TRX_3_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L221-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.DiagonallyImplicitTableau" href="#Gridap.ODEs.DiagonallyImplicitTableau"><code>Gridap.ODEs.DiagonallyImplicitTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DiagonallyImplicitTableau &lt;: ImplicitTableau end</code></pre><p>Tableau whose matrix is lower triangular, with at least one nonzero diagonal coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_BogackiShampine_4_3" href="#Gridap.ODEs.EXRK_BogackiShampine_4_3"><code>Gridap.ODEs.EXRK_BogackiShampine_4_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_BogackiShampine_4_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L311-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Euler_1_1" href="#Gridap.ODEs.EXRK_Euler_1_1"><code>Gridap.ODEs.EXRK_Euler_1_1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Euler_1_1
FE</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L11-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Fehlberg_3_2" href="#Gridap.ODEs.EXRK_Fehlberg_3_2"><code>Gridap.ODEs.EXRK_Fehlberg_3_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Fehlberg_3_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L190-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Heun_3_3" href="#Gridap.ODEs.EXRK_Heun_3_3"><code>Gridap.ODEs.EXRK_Heun_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Heun_3_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L129-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Kutta_3_3" href="#Gridap.ODEs.EXRK_Kutta_3_3"><code>Gridap.ODEs.EXRK_Kutta_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Kutta_3_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L120-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Midpoint_2_2" href="#Gridap.ODEs.EXRK_Midpoint_2_2"><code>Gridap.ODEs.EXRK_Midpoint_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Midpoint_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L35-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Ralston_2_2" href="#Gridap.ODEs.EXRK_Ralston_2_2"><code>Gridap.ODEs.EXRK_Ralston_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Ralston_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L63-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Ralston_3_3" href="#Gridap.ODEs.EXRK_Ralston_3_3"><code>Gridap.ODEs.EXRK_Ralston_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Ralston_3_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L154-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Ralston_4_4" href="#Gridap.ODEs.EXRK_Ralston_4_4"><code>Gridap.ODEs.EXRK_Ralston_4_4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Ralston_4_4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L259-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_RungeKutta_4_4" href="#Gridap.ODEs.EXRK_RungeKutta_4_4"><code>Gridap.ODEs.EXRK_RungeKutta_4_4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_RungeKutta_4_4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L217-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_SSP_2_2" href="#Gridap.ODEs.EXRK_SSP_2_2"><code>Gridap.ODEs.EXRK_SSP_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_SSP_2_2
EXRK_Heun_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_SSP_3_2" href="#Gridap.ODEs.EXRK_SSP_3_2"><code>Gridap.ODEs.EXRK_SSP_3_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_SSP_3_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L172-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_SSP_3_3" href="#Gridap.ODEs.EXRK_SSP_3_3"><code>Gridap.ODEs.EXRK_SSP_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_SSP_3_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L163-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_SSP_4_3" href="#Gridap.ODEs.EXRK_SSP_4_3"><code>Gridap.ODEs.EXRK_SSP_4_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_SSP_4_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L287-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Simpson_4_4" href="#Gridap.ODEs.EXRK_Simpson_4_4"><code>Gridap.ODEs.EXRK_Simpson_4_4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Simpson_4_4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L237-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRK_Wray_3_3" href="#Gridap.ODEs.EXRK_Wray_3_3"><code>Gridap.ODEs.EXRK_Wray_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EXRK_Wray_3_3
EXRK_VanDerHouwen_3_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausEX.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EXRungeKutta" href="#Gridap.ODEs.EXRungeKutta"><code>Gridap.ODEs.EXRungeKutta</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EXRungeKutta &lt;: ODESolver end</code></pre><p>Explicit Runge-Kutta ODE solver.</p><pre><code class="nohighlight hljs">residual(tx, ux, vx) = 0,

tx = t_n + c[i] * dt
ux = u_n + ∑_{1 ≤ j &lt; i} A[i, j] * dt * slopes[j]
vx = x
slopes[i] = x,

u_(n+1) = u_n + ∑_{1 ≤ i ≤ s} b[i] * dt * slopes[i].</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/RungeKuttaEX.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.EmbeddedTableau" href="#Gridap.ODEs.EmbeddedTableau"><code>Gridap.ODEs.EmbeddedTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EmbeddedTableau &lt;: AbstractTableau end</code></pre><p>Generic type that stores any type of embedded Butcher tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ExplicitTableau" href="#Gridap.ODEs.ExplicitTableau"><code>Gridap.ODEs.ExplicitTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ExplicitTableau &lt;: TableauType end</code></pre><p>Tableau whose matrix is strictly lower triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ForwardEuler" href="#Gridap.ODEs.ForwardEuler"><code>Gridap.ODEs.ForwardEuler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ForwardEuler &lt;: ODESolver end</code></pre><p>Forward Euler ODE solver.</p><pre><code class="nohighlight hljs">residual(tx, ux, vx) = 0,

tx = t_n
ux = u_n
vx = x,

u_(n+1) = u_n + dt * x.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/ForwardEuler.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.FullyImplicitTableau" href="#Gridap.ODEs.FullyImplicitTableau"><code>Gridap.ODEs.FullyImplicitTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FullyImplicitTableau &lt;: ImplicitTableau end</code></pre><p>Tableau whose matrix has at least one nonzero coefficient in its strict upper triangular part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.GeneralizedAlpha1" href="#Gridap.ODEs.GeneralizedAlpha1"><code>Gridap.ODEs.GeneralizedAlpha1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedAlpha1 &lt;: ODESolver</code></pre><p>Generalized-α first-order ODE solver.</p><pre><code class="nohighlight hljs">residual(tx, ux, vx) = 0,

tx = (1 - αf) * t_n + αf * t_(n+1)
ux = (1 - αf) * u_n + αf * u_(n+1)
vx = (1 - αm) * v_n + αm * v_(n+1),

u_(n+1) = u_n + dt * ((1 - γ) * v_n + γ * x)
v_(n+1) = x.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/GeneralizedAlpha1.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.GeneralizedAlpha2" href="#Gridap.ODEs.GeneralizedAlpha2"><code>Gridap.ODEs.GeneralizedAlpha2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedAlpha2 &lt;: ODESolver</code></pre><p>Generalized-α second-order ODE solver.</p><pre><code class="nohighlight hljs">residual(tx, ux, vx, ax) = 0,

tx = αf * t_n + (1 - αf) * t_(n+1)
ux = αf * u_n + (1 - αf) * u_(n+1)
vx = αf * v_n + (1 - αf) * v_(n+1)
ax = αm * a_n + (1 - αm) * a_(n+1),

u_(n+1) = u_n + dt * v_n + dt^2 / 2 * ((1 - 2 * β) * a_n + 2 * β * x)
v_(n+1) = v_n + dt * ((1 - γ) * a_n + γ * x)
a_(n+1) = x.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/GeneralizedAlpha2.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.GenericIMEXODEOperator" href="#Gridap.ODEs.GenericIMEXODEOperator"><code>Gridap.ODEs.GenericIMEXODEOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GenericIMEXODEOperator &lt;: IMEXODEOperator end</code></pre><p>Generic <code>IMEXODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L586-L590">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.GenericODESolution" href="#Gridap.ODEs.GenericODESolution"><code>Gridap.ODEs.GenericODESolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GenericODESolution &lt;: ODESolution end</code></pre><p>Generic wrapper for the evolution of an <code>ODEOperator</code> with an <code>ODESolver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolutions.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.GenericTableau" href="#Gridap.ODEs.GenericTableau"><code>Gridap.ODEs.GenericTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GenericTableau &lt;: AbstractTableau end</code></pre><p>Generic type that stores any type of Butcher tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.GenericTransientIMEXFEOperator" href="#Gridap.ODEs.GenericTransientIMEXFEOperator"><code>Gridap.ODEs.GenericTransientIMEXFEOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GenericTransientIMEXFEOperator &lt;: TransientIMEXFEOperator end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L849-L851">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXODEOperator" href="#Gridap.ODEs.IMEXODEOperator"><code>Gridap.ODEs.IMEXODEOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type IMEXODEOperator &lt;: ODEOperator end</code></pre><p>Implicit-Explicit decomposition of a residual defining an <code>ODEOperator</code>:</p><pre><code class="nohighlight hljs">residual(t, ∂t^0[u], ..., ∂t^N[u]) = implicit_residual(t, ∂t^0[u], ..., ∂t^N[u])
                                   + explicit_residual(t, ∂t^0[u], ..., ∂t^(N-1)[u]),</code></pre><p>where</p><ul><li>The implicit operator defined by the implicit residual is considered stiff and is meant to be solved implicitly,</li><li>The explicit operator defined by the explicit residual is considered non-stiff and is meant to be solved explicitly.</li></ul><p><strong>Important</strong></p><p>The explicit operator must have one order less than the implicit operator, so that the mass term of the global operator is fully contained in the implicit operator.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Gridap.ODEs.get_imex_operators-Tuple{Gridap.ODEs.IMEXODEOperator}"><code>get_imex_operators(odeop)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L383-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_1_1_1" href="#Gridap.ODEs.IMEXRK_1_1_1"><code>Gridap.ODEs.IMEXRK_1_1_1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_1_1_1</code></pre><p>Backward-Forward Euler pair, order 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_1_2_1" href="#Gridap.ODEs.IMEXRK_1_2_1"><code>Gridap.ODEs.IMEXRK_1_2_1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_1_2_1</code></pre><p>Backward-Forward Euler pair with same weights, order 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_1_2_2" href="#Gridap.ODEs.IMEXRK_1_2_2"><code>Gridap.ODEs.IMEXRK_1_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_1_2_2</code></pre><p>Implicit-Explicit midpoint pair, order 2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_2_2_2" href="#Gridap.ODEs.IMEXRK_2_2_2"><code>Gridap.ODEs.IMEXRK_2_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_2_2_2</code></pre><p>L-stable, 2-stage, 2-order SDIRK</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_2_3_2" href="#Gridap.ODEs.IMEXRK_2_3_2"><code>Gridap.ODEs.IMEXRK_2_3_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_2_3_2</code></pre><p>L-stable, 2-stage, 2-order SDIRK</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_2_3_3" href="#Gridap.ODEs.IMEXRK_2_3_3"><code>Gridap.ODEs.IMEXRK_2_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_2_3_3</code></pre><p>2-stage, 3-order SDIRK scheme with best damping properties</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_3_4_3" href="#Gridap.ODEs.IMEXRK_3_4_3"><code>Gridap.ODEs.IMEXRK_3_4_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_3_4_3</code></pre><p>L-stable, 3-stage, 3-order SDIRK</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRK_4_4_3" href="#Gridap.ODEs.IMEXRK_4_4_3"><code>Gridap.ODEs.IMEXRK_4_4_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXRK_4_4_3</code></pre><p>L-stable, 4-stage, 3-order SDIRK</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausIMEX.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXRungeKutta" href="#Gridap.ODEs.IMEXRungeKutta"><code>Gridap.ODEs.IMEXRungeKutta</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IMEXRungeKutta &lt;: ODESolver</code></pre><p>Implicit-Explicit Runge-Kutta ODE solver.</p><pre><code class="nohighlight hljs">mass(tx, ux) vx + im_res(tx, ux) = 0,

tx = t_n + c[i] * dt
ux = u_n + ∑_{1 ≤ j &lt; i} im_A[i, j] * dt * im_slopes[j] + im_A[i, i] * dt * x
         + ∑_{1 ≤ j &lt; i} ex_A[i, j] * dt * ex_slopes[j]
vx = x
im_slopes[i] = x,

mass(tx, ux) vx + ex_res(tx, ux) = 0,

tx = t_n + c[i] * dt
ux = u_n + ∑_{1 ≤ j ≤ i} im_A[i, j] * dt * im_slopes[j]
         + ∑_{1 ≤ j &lt; i} ex_A[i, j] * dt * ex_slopes[j]
vx = x
ex_slopes[i] = x,

u_(n+1) = u_n + ∑_{1 ≤ i ≤ s} im_b[i] * dt * im_slopes[i]
              + ∑_{1 ≤ i ≤ s} ex_b[i] * dt * ex_slopes[i].</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/RungeKuttaIMEX.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXTableau" href="#Gridap.ODEs.IMEXTableau"><code>Gridap.ODEs.IMEXTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct IMEXTableau &lt;: AbstractTableau end</code></pre><p>Generic type that stores any type of implicit-explicit pair of Butcher tableaus, that form a valid IMEX scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L206-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ImplicitExplicitTableau" href="#Gridap.ODEs.ImplicitExplicitTableau"><code>Gridap.ODEs.ImplicitExplicitTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ImplicitExplicitTableau &lt;: ImplicitTableau end</code></pre><p>Pair of implicit and explicit tableaus that form a valid implicit-explicit scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ImplicitTableau" href="#Gridap.ODEs.ImplicitTableau"><code>Gridap.ODEs.ImplicitTableau</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ImplicitTableau &lt;: TableauType end</code></pre><p>Tableau whose matrix has at least one nonzero coefficient outside its strict lower triangular part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.LinearStageOperator" href="#Gridap.ODEs.LinearStageOperator"><code>Gridap.ODEs.LinearStageOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LinearStageOperator &lt;: StageOperator end</code></pre><p>Linear stage operator representing <code>res(x) = J(t, us) x + r(t, us) = 0</code>, where <code>x</code> is the stage unknown and <code>us</code> denotes the point where the residual of the ODE is to be evaluated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/StageOperators.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.NonlinearStageOperator" href="#Gridap.ODEs.NonlinearStageOperator"><code>Gridap.ODEs.NonlinearStageOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NonlinearStageOperator &lt;: StageOperator end</code></pre><p>Nonlinear stage operator representing <code>res(x) = residual(t, us(x)...) = 0</code>, where <code>x</code> is the stage unknown and <code>us(x)</code> denotes the point where the residual of the ODE is to be evaluated. It is assumed that the coordinates of <code>us(x)</code> are linear in <code>x</code>, and the coefficients in front of <code>x</code> called <code>ws</code> are scalar, i.e. <code>ws[k] = d/dx us[k](x)</code> is a scalar constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/StageOperators.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODEOpFromTFEOp" href="#Gridap.ODEs.ODEOpFromTFEOp"><code>Gridap.ODEs.ODEOpFromTFEOp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ODEOpFromTFEOp &lt;: ODEOperator end</code></pre><p>Wrapper that transforms a <code>TransientFEOperator</code> into an <code>ODEOperator</code>, i.e. takes <code>residual(t, uh, ∂t[uh], ..., ∂t^N[uh], vh)</code> and returns <code>residual(t, us)</code>, where <code>us[k] = ∂t^k[us]</code> and <code>uf</code> represents the free values of <code>uh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOpsFromTFEOps.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODEOpFromTFEOpCache" href="#Gridap.ODEs.ODEOpFromTFEOpCache"><code>Gridap.ODEs.ODEOpFromTFEOpCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ODEOpFromTFEOpCache &lt;: GridapType</code></pre><p>Structure that stores the <code>TransientFESpace</code> and cache of a <code>TransientFEOperator</code>, as well as the jacobian matrices and residual if they are constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOpsFromTFEOps.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODEOperator" href="#Gridap.ODEs.ODEOperator"><code>Gridap.ODEs.ODEOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ODEOperator &lt;: GridapType end</code></pre><p>General implicit, nonlinear ODE operator defined by a residual of the form</p><pre><code class="nohighlight hljs">residual(t, ∂t^0[u], ..., ∂t^N[u]) = 0,</code></pre><p>where <code>N</code> is the order of the ODE operator and <code>∂t^k[u]</code> is the <code>k</code>-th-order time derivative of <code>u</code>.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.AbstractTableau}"><code>get_order(odeop)</code></a></li><li><a href="#Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>get_forms(odeop)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.allocate_residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>allocate_residual(odeop, t, us, odeopcache)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>residual!(r, odeop, t, us, odeopcache; add::Bool)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>allocate_jacobian(odeop, t, us, odeopcache)</code></a></li><li><a href="#Gridap.ODEs.jacobian_add!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}"><code>jacobian_add!(J, odeop, t, us, ws, odeopcache)</code></a></li></ul><p><strong>Optional</strong></p><ul><li><a href="#Gridap.ODEs.get_num_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>get_num_forms(odeop)</code></a></li><li><a href="#Gridap.ODEs.is_form_constant-Tuple{Gridap.ODEs.ODEOperator, Integer}"><code>is_form_constant(odeop, k)</code></a></li><li><a href="#Gridap.ODEs.allocate_odeopcache-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}"><code>allocate_odeopcache(odeop, t, us)</code></a></li><li><a href="#Gridap.ODEs.update_odeopcache!-Tuple{Any, Gridap.ODEs.ODEOperator, Real, Vararg{Any}}"><code>update_odeopcache!(odeopcache, odeop, t)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>residual(odeop, t, us, odeopcache)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>jacobian!(odeop, t, us, ws, odeopcache)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>jacobian(odeop, t, us, ws, odeopcache)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L125-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODEOperatorType" href="#Gridap.ODEs.ODEOperatorType"><code>Gridap.ODEs.ODEOperatorType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ODEOperatorType &lt;: GridapType end</code></pre><p>Trait that indicates the linearity type of an ODE operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODEOperatorType-Union{Tuple{Gridap.ODEs.ODEOperator{T}}, Tuple{T}} where T" href="#Gridap.ODEs.ODEOperatorType-Union{Tuple{Gridap.ODEs.ODEOperator{T}}, Tuple{T}} where T"><code>Gridap.ODEs.ODEOperatorType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEOperatorType(odeop::ODEOperator) -&gt; ODEOperatorType</code></pre><p>Return the <code>ODEOperatorType</code> of the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODEOperatorType-Union{Tuple{TransientFEOperator{T}}, Tuple{T}} where T" href="#Gridap.ODEs.ODEOperatorType-Union{Tuple{TransientFEOperator{T}}, Tuple{T}} where T"><code>Gridap.ODEs.ODEOperatorType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEOperatorType(::Type{&lt;:TransientFEOperator}) -&gt; ODEOperatorType</code></pre><p>Return the <code>ODEOperatorType</code> of the <code>TransientFEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODESolution" href="#Gridap.ODEs.ODESolution"><code>Gridap.ODEs.ODESolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ODESolution &lt;: GridapType end</code></pre><p>Wrapper around an <code>ODEOperator</code> and <code>ODESolver</code> that represents the solution at a set of time steps. It is an iterator that computes the solution at each time step in a lazy fashion when accessing the solution.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}"><code>iterate(odesltn)</code></a></li><li><a href="#Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}"><code>iterate(odesltn, state)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolutions.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ODESolver" href="#Gridap.ODEs.ODESolver"><code>Gridap.ODEs.ODESolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type ODESolver &lt;: GridapType end</code></pre><p>An <code>ODESolver</code> is a map that update state vectors. These state vectors are created at the first iteration from the initial conditions, and are then converted back into the evaluation of the solution at the current time step.</p><p>In the simplest case, the state vectors correspond to the first <code>N-1</code> time derivatives of <code>u</code> at time <code>t_n</code>, where <code>N</code> is the order of the <code>ODEOperator</code>, but some solvers rely on other state variables (values at previous times,  higher-order derivatives...).</p><p><strong>Mandatory</strong></p><ul><li><a href="#Gridap.ODEs.allocate_odecache-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>allocate_odecache(odeslvr, odeop, t0, us0)</code></a></li><li><a href="#Gridap.ODEs.ode_march!-Tuple{Tuple{Vararg{AbstractVector}}, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>ode_march!(stateF, odeslvr, odeop, t0, state0, odecache)</code></a></li></ul><p><strong>Optional</strong></p><ul><li><a href="#Gridap.ODEs.ode_start-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>ode_start(odeslvr, odeop, t0, us0, odecache)</code></a></li><li><a href="#Gridap.ODEs.ode_finish!-Tuple{AbstractVector, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Any, Tuple{Vararg{AbstractVector}}, Any}"><code>ode_finish!(uF, odeslvr, odeop, t0, tF, stateF, odecache)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers.jl#L4-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_2_2" href="#Gridap.ODEs.SDIRK_2_2"><code>Gridap.ODEs.SDIRK_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L141-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_3_2" href="#Gridap.ODEs.SDIRK_3_2"><code>Gridap.ODEs.SDIRK_3_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_3_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L169-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_3_3" href="#Gridap.ODEs.SDIRK_3_3"><code>Gridap.ODEs.SDIRK_3_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_3_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L245-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_4_3" href="#Gridap.ODEs.SDIRK_4_3"><code>Gridap.ODEs.SDIRK_4_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_4_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L334-L336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_Crouzeix_3_4" href="#Gridap.ODEs.SDIRK_Crouzeix_3_4"><code>Gridap.ODEs.SDIRK_Crouzeix_3_4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_Crouzeix_3_4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L265-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_Euler_1_1" href="#Gridap.ODEs.SDIRK_Euler_1_1"><code>Gridap.ODEs.SDIRK_Euler_1_1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_Euler_1_1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L16-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_LobattoIIIC_2_2" href="#Gridap.ODEs.SDIRK_LobattoIIIC_2_2"><code>Gridap.ODEs.SDIRK_LobattoIIIC_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_LobattoIIIC_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L132-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_Midpoint_1_2" href="#Gridap.ODEs.SDIRK_Midpoint_1_2"><code>Gridap.ODEs.SDIRK_Midpoint_1_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_Midpoint_1_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_Norsett_3_4" href="#Gridap.ODEs.SDIRK_Norsett_3_4"><code>Gridap.ODEs.SDIRK_Norsett_3_4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_Norsett_3_4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L288-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_QinZhang_2_2" href="#Gridap.ODEs.SDIRK_QinZhang_2_2"><code>Gridap.ODEs.SDIRK_QinZhang_2_2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_QinZhang_2_2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L75-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.SDIRK_SSP_2_3" href="#Gridap.ODEs.SDIRK_SSP_2_3"><code>Gridap.ODEs.SDIRK_SSP_2_3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK_SSP_2_3
SDIRK_Crouzeix_2_3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/TableausDIM.jl#L150-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.StageOperator" href="#Gridap.ODEs.StageOperator"><code>Gridap.ODEs.StageOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type StageOperator &lt;: NonlinearOperator end</code></pre><p>Operator used to perform one stage within one time step of an <code>ODESolver</code>.</p><p><strong>Mandatory</strong></p><ul><li><a href="../Algebra/#Gridap.Algebra.allocate_residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>allocate_residual(nlop, x)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>residual!(r, nlop, x)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>allocate_jacobian(nlop, x)</code></a></li><li><a href="../Algebra/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.Algebra.NonlinearOperator, AbstractVector}"><code>jacobian!(J, nlop, x)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/StageOperators.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TableauName" href="#Gridap.ODEs.TableauName"><code>Gridap.ODEs.TableauName</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TableauName &lt;: GridapType end</code></pre><p>Name of a Butcher tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TableauType" href="#Gridap.ODEs.TableauType"><code>Gridap.ODEs.TableauType</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TableauType &lt;: GridapType end</code></pre><p>Trait that indicates whether a tableau is explicit, implicit or implicit-explicit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TableauType-Union{Tuple{Gridap.ODEs.AbstractTableau{T}}, Tuple{T}} where T" href="#Gridap.ODEs.TableauType-Union{Tuple{Gridap.ODEs.AbstractTableau{T}}, Tuple{T}} where T"><code>Gridap.ODEs.TableauType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TableauType(::AbstractTableau) -&gt; TableauType</code></pre><p>Return the <code>TableauType</code> of the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ThetaMethod" href="#Gridap.ODEs.ThetaMethod"><code>Gridap.ODEs.ThetaMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ThetaMethod &lt;: ODESolver end</code></pre><p>θ-method ODE solver.</p><pre><code class="nohighlight hljs">residual(tx, ux, vx) = 0,

tx = t_n + θ * dt
ux = u_n + θ * dt * x
vx = x,

u_(n+1) = u_n + dt * x.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/ThetaMethod.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TimeSpaceFunction" href="#Gridap.ODEs.TimeSpaceFunction"><code>Gridap.ODEs.TimeSpaceFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TimeSpaceFunction{F} &lt;: Function end</code></pre><p><code>TimeSpaceFunction</code> allows for convenient ways to apply differential operators to functions that depend on time and space. More precisely, if <code>f</code> is a function that, to a given time, returns a function of space (i.e. <code>f</code> is evaluated at time <code>t</code> and position <code>x</code> via <code>f(t)(x)</code>), then <code>F = TimeSpaceFunction(f)</code> supports the following syntax:</p><ul><li><code>op(F)</code>: a <code>TimeSpaceFunction</code> representing both <code>t -&gt; x -&gt; op(f)(t)(x)</code> and <code>(t, x) -&gt; op(f)(t)(x)</code>,</li><li><code>op(F)(t)</code>: a function of space representing <code>x -&gt; op(f)(t)(x)</code></li><li><code>op(F)(t, x)</code>: the quantity <code>op(f)(t)(x)</code> (this notation is equivalent to <code>op(F)(t)(x)</code>),</li></ul><p>for all spatial and temporal differential operator, i.e. <code>op</code> in <code>(time_derivative, gradient, symmetric_gradient, divergence, curl, laplacian)</code> and their symbolic aliases (<code>∂t</code>, <code>∂tt</code>, <code>∇</code>, ...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TimeDerivatives.jl#L4-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientCellField" href="#Gridap.ODEs.TransientCellField"><code>Gridap.ODEs.TransientCellField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TransientCellField &lt;: CellField end</code></pre><p>Transient version of <code>CellField</code>.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Gridap.ODEs.time_derivative-Tuple{Any}"><code>time_derivative(f)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientCellFields.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientFEBasis" href="#Gridap.ODEs.TransientFEBasis"><code>Gridap.ODEs.TransientFEBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientFEBasis &lt;: FEBasis end</code></pre><p>Transient <code>FEBasis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientCellFields.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientFEOpFromWeakForm" href="#Gridap.ODEs.TransientFEOpFromWeakForm"><code>Gridap.ODEs.TransientFEOpFromWeakForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientFEOpFromWeakForm &lt;: TransientFEOperator end</code></pre><p>Generic <code>TransientFEOperator</code> constructed from the weak formulation of a partial differential equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientFEOperator" href="#Gridap.ODEs.TransientFEOperator"><code>Gridap.ODEs.TransientFEOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TransientFEOperator &lt;: GridapType end</code></pre><p>Transient version of <code>FEOperator</code> corresponding to a residual of the form</p><pre><code class="nohighlight hljs">residual(t, u, v) = 0,</code></pre><p>where <code>residual</code> is linear in <code>v</code>. Time derivatives of <code>u</code> can be included by using the <code>∂t</code> operator.</p><p><strong>Important</strong></p><p>For now, the residual and jacobians cannot be directly computed on a <code>TransientFEOperator</code>. They have to be evaluated on the corresponding algebraic operator, which is an <code>ODEOperator</code>. As such, <code>TransientFEOperator</code> is not exactly a subtype of <code>FEOperator</code>, but rather at the intersection of <code>FEOperator</code> and <code>ODEOperator</code>. This is because the <code>ODEOperator</code> works with vectors and it is optimised to take advantage of constant forms.</p><p><strong>Mandatory</strong></p><ul><li><a href="../FESpaces/#Gridap.FESpaces.get_test-Tuple{FEOperator}"><code>get_test(tfeop)</code></a></li><li><a href="../FESpaces/#Gridap.FESpaces.get_trial-Tuple{FEOperator}"><code>get_trial(tfeop)</code></a></li><li><a href="#Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.AbstractTableau}"><code>get_order(tfeop)</code></a></li><li><a href="#Gridap.ODEs.get_res-Tuple{TransientFEOperator}"><code>get_res(tfeop::TransientFEOperator)</code></a></li><li><a href="#Gridap.ODEs.get_jacs-Tuple{TransientFEOperator}"><code>get_jacs(tfeop::TransientFEOperator)</code></a></li><li><a href="#Gridap.ODEs.get_forms-Tuple{TransientFEOperator}"><code>get_forms(tfeop::TransientFEOperator)</code></a></li><li><a href="#Gridap.ODEs.get_assembler-Tuple{TransientFEOperator}"><code>get_assembler(tfeop)</code></a></li></ul><p><strong>Optional</strong></p><ul><li><a href="../FESpaces/#Gridap.FESpaces.get_algebraic_operator-Tuple{FEOperator}"><code>get_algebraic_operator(tfeop)</code></a></li><li><a href="#Gridap.ODEs.get_num_forms-Tuple{TransientFEOperator}"><code>get_num_forms(tfeop::TransientFEOperator)</code></a></li><li><a href="#Gridap.ODEs.is_form_constant-Tuple{Gridap.ODEs.ODEOperator, Integer}"><code>is_form_constant(tfeop, k)</code></a></li><li><a href="#Gridap.ODEs.allocate_tfeopcache-Tuple{TransientFEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>allocate_tfeopcache(tfeop)</code></a></li><li><a href="#Gridap.ODEs.update_tfeopcache!-Tuple{Any, TransientFEOperator, Real}"><code>update_tfeopcache!(tfeopcache, tfeop, t)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientFESolution" href="#Gridap.ODEs.TransientFESolution"><code>Gridap.ODEs.TransientFESolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TransientFESolution &lt;: GridapType end</code></pre><p>Wrapper around a <code>TransientFEOperator</code> and <code>ODESolver</code> that represents the solution at a set of time steps. It is an iterator that computes the solution at each time step in a lazy fashion when accessing the solution.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}"><code>iterate(tfesltn)</code></a></li><li><a href="#Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}"><code>iterate(tfesltn, state)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESolutions.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientIMEXFEOperator" href="#Gridap.ODEs.TransientIMEXFEOperator"><code>Gridap.ODEs.TransientIMEXFEOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TransientIMEXFEOperator &lt;: TransientFEOperator end</code></pre><p>Implicit-Explicit decomposition of a residual defining a <code>TransientFEOperator</code>:</p><pre><code class="nohighlight hljs">residual(t, u, v) = implicit_residual(t, u, v)
                  + explicit_residual(t, u, v),</code></pre><p>where</p><ul><li>The implicit operator defined by the implicit residual is considered stiff and is meant to be solved implicitly,</li><li>The explicit operator defined by the explicit residual is considered non-stiff and is meant to be solved explicitly.</li><li>Both the implicit and explicit residuals are linear in <code>v</code>.</li></ul><p><strong>Important</strong></p><p>The explicit operator must have one order less than the implicit operator, so that the mass term of the global operator is fully contained in the implicit operator.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Gridap.ODEs.get_imex_operators-Tuple{Gridap.ODEs.IMEXODEOperator}"><code>get_imex_operators(tfeop)</code></a></li></ul><p><strong>Optional</strong></p><ul><li><a href="../FESpaces/#Gridap.FESpaces.get_test-Tuple{FEOperator}"><code>get_test(tfeop)</code></a></li><li><a href="../FESpaces/#Gridap.FESpaces.get_trial-Tuple{FEOperator}"><code>get_trial(tfeop)</code></a></li><li><a href="../FESpaces/#Gridap.FESpaces.get_algebraic_operator-Tuple{FEOperator}"><code>get_algebraic_operator(tfeop)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L760-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientLinearFEOpFromWeakForm" href="#Gridap.ODEs.TransientLinearFEOpFromWeakForm"><code>Gridap.ODEs.TransientLinearFEOpFromWeakForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientLinearFEOpFromWeakForm &lt;: TransientFEOperator end</code></pre><p>Transient <code>FEOperator</code> defined by a transient weak form</p><pre><code class="nohighlight hljs">residual(t, u, v) = ∑_{0 ≤ k ≤ N} form_k(t, ∂t^k[u], v) - res(t, v) = 0,</code></pre><p>where <code>N</code> is the order of the operator, <code>form_k</code> is linear in <code>∂t^k[u]</code> and does not depend on the other time derivatives of <code>u</code>, and the <code>form_k</code> and <code>res</code> are linear in <code>v</code>.</p><p>For convenience, the form corresponding to order <code>k</code> has to be written as a function of <code>∂t^k[u]</code>, i.e. as a linear form, and the residual as a function of <code>t</code> and <code>v</code> only.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L641-L655">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientMultiFieldCellField" href="#Gridap.ODEs.TransientMultiFieldCellField"><code>Gridap.ODEs.TransientMultiFieldCellField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientMultiFieldCellField &lt;: TransientCellField end</code></pre><p>Transient <code>CellField</code> for a multi-field <code>FESpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientCellFields.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientQuasilinearFEOpFromWeakForm" href="#Gridap.ODEs.TransientQuasilinearFEOpFromWeakForm"><code>Gridap.ODEs.TransientQuasilinearFEOpFromWeakForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientQuasilinearFEOpFromWeakForm &lt;: TransientFEOperator end</code></pre><p>Transient <code>FEOperator</code> defined by a transient weak form</p><pre><code class="nohighlight hljs">residual(t, u, v) = mass(t, u, ∂t^N[u], v) + res(t, u, v) = 0.</code></pre><p>Let <code>N</code> be the order of the operator. We impose the following conditions:</p><ul><li><code>mass</code> is linear in the <code>N</code>-th-order time derivative of <code>u</code>,</li><li><code>res</code> has order <code>N-1</code>,</li><li>both <code>mass</code> and <code>res</code> are linear in <code>v</code>.</li></ul><p>For convenience, the mass matrix has to be specified as a function of <code>u</code> for the nonlinear part, and <code>∂t^N[u]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L320-L334">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientSemilinearFEOpFromWeakForm" href="#Gridap.ODEs.TransientSemilinearFEOpFromWeakForm"><code>Gridap.ODEs.TransientSemilinearFEOpFromWeakForm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientSemilinearFEOpFromWeakForm &lt;: TransientFEOperator end</code></pre><p>Transient <code>FEOperator</code> defined by a transient weak form</p><pre><code class="nohighlight hljs">residual(t, u, v) = mass(t, ∂t^N[u], v) + res(t, u, v) = 0.</code></pre><p>Let <code>N</code> be the order of the operator. We impose the following conditions:</p><ul><li><code>mass</code> is linear in the <code>N</code>-th-order time derivative of <code>u</code>,</li><li><code>res</code> has order <code>N-1</code>,</li><li>both <code>mass</code> and <code>res</code> are linear in <code>v</code>.</li></ul><p>For convenience, the mass matrix has to be specified as a function of <code>∂t^N[u]</code>, i.e. as a linear form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L474-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientSingleFieldCellField" href="#Gridap.ODEs.TransientSingleFieldCellField"><code>Gridap.ODEs.TransientSingleFieldCellField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientSingleFieldCellField &lt;: TransientCellField end</code></pre><p>Transient <code>CellField</code> for a single-field <code>FESpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientCellFields.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientTrialFESpace" href="#Gridap.ODEs.TransientTrialFESpace"><code>Gridap.ODEs.TransientTrialFESpace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct TransientTrialFESpace &lt;: SingleFieldFESpace end</code></pre><p>Transient version of <code>TrialFESpace</code>: the Dirichlet boundary conditions are allowed to be time-dependent.</p><p><strong>Mandatory</strong></p><ul><li><a href="#Gridap.ODEs.allocate_space-Tuple{TransientTrialFESpace}"><code>allocate_space(space)</code></a></li><li><a href="../Arrays/#Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any}}"><code>evaluate!(space, t)</code></a></li><li><a href="../Arrays/#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(space, t)</code></a></li><li><a href="#Gridap.ODEs.time_derivative-Tuple{Any}"><code>time_derivative(space)</code></a></li></ul><p><strong>Optional</strong></p><ul><li><a href="../Arrays/#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(space, t::Real)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.TransientTrialFESpace-Tuple{Any}" href="#Gridap.ODEs.TransientTrialFESpace-Tuple{Any}"><code>Gridap.ODEs.TransientTrialFESpace</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(space::TransientTrialFESpace)(t) -&gt; FESpace</code></pre><p>Alias for <a href="../Arrays/#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any}}"><code>evaluate(space, t)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}" href="#Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.iterate(odesltn::ODESolution) -&gt; ((Real, AbstractVector), StateType)</code></pre><p>Perform one time step of the <code>ODEOperator</code> with the <code>ODESolver</code> attached to the <code>ODESolution</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolutions.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{Gridap.ODEs.ODESolution}" href="#Base.iterate-Tuple{Gridap.ODEs.ODESolution}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.iterate(odesltn::ODESolution) -&gt; ((Real, AbstractVector), StateType)</code></pre><p>Allocate the operators and cache and perform one time step of the <code>ODEOperator</code> with the <code>ODESolver</code> attached to the <code>ODESolution</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolutions.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{Gridap.ODEs.TransientFESolution, Any}" href="#Base.iterate-Tuple{Gridap.ODEs.TransientFESolution, Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.iterate(tfesltn::TransientFESolution) -&gt; ((Real, FEFunction), StateType)</code></pre><p>Perform one step of the <code>ODEOperator</code> with the <code>ODESolver</code> attached to the <code>TransientFESolution</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESolutions.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.iterate-Tuple{Gridap.ODEs.TransientFESolution}" href="#Base.iterate-Tuple{Gridap.ODEs.TransientFESolution}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.iterate(tfesltn::TransientFESolution) -&gt; ((Real, FEFunction), StateType)</code></pre><p>Allocate a cache and perform one step of the <code>ODEOperator</code> with the <code>ODESolver</code> attached to the <code>TransientFESolution</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESolutions.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.allocate_jacobian-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.Algebra.allocate_jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_jacobian(
  odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}},
  odeopcache
) -&gt; AbstractMatrix</code></pre><p>Allocate a jacobian matrix for the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L292-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.allocate_residual-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.Algebra.allocate_residual-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.Algebra.allocate_residual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_residual(
  odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}},
  odeopcache
) -&gt; AbstractVector</code></pre><p>Allocate a residual vector for the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L238-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.get_matrix-Tuple{Gridap.ODEs.AbstractTableau}" href="#Gridap.Algebra.get_matrix-Tuple{Gridap.ODEs.AbstractTableau}"><code>Gridap.Algebra.get_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_matrix(tableau::AbstractTableau) -&gt; AbstractMatrix</code></pre><p>Return the matrix of the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}" href="#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}"><code>Gridap.Algebra.jacobian!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian!(
  J::AbstractMatrix, odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}}, ws::Tuple{Vararg{Real}},
  odeopcache
) -&gt; AbstractMatrix</code></pre><p>Compute the jacobian of the residual of the <code>ODEOperator</code> with respect to all time derivatives, weighted by some factors <code>ws</code>.</p><p>The weights are ordered by increasing order of time derivative, i.e. the first weight corresponds to <code>∂residual / ∂u</code> and the last to <code>∂residual / ∂(d^N u / dt^N)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L335-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.jacobian-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}" href="#Gridap.Algebra.jacobian-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}"><code>Gridap.Algebra.jacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian(
  odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}}, ws::Tuple{Vararg{Real}},
  odeopcache
) -&gt; AbstractMatrix</code></pre><p>Allocate a jacobian matrix for the <code>ODEOperator</code> and compute the jacobian of the residual of the <code>ODEOperator</code> with respect to all time derivatives, weighted by some factors <code>ws</code>.</p><p>The weights are ordered by increasing order of time derivative, i.e. the first weight corresponds to <code>∂residual / ∂u</code> and the last to <code>∂residual / ∂(d^N u / dt^N)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L357-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.Algebra.residual!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual!(
  r::AbstractVector, odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}},
  odeopcache; add::Bool=false
) -&gt; AbstractVector</code></pre><p>Compute the residual of the <code>ODEOperator</code>. If <code>add</code> is true, this function adds to <code>r</code> instead of erasing it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L255-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.residual-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.Algebra.residual-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.Algebra.residual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">residual(
  odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}},
  odeopcache
) -&gt; AbstractVector</code></pre><p>Allocate a vector and evaluate the residual of the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L273-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.solve-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}" href="#Gridap.Algebra.solve-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}"><code>Gridap.Algebra.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(
  odeslvr::ODESolver, odeop::ODEOperator,
  t0::Real, tF::Real, us0::Tuple{Vararg{AbstractVector}},
) -&gt; ODESolution</code></pre><p>Create an <code>ODESolution</code> wrapper around the <code>ODEOperator</code> and <code>ODESolver</code>, starting with state <code>us0</code> at time <code>t0</code>, to be evolved until <code>tF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolutions.jl#L126-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Algebra.solve-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{CellField}}}" href="#Gridap.Algebra.solve-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{CellField}}}"><code>Gridap.Algebra.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(
  odeslvr::ODESolver, tfeop::TransientFEOperator,
  t0::Real, tF::Real, uhs0
) -&gt; TransientFESolution</code></pre><p>Create a <code>TransientFESolution</code> wrapper around the <code>TransientFEOperator</code> and <code>ODESolver</code>, starting at time <code>t0</code> with state <code>us0</code>, to be evolved until <code>tF</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESolutions.jl#L114-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Arrays.evaluate!-Tuple{FESpace, TransientTrialFESpace, Real}" href="#Gridap.Arrays.evaluate!-Tuple{FESpace, TransientTrialFESpace, Real}"><code>Gridap.Arrays.evaluate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate!(
  transient_space::FESpace,
  space::TransientTrialFESpace, t::Real
) -&gt; FESpace</code></pre><p>Replace the Dirichlet values of the space by those at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Arrays.evaluate-Tuple{TransientTrialFESpace, Nothing}" href="#Gridap.Arrays.evaluate-Tuple{TransientTrialFESpace, Nothing}"><code>Gridap.Arrays.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(space::TransientTrialFESpace, t::Nothing) -&gt; FESpace</code></pre><p>Evaluating at <code>nothing</code> means that the Dirichlet values are not important.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Arrays.evaluate-Tuple{TransientTrialFESpace, Real}" href="#Gridap.Arrays.evaluate-Tuple{TransientTrialFESpace, Real}"><code>Gridap.Arrays.evaluate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate(space::TransientTrialFESpace, t::Real) -&gt; FESpace</code></pre><p>Allocate a transient space and evaluate the Dirichlet values at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ButcherTableau" href="#Gridap.ODEs.ButcherTableau"><code>Gridap.ODEs.ButcherTableau</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ButcherTableau(name::TableauName, type::Type) -&gt; AbtractTableau</code></pre><p>Builds the Butcher tableau corresponding to a <code>TableauName</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.IMEXODEOperatorType-Tuple{Type{&lt;:Gridap.ODEs.ODEOperatorType}, Type{&lt;:Gridap.ODEs.ODEOperatorType}}" href="#Gridap.ODEs.IMEXODEOperatorType-Tuple{Type{&lt;:Gridap.ODEs.ODEOperatorType}, Type{&lt;:Gridap.ODEs.ODEOperatorType}}"><code>Gridap.ODEs.IMEXODEOperatorType</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IMEXODEOperatorType(
  T_im::Type{&lt;:ODEOperatorType},
  T_ex::Type{&lt;:ODEOperatorType}
) -&gt; ODEOperatorType</code></pre><p>Return the <code>ODEOperatorType</code> of the operator defined by an IMEX decomposition. This function should be called in the constructors of concrete IMEX operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs._to_transient_single_fields-Tuple{Any, Any}" href="#Gridap.ODEs._to_transient_single_fields-Tuple{Any, Any}"><code>Gridap.ODEs._to_transient_single_fields</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_to_transient_single_fields(
  multi_field,
  derivatives
) -&gt; Vector{&lt;:TransientSingleFieldCellField}</code></pre><p>Convert a <code>TransientMultiFieldCellField</code> into a vector of <code>TransientSingleFieldCellField</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientCellFields.jl#L259-L267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.allocate_odecache-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}" href="#Gridap.ODEs.allocate_odecache-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>Gridap.ODEs.allocate_odecache</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_odecache(
  odeslvr::ODESolver, odeop::ODEOperator,
  t0::Real, us0::Tuple{Vararg{AbstractVector}}
) -&gt; CacheType</code></pre><p>Allocate the cache of the <code>ODESolver</code> applied to the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers.jl#L26-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.allocate_odeopcache-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}" href="#Gridap.ODEs.allocate_odeopcache-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}"><code>Gridap.ODEs.allocate_odeopcache</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_odeopcache(
  odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}}, args...
) -&gt; CacheType</code></pre><p>Allocate the cache required by the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L214-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.allocate_space-Tuple{TransientTrialFESpace}" href="#Gridap.ODEs.allocate_space-Tuple{TransientTrialFESpace}"><code>Gridap.ODEs.allocate_space</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_space(space::TransientTrialFESpace) -&gt; FESpace</code></pre><p>Allocate a transient space, intended to be updated at every time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.allocate_tfeopcache-Tuple{TransientFEOperator, Real, Tuple{Vararg{AbstractVector}}}" href="#Gridap.ODEs.allocate_tfeopcache-Tuple{TransientFEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>Gridap.ODEs.allocate_tfeopcache</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_tfeopcache(
  tfeop::TransientFEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}}
) -&gt; CacheType</code></pre><p>Allocate the cache of the <code>TransientFEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.check_imex_compatibility-Tuple{Integer, Integer}" href="#Gridap.ODEs.check_imex_compatibility-Tuple{Integer, Integer}"><code>Gridap.ODEs.check_imex_compatibility</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_imex_compatibility(im_order::Integer, ex_order::Integer) -&gt; Bool</code></pre><p>Check whether two operators can make a valid IMEX operator decomposition. This function should be called in the constructors of concrete IMEX operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_assembler-Tuple{TransientFEOperator}" href="#Gridap.ODEs.get_assembler-Tuple{TransientFEOperator}"><code>Gridap.ODEs.get_assembler</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_assembler(tfeop::TransientFEOperator) -&gt; Assembler</code></pre><p>Return the assembler of the <code>TransientFEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_embedded_order-Tuple{Gridap.ODEs.EmbeddedTableau}" href="#Gridap.ODEs.get_embedded_order-Tuple{Gridap.ODEs.EmbeddedTableau}"><code>Gridap.ODEs.get_embedded_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_embedded_order(tableau::EmbeddedTableau) -&gt; Integer</code></pre><p>Return the embedded order of the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_embedded_weights-Tuple{Gridap.ODEs.EmbeddedTableau}" href="#Gridap.ODEs.get_embedded_weights-Tuple{Gridap.ODEs.EmbeddedTableau}"><code>Gridap.ODEs.get_embedded_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_embedded_weights(tableau::EmbeddedTableau) -&gt; AbstractVector</code></pre><p>Return the embedded weight of the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}" href="#Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>Gridap.ODEs.get_forms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_forms(odeop::ODEOperator) -&gt; Tuple{Vararg{Function}}</code></pre><p>Return the linear forms of the <code>ODEOperator</code>:</p><ul><li>For a general ODE operator, return an empty tuple,</li><li>For a quasilinear ODE operator, return a tuple with the mass matrix,</li><li>For a linear ODE operator, return all the linear forms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L188-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_forms-Tuple{TransientFEOperator}" href="#Gridap.ODEs.get_forms-Tuple{TransientFEOperator}"><code>Gridap.ODEs.get_forms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_forms(tfeop::TransientFEOperator) -&gt; Function</code></pre><p>Return the bilinear forms of the <code>TransientFEOperator</code>:</p><ul><li>For a general transient FE operator, return nothing,</li><li>For a quasilinear transient FE operator, return the mass matrix,</li><li>For a linear transient FE operator, return all the linear forms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L104-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_imex_operators-Tuple{Gridap.ODEs.IMEXODEOperator}" href="#Gridap.ODEs.get_imex_operators-Tuple{Gridap.ODEs.IMEXODEOperator}"><code>Gridap.ODEs.get_imex_operators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_imex_operators(odeop::IMEXODEOperator) -&gt; (ODEOperator, ODEOperator)</code></pre><p>Return the implicit and explicit parts of the <code>IMEXODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L417-L421">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_imex_operators-Tuple{TransientIMEXFEOperator}" href="#Gridap.ODEs.get_imex_operators-Tuple{TransientIMEXFEOperator}"><code>Gridap.ODEs.get_imex_operators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_imex_operators(tfeop::TransientIMEXFEOperator) -&gt; (TransientFEOperator, TransientFEOperator)</code></pre><p>Return the implicit and explicit parts of the <code>TransientIMEXFEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L788-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_jacs-Tuple{TransientFEOperator}" href="#Gridap.ODEs.get_jacs-Tuple{TransientFEOperator}"><code>Gridap.ODEs.get_jacs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_jacs(tfeop::TransientFEOperator) -&gt; Tuple{Vararg{Function}}</code></pre><p>Return the jacobians of the <code>TransientFEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_num_forms-Tuple{Gridap.ODEs.ODEOperator}" href="#Gridap.ODEs.get_num_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>Gridap.ODEs.get_num_forms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_forms(odeop::ODEOperator) -&gt; Integer</code></pre><p>Return the number of linear forms of the <code>ODEOperator</code>. See <a href="#Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>get_forms</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_num_forms-Tuple{TransientFEOperator}" href="#Gridap.ODEs.get_num_forms-Tuple{TransientFEOperator}"><code>Gridap.ODEs.get_num_forms</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_num_forms(tfeop::TransientFEOperator) -&gt; Integer</code></pre><p>Return the number of bilinear forms of the <code>TransientFEOperator</code>. See <a href="#Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}"><code>get_forms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.get_res-Tuple{TransientFEOperator}" href="#Gridap.ODEs.get_res-Tuple{TransientFEOperator}"><code>Gridap.ODEs.get_res</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_res(tfeop::TransientFEOperator) -&gt; Function</code></pre><p>Return the lowest-order element in the decomposition of the residual of the <code>ODEOperator</code>:</p><ul><li>In the general case, return the whole residual,</li><li>For an <code>AbstractQuasilinearODE</code>, return the residual excluding the mass term,</li><li>For an <code>AbstractLinearODE</code>, return the forcing term.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L64-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.is_form_constant-Tuple{Gridap.ODEs.ODEOperator, Integer}" href="#Gridap.ODEs.is_form_constant-Tuple{Gridap.ODEs.ODEOperator, Integer}"><code>Gridap.ODEs.is_form_constant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_form_constant(odeop::ODEOperator, k::Integer) -&gt; Bool</code></pre><p>Indicate whether the linear form of the <code>ODEOperator</code> corresponding to the <code>k</code>-th-order time derivative of <code>u</code> is constant with respect to <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.is_form_constant-Tuple{TransientFEOperator, Integer}" href="#Gridap.ODEs.is_form_constant-Tuple{TransientFEOperator, Integer}"><code>Gridap.ODEs.is_form_constant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_form_constant(tfeop::TransientFEOperator, k::Integer) -&gt; Bool</code></pre><p>Indicate whether the bilinear form of the <code>TransientFEOperator</code> corresponding to the <code>k</code>-th-order time derivative of <code>u</code> is constant with respect to <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.jacobian_add!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}" href="#Gridap.ODEs.jacobian_add!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}"><code>Gridap.ODEs.jacobian_add!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobian_add!(
  J::AbstractMatrix, odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}}, ws::Tuple{Vararg{Real}},
  odeopcache
) -&gt; AbstractMatrix</code></pre><p>Add the jacobian of the residual of the <code>ODEOperator</code> with respect to all time derivatives, weighted by some factors <code>ws</code>.</p><p>The weights are ordered by increasing order of time derivative, i.e. the first weight corresponds to <code>∂residual / ∂u</code> and the last to <code>∂residual / ∂(d^N u / dt^N)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L315-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ode_finish!-Tuple{AbstractVector, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Any, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.ODEs.ode_finish!-Tuple{AbstractVector, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Any, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.ODEs.ode_finish!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ode_finish!(
  uF::AbstractVector,
  odeslvr::ODESolver, odeop::ODEOperator,
  t0::Real, tF, stateF::Tuple{Vararg{AbstractVector}},
  odecache
) -&gt; (AbstractVector, CacheType)</code></pre><p>Convert the state vectors into the evaluation of the solution of the ODE at the current time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ode_march!-Tuple{Tuple{Vararg{AbstractVector}}, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.ODEs.ode_march!-Tuple{Tuple{Vararg{AbstractVector}}, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.ODEs.ode_march!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ode_march!(
  stateF::Tuple{Vararg{AbstractVector}},
  odeslvr::ODESolver, odeop::ODEOperator,
  t0::Real, state0::Tuple{Vararg{AbstractVector}},
  odecache
) -&gt; (Real, Tuple{Vararg{AbstractVector}}, CacheType)</code></pre><p>March the state vector for one time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers.jl#L59-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.ode_start-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}" href="#Gridap.ODEs.ode_start-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}"><code>Gridap.ODEs.ode_start</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ode_start(
  odeslvr::ODESolver, odeop::ODEOperator,
  t0::Real, us0::Tuple{Vararg{AbstractVector}},
  odecache
) -&gt; (Tuple{Vararg{AbstractVector}}, CacheType)</code></pre><p>Convert the initial conditions into state vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_ode_operator-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}" href="#Gridap.ODEs.test_ode_operator-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}"><code>Gridap.ODEs.test_ode_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_ode_operator(
  odeop::ODEOperator,
  t::Real, us::Tuple{Vararg{AbstractVector}}, args...
) -&gt; Bool</code></pre><p>Test the interface of <code>ODEOperator</code> specializations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L615-L622">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_ode_solution-Tuple{Gridap.ODEs.ODESolution}" href="#Gridap.ODEs.test_ode_solution-Tuple{Gridap.ODEs.ODESolution}"><code>Gridap.ODEs.test_ode_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_ode_solution(odesltn::ODESolution) -&gt; Bool</code></pre><p>Test the interface of <code>ODESolution</code> specializations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolutions.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_ode_solver-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}" href="#Gridap.ODEs.test_ode_solver-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}"><code>Gridap.ODEs.test_ode_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_ode_solver(
  odeslvr::ODESolver, odeop::ODEOperator,
  t0::Real, us0::Tuple{Vararg{AbstractVector}}
) -&gt; Bool</code></pre><p>Test the interface of <code>ODESolver</code> specializations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_tfe_operator-Tuple{TransientFEOperator, Real, Gridap.ODEs.TransientCellField}" href="#Gridap.ODEs.test_tfe_operator-Tuple{TransientFEOperator, Real, Gridap.ODEs.TransientCellField}"><code>Gridap.ODEs.test_tfe_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_tfe_operator(
  tfeop::TransientFEOperator,
  t::Real, uh::TransientCellField
) -&gt; Bool</code></pre><p>Test the interface of <code>TransientFEOperator</code> specializations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L882-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_tfe_solution-Tuple{Gridap.ODEs.TransientFESolution}" href="#Gridap.ODEs.test_tfe_solution-Tuple{Gridap.ODEs.TransientFESolution}"><code>Gridap.ODEs.test_tfe_solution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_tfe_solution(tfesltn::TransientFESolution) -&gt; Bool</code></pre><p>Test the interface of <code>TransientFESolution</code> specializations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESolutions.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_tfe_solver-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}" href="#Gridap.ODEs.test_tfe_solver-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}"><code>Gridap.ODEs.test_tfe_solver</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_tfe_solver(
  odeslvr::ODESolver, tfeop::TransientFEOperator,
  t0::Real, tF::Real, uhs0
) -&gt; Bool</code></pre><p>Test the interface of <code>ODESolver</code> specializations on <code>TransientFEOperator</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESolutions.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.test_tfe_space-Tuple{FESpace}" href="#Gridap.ODEs.test_tfe_space-Tuple{FESpace}"><code>Gridap.ODEs.test_tfe_space</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_tfe_space(U::FESpace) -&gt; Bool</code></pre><p>Test the transient interface of <code>FESpace</code> specializations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L218-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.time_derivative-Tuple{Any, Val{0}}" href="#Gridap.ODEs.time_derivative-Tuple{Any, Val{0}}"><code>Gridap.ODEs.time_derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_derivative(f::DerivableType, ::Val{k}) -&gt; DerivableType</code></pre><p>Build the <code>k</code>-th-order time derivative operator for <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TimeDerivatives.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.time_derivative-Tuple{Any}" href="#Gridap.ODEs.time_derivative-Tuple{Any}"><code>Gridap.ODEs.time_derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_derivative(f::DerivableType) -&gt; DerivableType</code></pre><p>Build the first-order time derivative operator for <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TimeDerivatives.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.time_derivative-Tuple{TransientTrialFESpace}" href="#Gridap.ODEs.time_derivative-Tuple{TransientTrialFESpace}"><code>Gridap.ODEs.time_derivative</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_derivative(space::TransientTrialFESpace) -&gt; FESpace</code></pre><p>First-order time derivative of the Dirichlet functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFESpaces.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.update_odeopcache!-Tuple{Any, Gridap.ODEs.ODEOperator, Real, Vararg{Any}}" href="#Gridap.ODEs.update_odeopcache!-Tuple{Any, Gridap.ODEs.ODEOperator, Real, Vararg{Any}}"><code>Gridap.ODEs.update_odeopcache!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_odeopcache!(odeopcache, odeop::ODEOperator, t::Real, args...) -&gt; CacheType</code></pre><p>Update the cache of the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L229-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.update_tfeopcache!-Tuple{Any, TransientFEOperator, Real}" href="#Gridap.ODEs.update_tfeopcache!-Tuple{Any, TransientFEOperator, Real}"><code>Gridap.ODEs.update_tfeopcache!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_tfeopcache!(tfeopcache, tfeop::TransientFEOperator, t::Real) -&gt; CacheType</code></pre><p>Update the cache of the <code>TransientFEOperator</code> at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TransientFEOperators.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.∂t-Tuple{Any}" href="#Gridap.ODEs.∂t-Tuple{Any}"><code>Gridap.ODEs.∂t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂t(f::DerivableType) -&gt; DerivableType</code></pre><p>Build the first-th-order time derivative operator for <code>f</code>.</p><p>Alias for <code>time_derivative(f)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TimeDerivatives.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.∂t-Union{Tuple{k}, Tuple{Any, Val{k}}} where k" href="#Gridap.ODEs.∂t-Union{Tuple{k}, Tuple{Any, Val{k}}} where k"><code>Gridap.ODEs.∂t</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂t(f::DerivableType, ::Val{k}) -&gt; DerivableType</code></pre><p>Build the <code>k</code>-th-order time derivative operator for <code>f</code>.</p><p>Alias for <code>time_derivative(f, Val(k))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TimeDerivatives.jl#L82-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ODEs.∂tt-Tuple{Any}" href="#Gridap.ODEs.∂tt-Tuple{Any}"><code>Gridap.ODEs.∂tt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∂tt(f::DerivableType) -&gt; DerivableType</code></pre><p>Second-order time derivative operator for <code>f</code>.</p><p>Alias for <code>time_derivative(f, Val(2))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/TimeDerivatives.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.AbstractTableau}" href="#Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.AbstractTableau}"><code>Gridap.Polynomials.get_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_order(tableau::AbstractTableau) -&gt; Integer</code></pre><p>Return the order of the scheme corresponding to the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.ODEOperator}" href="#Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.ODEOperator}"><code>Gridap.Polynomials.get_order</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_order(odeop::ODEOperator) -&gt; Integer</code></pre><p>Return the order of the <code>ODEOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODEOperators.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ReferenceFEs.get_nodes-Tuple{Gridap.ODEs.AbstractTableau}" href="#Gridap.ReferenceFEs.get_nodes-Tuple{Gridap.ODEs.AbstractTableau}"><code>Gridap.ReferenceFEs.get_nodes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_nodes(tableau::AbstractTableau) -&gt; AbstractVector</code></pre><p>Return the nodes of the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Gridap.ReferenceFEs.get_weights-Tuple{Gridap.ODEs.AbstractTableau}" href="#Gridap.ReferenceFEs.get_weights-Tuple{Gridap.ODEs.AbstractTableau}"><code>Gridap.ReferenceFEs.get_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_weights(tableau::AbstractTableau) -&gt; AbstractVector</code></pre><p>Return the weights of the tableau.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gridap/Gridap.jl/blob/edd8cb7b5048f968777d63e3708ce36edacf990d/src/ODEs/ODESolvers/Tableaus.jl#L77-L81">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MultiField/">« Gridap.MultiField</a><a class="docs-footer-nextpage" href="../Adaptivity/">Gridap.Adaptivity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 4 November 2024 12:15">Monday 4 November 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
