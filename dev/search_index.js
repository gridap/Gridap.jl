var documenterSearchIndex = {"docs":
[{"location":"Adaptivity/#Gridap.Adaptivity","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"CurrentModule = Gridap.Adaptivity","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The adaptivity module provides a framework to work with adapted (refined/coarsened/mixed) meshes.","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"It provides","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"A generic interface to represent adapted meshes and a set of tools to work with Finite Element spaces defined on them. In particular, moving CellFields between parent and child meshes.\nParticular implementations for conformally refining/coarsening 2D/3D meshes using several well-known strategies. In particular, Red-Green refinement and longest-edge bisection.","category":"page"},{"location":"Adaptivity/#Interface","page":"Gridap.Adaptivity","title":"Interface","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The following types are defined in the module:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"RefinementRule\nAdaptivityGlue\nAdaptedDiscreteModel\nAdaptedTriangulation","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.RefinementRule","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.RefinementRule","text":"Structure representing the map between a single parent cell and its children.\n\nContains: \n\nT :: RefinementRuleType, indicating the refinement method.\npoly :: Polytope, representing the geometry of the parent cell.\nref_grid :: DiscreteModel defined on poly, giving the parent-to-children cell map. \n\n\n\n\n\n","category":"type"},{"location":"Adaptivity/#Gridap.Adaptivity.AdaptivityGlue","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.AdaptivityGlue","text":"Glue containing the map between two nested triangulations. The contained datastructures will  depend on the type of glue. There are two types of AdaptivityGlue: \n\nRefinementGlue :: All cells in the new mesh are children of cells in the old mesh. I.e given  a new cell, it is possible to find a single old cell containing it (the new cell might be exactly the old cell if no refinement).\nMixedGlue :: Some cells in the new mesh are children of cells in the old mesh, while others are parents of cells in the old mesh. \n\nContains: \n\nn2o_faces_map :: Given a new face gid, returns\nif fine, the gid of the old face containing it.\nif coarse, the gids of its children (in child order)\nn2o_cell_to_child_id :: Given a new cell gid, returns \nif fine, the local child id within the (old) coarse cell containing it.\nif coarse, a list of local child ids of the (old) cells containing it.\nrefinement_rules :: Array conatining the RefinementRule used for each coarse cell.\n\n\n\n\n\n","category":"type"},{"location":"Adaptivity/#Gridap.Adaptivity.AdaptedDiscreteModel","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.AdaptedDiscreteModel","text":"DiscreteModel created by refining/coarsening another DiscreteModel.\n\nThe refinement/coarsening hierarchy can be traced backwards by following the   parent pointer chain. This allows the transfer of dofs   between FESpaces defined on this model and its ancestors.\n\n\n\n\n\n","category":"type"},{"location":"Adaptivity/#Gridap.Adaptivity.AdaptedTriangulation","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.AdaptedTriangulation","text":"Triangulation produced from an AdaptedDiscreteModel.\n\nContains: \n\nadapted_model :: AdaptedDiscreteModel for the triangulation.\ntrian :: Triangulation extracted from the background model, i.e get_model(adapted_model).\n\n\n\n\n\n","category":"type"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The high-level interface is provided by the following methods:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"refine\ncoarsen\nadapt","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.refine","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.refine","text":"function refine(model::DiscreteModel,args...;kwargs...) :: AdaptedDiscreteModel\n\nReturns an AdaptedDiscreteModel that is the result of refining the given DiscreteModel.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.coarsen","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.coarsen","text":"function coarsen(model::DiscreteModel,args...;kwargs...) :: AdaptedDiscreteModel\n\nReturns an AdaptedDiscreteModel that is the result of coarsening the given DiscreteModel.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.adapt","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.adapt","text":"function adapt(model::DiscreteModel,args...;kwargs...) :: AdaptedDiscreteModel\n\nReturns an AdaptedDiscreteModel that is the result of adapting (mixed coarsening and refining)   the given DiscreteModel.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Edge-Based-refinement","page":"Gridap.Adaptivity","title":"Edge-Based refinement","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The module provides a refine method for UnstructuredDiscreteModel. The method takes a string refinement_method that determines the refinement strategy to be used. The following strategies are available:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"\"red_green\" :: Red-Green refinement, default.\n\"nvb\" :: Longest-edge bisection (only for meshes of TRIangles)\n\"barycentric\" :: Barycentric refinement (only for meshes of TRIangles)\n\"simplexify\" :: Simplexify refinement. Same resulting mesh as the simplexify method, but keeps track of the parent-child relationships.","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"Additionally, the method takes a kwarg cells_to_refine that determines which cells will be refined. Possible input types are:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"Nothing :: All cells get refined.\nAbstractArray{<:Bool} of size num_cells(model) :: Only cells such that cells_to_refine[iC] == true get refined.\nAbstractArray{<:Integer} :: Cells for which gid âˆˆ cells_to_refine get refined","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The algorithms try to respect the cells_to_refine input as much as possible, but some additional cells might get refined in order to guarantee that the mesh remains conforming.","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"  function refine(model::UnstructuredDiscreteModel;refinement_method=\"red_green\",kwargs...)\n    [...]\n  end","category":"page"},{"location":"Adaptivity/#CartesianDiscreteModel-refining","page":"Gridap.Adaptivity","title":"CartesianDiscreteModel refining","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The module provides a refine method for CartesianDiscreteModel. The method takes a Tuple of size Dc (the dimension of the model cells) that will determine how many times cells will be refined in each direction. For example, for a 2D model, refine(model,(2,3)) will refine each QUAD cell into a 2x3 grid of cells.","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"  function refine(model::CartesianDiscreteModel{Dc}, cell_partition::Tuple) where Dc\n    [...]\n  end","category":"page"},{"location":"Adaptivity/#Macro-Finite-Elements","page":"Gridap.Adaptivity","title":"Macro Finite-Elements","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The module also provides support for macro finite-elements. From an abstract point of view, a macro finite-element is a finite-element defined on a refined polytope, where polynomial basis are defined on each of the subcells (creating a broken piece-wise polynomial space on the original polytope). From Gridap's point of view, a macro finite-element is a ReferenceFE defined on a RefinementRule from an array of ReferenceFEs defined on the subcells.","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"Although there are countless combinations, here are two possible applications:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"Linearized High-Order Lagrangian FESpaces: These are spaces which have the same DoFs as a high-order Lagrangian space, but where the basis functions are linear on each subcell.\nBarycentrically-refined elements for Stokes-like problems: These are spaces where the basis functions for velocity are defined on the barycentrically-refined mesh, whereas the basis functions for pressure are defined on the original cells. This allows for exact so-called Stokes sequences (see here).","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The API is given by the following methods:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"  MacroReferenceFE","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.MacroReferenceFE","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.MacroReferenceFE","text":"MacroReferenceFE(rrule::RefinementRule,reffes::AbstractVector{<:ReferenceFE})\n\nConstructs a ReferenceFE for a macro-element, given a RefinementRule and a set of ReferenceFEs for the subcells.\n\nFor performance, these should be paired with CompositeQuadratures.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Notes-for-users","page":"Gridap.Adaptivity","title":"Notes for users","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"Most of the tools provided by this module are showcased in the tests of the module itself, as well as the following tutorial (coming soon).","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"However, we want to stress a couple of key performance-critical points:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The refining/coarsening routines are not optimized for performance. In particular, they are not parallelized. If you require an optimized/parallel implementation, please consider leveraging specialised meshing libraries. For instance, we provide an implementation of refine/coarsen using P4est in the GridapP4est.jl library.\nAlthough the toolbox allows you to evaluate CellFields defined on both fine/coarse meshes on their parent/children mesh, both directions of evaluation are not equivalent. As a user, you should always try to evaluate/integrate on the finest mesh for maximal performance. Evaluating a fine CellField on a coarse mesh relies on local tree searches, and is therefore a very expensive operation that should be avoided whenever possible.","category":"page"},{"location":"Adaptivity/#Notes-for-developers","page":"Gridap.Adaptivity","title":"Notes for developers","text":"","category":"section"},{"location":"Adaptivity/#RefinementRule-API","page":"Gridap.Adaptivity","title":"RefinementRule API","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"Given a RefinementRule, the library provides a set of methods to compute the mappings between parent (coarse) face ids and child (fine) face ids (and vice-versa).","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"The most basic information (that can directly be hardcoded in the RefinementRule for performance) are the mappings between parent face ids and child face ids. These are provided by:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"get_d_to_face_to_child_faces\nget_d_to_face_to_parent_face","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.get_d_to_face_to_child_faces","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_d_to_face_to_child_faces","text":"get_d_to_face_to_child_faces(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the child/fine faces of the  same dimension that it contains. Therefore, only fine faces at the coarse cell boundary are  listed in the returned structure.\n\nReturns: [Face dimension][Coarse Face id] -> [Fine faces]\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_d_to_face_to_parent_face","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_d_to_face_to_parent_face","text":"get_d_to_face_to_parent_face(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each fine/child face the parent/coarse face containing it. The parent face can have higher dimension. \n\nReturns the tuple (A,B) with \n\nA = [Face dimension][Fine Face id] -> [Parent Face]\nB = [Face dimension][Fine Face id] -> [Parent Face Dimension]\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"On top of these two basic mappings, a whole plethora of additional topological mappings can be computed. These first set of routines extend the ReferenceFEs API to provide information on the face-to-node mappings and permutations:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"ReferenceFEs.get_face_vertices\nReferenceFEs.get_face_coordinates\nReferenceFEs.get_vertex_permutations\nReferenceFEs.get_face_vertex_permutations","category":"page"},{"location":"Adaptivity/#Gridap.ReferenceFEs.get_face_vertices","page":"Gridap.Adaptivity","title":"Gridap.ReferenceFEs.get_face_vertices","text":"ReferenceFEs.get_face_vertices(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the ids of the child/fine vertices it contains.\n\n\n\n\n\nget_face_vertices(p::Polytope) -> Vector{Vector{Int}}\nget_face_vertices(p::Polytope,dim::Integer) -> Vector{Vector{Int}}\n\n\n\n\n\nget_face_vertices(g::GridTopology,d::Integer)\n\n\n\n\n\nget_face_vertices(g::GridTopology)\n\nDefaults to\n\ncompute_face_vertices(g)\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.ReferenceFEs.get_face_coordinates","page":"Gridap.Adaptivity","title":"Gridap.ReferenceFEs.get_face_coordinates","text":"ReferenceFEs.get_face_coordinates(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the coordinates of the child/fine vertices it contains.\n\n\n\n\n\nget_face_coordinates(p::Polytope)\nget_face_coordinates(p::Polytope,d::Integer)\n\n\n\n\n\nget_face_coordinates(g::GridTopology)\nget_face_coordinates(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.ReferenceFEs.get_vertex_permutations","page":"Gridap.Adaptivity","title":"Gridap.ReferenceFEs.get_vertex_permutations","text":"ReferenceFEs.get_vertex_permutations(rr::RefinementRule)\n\nGiven a RefinementRule, returns all possible permutations of the child/fine vertices within the cell.\n\n\n\n\n\nget_vertex_permutations(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p, returns a vector of vectors containing all admissible permutations of the polytope vertices. An admissible permutation is one such that, if the vertices of the polytope are re-labeled according to this permutation, the resulting polytope preserves the shape of the original one.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nperms = get_vertex_permutations(SEGMENT)\nprintln(perms)\n\n# output\nArray{Int,1}[[1, 2], [2, 1]]\n\n\nThe first admissible permutation for a segment is [1,2],i.e., the identity. The second one is [2,1], i.e., the first vertex is relabeled as 2 and the second vertex is relabeled as 1.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.ReferenceFEs.get_face_vertex_permutations","page":"Gridap.Adaptivity","title":"Gridap.ReferenceFEs.get_face_vertex_permutations","text":"ReferenceFEs.get_face_vertex_permutations(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the possible permutations of the child/fine vertices it contains.\n\n\n\n\n\nget_face_vertex_permutations(p::Polytope)\nget_face_vertex_permutations(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"We also provide face-to-face maps:","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"get_cface_to_num_own_ffaces\nget_cface_to_own_ffaces\nget_cface_to_ffaces\nget_cface_to_own_ffaces_to_lnodes\nget_cface_to_ffaces_to_lnodes\nget_cface_to_fface_permutations\naggregate_cface_to_own_fface_data\nget_face_subface_ldof_to_cell_ldof","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.get_cface_to_num_own_ffaces","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_cface_to_num_own_ffaces","text":"get_cface_to_num_own_ffaces(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the number of child/fine faces of all  dimensions that it owns. \n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_cface_to_own_ffaces","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_cface_to_own_ffaces","text":"get_cface_to_own_ffaces(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the child/fine faces of all  dimensions that it owns. \n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_cface_to_ffaces","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_cface_to_ffaces","text":"get_cface_to_ffaces(rr::RefinementRule)\n\nGiven a RefinementRule, returns for each parent/coarse face the child/fine faces of all  dimensions that are on it (owned and not owned).\n\nThe implementation aggregates the results of get_cface_to_own_ffaces.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_cface_to_own_ffaces_to_lnodes","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_cface_to_own_ffaces_to_lnodes","text":"get_cface_to_own_ffaces_to_lnodes(rr::RefinementRule)\n\nGiven a RefinementRule, returns\n\n[coarse face][local owned child face] -> local fine node ids\n\nwhere local refers to the local fine numbering within the coarse face.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_cface_to_ffaces_to_lnodes","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_cface_to_ffaces_to_lnodes","text":"get_cface_to_ffaces_to_lnodes(rr::RefinementRule)\n\nGiven a RefinementRule, returns\n\n[coarse face][local child face] -> local fine node ids\n\nwhere local refers to the local fine numbering within the coarse face.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_cface_to_fface_permutations","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_cface_to_fface_permutations","text":"get_cface_to_fface_permutations(rrule::RefinementRule)\nget_cface_to_own_fface_permutations(rrule::RefinementRule)\n\nGiven a RefinementRule, this function returns: \n\ncface_to_cpindex_to_ffaces : For each coarse face, for each coarse face permutation,  the permuted ids of the fine faces.\ncface_to_cpindex_to_fpindex : For each coarse face, for each coarse face permutation,  the sub-permutation of the fine faces.\n\nThe idea is the following: A permutation on a coarse face induces a 2-level permutation for  the fine faces, i.e \n\nFirst, the fine faces get shuffled amongs themselves.\nSecond, each fine face has it's orientation changed (given by a sub-permutation).\n\nFor instance, let's consider a 1D example, where a SEGMENT is refined into 2 segments: \n\n   3             4     5\nX-----X  -->  X-----X-----X \n1     2       1     3     2\n\nThen when aplying the coarse node permutation (1,2) -> (2,1),  we get the following fine face permutation: \n\nFaces (1,2,3,4,5) get mapped to (2,1,3,5,4)\nMoreover, the orientation of faces 3 and 5 is changed,  i.e we get the sub-permutation (1,1,1,2,2)\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.aggregate_cface_to_own_fface_data","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.aggregate_cface_to_own_fface_data","text":"aggregate_cface_to_own_fface_data(\n    rr::RefinementRule,\n    cface_to_own_fface_to_data :: AbstractVector{<:AbstractVector{T}}\n) where T\n\nGiven a RefinementRule, and a data structure cface_to_own_fface_to_data that contains data for each child/fine face owned by each parent/coarse face, returns a data structure cface_to_fface_to_data that contains the data for each child/fine face contained in the  closure of each parent/coarse face (i.e the fine faces are owned and not owned).\n\nThe implementation makes sure that the resulting data structure is ordered according to the fine face numbering in get_cface_to_ffaces(rrule) (which in turn is by increasing fine face id).\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_face_subface_ldof_to_cell_ldof","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_face_subface_ldof_to_cell_ldof","text":"Given a RefinementRule of dimension Dc and a Dc-Tuple fine_orders of approximation orders,  returns a map between the fine nodal dofs of order fine_orders in the reference grid and the  coarse nodal dofs of order 2â‹…fine_orders in the coarse parent cell. \n\nThe result is given for each coarse/parent face of dimension D as a list of the corresponding  fine dof lids, i.e \n\n[coarse face][coarse dof lid] -> fine dof lid\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#AdaptivityGlue-API","page":"Gridap.Adaptivity","title":"AdaptivityGlue API","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"get_n2o_reference_coordinate_map\nget_old_cell_refinement_rules\nget_new_cell_refinement_rules\nget_d_to_fface_to_cface\nn2o_reindex\no2n_reindex","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.get_n2o_reference_coordinate_map","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_n2o_reference_coordinate_map","text":"For each fine cell, returns the map Î¦ st. xcoarse = Ï•(xfine)\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_old_cell_refinement_rules","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_old_cell_refinement_rules","text":"Given a RefinementGlue, returns an array containing the refinement rules for each   cell in the old mesh. \n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_new_cell_refinement_rules","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_new_cell_refinement_rules","text":"Given a RefinementGlue, returns an array containing the refinement rules for each   cell in the new mesh. \n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.get_d_to_fface_to_cface","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.get_d_to_fface_to_cface","text":"For each child/fine face, returns the parent/coarse face containing it. The parent   face might have higher dimension. \n\nReturns two arrays: \n\n[dimension][fine face gid] -> coarse parent face gid\n[dimension][fine face gid] -> coarse parent face dimension\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.n2o_reindex","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.n2o_reindex","text":"function n2o_reindex(new_data,g::AdaptivityGlue) -> old_data\n\nReindexes a cell-wise array from the new mesh to the old mesh.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#Gridap.Adaptivity.o2n_reindex","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.o2n_reindex","text":"function o2n_reindex(old_data,g::AdaptivityGlue) -> new_data\n\nReindexes a cell-wise array from the old mesh to the new mesh.\n\n\n\n\n\n","category":"function"},{"location":"Adaptivity/#New-to-old-field-evaluations","page":"Gridap.Adaptivity","title":"New-to-old field evaluations","text":"","category":"section"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"When a cell is refined, we need to be able to evaluate the fields defined on the children cells on the parent cell. To do so, we bundle the fields defined on the children cells into a new type of Field called FineToCoarseField. When evaluated on a Point, a FineToCoarseField will select the child cell that contains the Point and evaluate the mapped point on the corresponding child field.","category":"page"},{"location":"Adaptivity/","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity","text":"FineToCoarseField\nFineToCoarseDofBasis\nFineToCoarseRefFE","category":"page"},{"location":"Adaptivity/#Gridap.Adaptivity.FineToCoarseField","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.FineToCoarseField","text":"struct FineToCoarseField <: Field\n  fine_fields :: AbstractVector{<:Field}\n  rrule       :: RefinementRule\n  id_map      :: AbstractVector{<:Integer}\nend\n\nGiven a domain and a non-overlapping refined cover, a FineToCoarseField is a Field defined in the domain and constructed by a set of fields defined on  the subparts of the covering partition. The refined cover is represented by a RefinementRule. \n\nParameters:\n\nrrule: Refinement rule representing the covering partition.\nfine_fields: Fields defined on the subcells of the covering partition. To accomodate the                case where not all subcells are present (e.g in distributed), we allow for                 length(fine_fields) != num_subcells(rrule).\nid_map: Mapping from the subcell ids to the indices of the fine_fields array.            If length(fine_fields) == num_subcells(rrule), this is the identity map.            Otherwise, the id_map is used to map the subcell ids to the indices of the            fine_fields array.\n\n\n\n\n\n","category":"type"},{"location":"Adaptivity/#Gridap.Adaptivity.FineToCoarseDofBasis","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.FineToCoarseDofBasis","text":"\n\n\n\n","category":"type"},{"location":"Adaptivity/#Gridap.Adaptivity.FineToCoarseRefFE","page":"Gridap.Adaptivity","title":"Gridap.Adaptivity.FineToCoarseRefFE","text":"Wrapper for a ReferenceFE which is specialised for    efficiently evaluating FineToCoarseFields. \n\n\n\n\n\n","category":"type"},{"location":"MultiField/","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"CurrentModule = Gridap.MultiField","category":"page"},{"location":"MultiField/#Gridap.MultiField","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"","category":"section"},{"location":"MultiField/","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"Modules = [MultiField,]","category":"page"},{"location":"MultiField/#Gridap.MultiField","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"The exported names are\n\nBlockMultiFieldStyle\nConsecutiveMultiFieldStyle\nMultiFieldCellField\nMultiFieldFEFunction\nMultiFieldFESpace\nMultiFieldStyle\ncompute_field_offsets\ninterpolate\ninterpolate_dirichlet\ninterpolate_everywhere\nnum_fields\nrestrict_to_field\n\n\n\n\n\n","category":"module"},{"location":"MultiField/#Gridap.MultiField.BlockMultiFieldStyle","page":"Gridap.MultiField","title":"Gridap.MultiField.BlockMultiFieldStyle","text":"Similar to ConsecutiveMultiFieldStyle, but we keep the original DoF ids of the   individual spaces for better block assembly (see BlockSparseMatrixAssembler).   Takes three parameters: \n\nNB: Number of assembly blocks\nSB: Size of each assembly block, as a Tuple.\nP : Permutation of the variables of the multifield space when assembling, as a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.ConsecutiveMultiFieldStyle","page":"Gridap.MultiField","title":"Gridap.MultiField.ConsecutiveMultiFieldStyle","text":"The DoF ids of the collective space are the concatenation of the DoF ids of the   individual spaces.\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFEFunction","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFEFunction","text":"struct MultiFieldFEFunction <: CellField\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFESpace","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFESpace","text":"struct MultiFieldFESpace{S<:MultiFieldStyle,B} <: FESpace\n  spaces::Vector{<:SingleFieldFESpace}\n  multi_field_style::S\n  constraint_style::Val{B}\nend\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFESpace-Tuple{Vector{<:Gridap.FESpaces.SingleFieldFESpace}}","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFESpace","text":"MultiFieldFESpace(spaces::Vector{<:SingleFieldFESpace})\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.StridedMultiFieldStyle","page":"Gridap.MultiField","title":"Gridap.MultiField.StridedMultiFieldStyle","text":"Not implemented yet. \n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.FESpaces.interpolate-Tuple{Any, MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate","text":"The resulting MultiFieldFEFunction is in the space (in particular it fulfills Dirichlet BCs even in the case that the given cell field does not fulfill them)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate_dirichlet-Tuple{Any, MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate_dirichlet","text":"\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate_everywhere-Tuple{Any, MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate_everywhere","text":"like interpolate, but also compute new degrees of freedom for the dirichlet component. The resulting MultiFieldFEFunction does not necessary belongs to the underlying space\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.compute_field_offsets-Tuple{MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.compute_field_offsets","text":"compute_field_offsets(f::MultiFieldFESpace)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.num_fields-Tuple{Gridap.MultiField.MultiFieldFEFunction}","page":"Gridap.MultiField","title":"Gridap.MultiField.num_fields","text":"num_fields(m::MultiFieldFEFunction)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.num_fields-Tuple{MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.num_fields","text":"num_fields(f::MultiFieldFESpace)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.restrict_to_field-Tuple{MultiFieldFESpace, AbstractVector, Integer}","page":"Gridap.MultiField","title":"Gridap.MultiField.restrict_to_field","text":"restrict_to_field(f::MultiFieldFESpace,free_values::AbstractVector,field::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"CurrentModule = Gridap.ODEs","category":"page"},{"location":"ODEs/#Gridap.ODEs","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We consider an initial value problem written in the form","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"leftbeginarrayrcllboldsymbolr(t partial_t^0 boldsymbolu ldots partial_t^n boldsymbolu) = boldsymbol0_d  partial_t^k boldsymbolu(t_0) = boldsymbolu_0^k  0 leq k leq n-1endarrayright","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolu mathbbR to mathbbR^d is the unknown of the problem,\nn in mathbbN is the order of the ODE,\nt_0 in mathbbR is the initial time and boldsymbolu_0^k_0 leq k leq n-1 in (mathbbR^d)^n-1 are the initial conditions, and\nboldsymbolr mathbbR times (mathbbR^d)^n to mathbbR^d is the residual.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We illustrate these notations on the semi-discretisation of the heat equation. It is a first-order ODE so we have n = 1, and d is the number of degrees of freedom. The residual and initial condition have the formboldsymbolr(t boldsymbolu dotboldsymbolu) doteq boldsymbolM dotboldsymbolu + boldsymbolK(t) boldsymbolu - boldsymbolf(t) qquad boldsymbolu(t_0) = boldsymbolu_0^0where boldsymbolM in mathbbR^d times d is the mass matrix, boldsymbolK mathbbR to mathbbR^d times d is the stiffness matrix, boldsymbolf mathbbR to mathbbR^d is the forcing term, and boldsymbolu_0^0 is the initial condition.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Suppose that we are willing to approximate boldsymbolu at a time t_F  t_0. A numerical scheme splits the time interval t_0 t_F into smaller intervals t_n t_n+1 (that do not have to be of equal length) and propagates the information at time t_n to time t_n+1. More formally, we consider a general framework consisting of a starting, an update, and a finishing map defined as follows","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The starting map mathcalI (mathbbR^d)^n to (mathbbR^d)^s converts the initial conditions into s state vectors, where s geq n.\nThe marching map mathcalU mathbbR times (mathbbR^d)^s to (mathbbR^d)^s updates the state vectors from time t_n to time t_n+1.\nThe finishing map mathcalF mathbbR times (mathbbR^d)^s to mathbbR^d converts the state vectors into the evaluation of boldsymbolu at the current time.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"In the simplest case, the time step h = h_n = t_n+1 - t_n is prescribed and constant across all iterations. The state vectors are simply the initial conditions, i.e. s = n and mathcalI = mathrmid, and assuming that the initial conditions are given by increasing order of time derivative, mathcalF returns its first input.Some schemes need nontrivial starting and finishing maps. (See the generalised-alpha schemes below.) When higher-order derivatives can be retrieved from the state vectors, it is also possible to take another definition for mathcalF so that it returns the evaluation of boldsymbolu and higher-order derivatives at the current time.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"These three maps need to be designed such that the following recurrence produces approximations of boldsymbolu at the times of interest t_n","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"leftbeginarraylcl\nleftboldsymbolsright_n+1 = mathcalU(h_n leftboldsymbolsright_n) \nleftboldsymbolsright_0 = mathcalI(boldsymbolu_0^0 ldots boldsymbolu_0^n-1)\nendarrayright qquad boldsymbolu_n = mathcalF(leftboldsymbolsright_n)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"More precisely, we would like boldsymbolu_n to be close to boldsymbolu(t_n). Here the notation boldsymbols_n stands for the state vector, i.e. a vector of s vectors: boldsymbols_n = (boldsymbols_n i)_1 leq i leq s. In particular, we notice that we need the exactness condition","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"mathcalF circ mathcalI(boldsymbolu_0^0 ldots boldsymbolu_0^n-1) = boldsymbolu_0","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This is a condition on the design of the pair (mathcalI, mathcalF).","category":"page"},{"location":"ODEs/#Classification-of-ODEs-and-numerical-schemes","page":"Gridap.ODEs","title":"Classification of ODEs and numerical schemes","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Essentially, a numerical scheme converts a (continuous) ODE into (discrete) nonlinear systems of equations. These systems of equations can be linear under special conditions on the nature of the ODE and the numerical scheme. Since numerical methods for linear and nonlinear systems of equations can be quite different in terms of cost and implementation, we are interested in solving linear systems whenever possible. This leads us to perform the following classifications.","category":"page"},{"location":"ODEs/#Classification-of-ODEs","page":"Gridap.ODEs","title":"Classification of ODEs","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We define a few nonlinearity types based on the expression of the residual.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Nonlinear. Nothing special can be said about the residual.\nQuasilinear. The residual is linear with respect to the highest-order time derivative and the corresponding linear form may depend on time and lower-order time derivatives, i.e.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolr(t partial_t^0 boldsymbolu ldots partial_t^n boldsymbolu) = boldsymbolM(t partial_t^0 boldsymbolu ldots partial_t^n-1 boldsymbolu) partial_t^n boldsymbolu + boldsymbolf(t partial_t^0 boldsymbolu ldots partial_t^n-1 boldsymbolu)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We call the matrix boldsymbolM mathbbR to mathbbR^d times d the mass matrix. In particular, a quasilinear ODE is a nonlinear ODE.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Semilinear. The residual is quasilinear and the mass matrix may only depend on time, i.e.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolr(t partial_t^0 boldsymbolu ldots partial_t^n boldsymbolu) = boldsymbolM(t) partial_t^n boldsymbolu + boldsymbolf(t partial_t^0 boldsymbolu ldots partial_t^n-1 boldsymbolu)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"In particular, a semilinear ODE is a quasilinear ODE.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Linear. The residual is linear with respect to all time derivatives, i.e.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolr(t partial_t^0 boldsymbolu ldots partial_t^n boldsymbolu) = sum_0 leq k leq n boldsymbolA_k(t) partial_t^k boldsymbolu - boldsymbolf(t)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We refer to the matrix boldsymbolA_k mathbbR to mathbbR^d times d as the k-th linear form of the residual. We may still define the mass matrix boldsymbolM = boldsymbolA_n. Note that the term independent of u, i.e. the forcing term, is subtracted from the residual. This aligns with standard conventions, and in particular with those of AffineFEOperator (see example in Finite element operators below, in the construction of a TransientLinearFEOperator). In particular, a linear ODE is a semilinear ODE.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Note that for residuals of order zero (i.e. \"standard\" systems of equations), the definitions of quasilinear, semilinear, and linear coincide.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We consider an extra ODE type that is motivated by stiff problems. We say that an ODE has an implicit-explicit (IMEX) decomposition if it be can written as the sum of a residual of order n and another residual of order n-1, i.e.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolr(t partial_t^0 boldsymbolu ldots partial_t^n boldsymbolu) = boldsymbolr_textimplicit(t partial_t^0 boldsymbolu ldots partial_t^n boldsymbolu) + boldsymbolr_textexplicit(t partial_t^0 boldsymbolu ldots partial_t^n-1 boldsymbolu)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The decomposition takes the form above so that the mass matrix of the global residual is fully contained in the implicit part. The table below indicates the type of the corresponding global ODE.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Explicit \\ Implicit Nonlinear Quasilinear Semilinear Linear\nNonlinear Nonlinear Quasilinear Semilinear Semilinear\nLinear Nonlinear Quasilinear Semilinear Linear","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"In particular, for the global residual to be linear, both the implicit and explicit parts need to be linear too.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"In the special case where the implicit part is linear and the explicit part is quasilinear or semilinear, we could, in theory, identify two linear forms for the global residual. However, introducing this difference would call for an order-dependent classification of ODEs and this would create (infinitely) many new types. Since numerical schemes can rarely take advantage of this extra structure in practice, we still say that the global residual is semilinear in these cases.","category":"page"},{"location":"ODEs/#Classification-of-numerical-schemes","page":"Gridap.ODEs","title":"Classification of numerical schemes","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We introduce a classification of numerical schemes based on where they evaluate the residual during the state update.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"If it is possible (up to a change of variables) to write the system of equations for the state update as evaluations of the residual at known values (that depend on the solution at the current time) for all but the highest-order derivative, we say that the scheme is explicit.\nOtherwise, we say that the scheme is implicit.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For example, when solving a first-order ODE, the state update would involve solving one or more equations of the type boldsymbolr(t_k boldsymbolu_k(boldsymbolx) boldsymbolv_k(boldsymbolx)) = boldsymbol0where boldsymbolx and the unknown of the state update. The scheme is explicit if it is possible to introduce a change of variables such that boldsymbolu_k does not depend on boldsymbolx. Otherwise, it is implicit.","category":"page"},{"location":"ODEs/#Classification-of-systems-of-equations","page":"Gridap.ODEs","title":"Classification of systems of equations","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"It is advantageous to introduce this classification of ODE and numerical schemes because the system of equations arising from the discretisation of the ODE by a numerical scheme will be linear or nonlinear depending on whether the scheme is explicit, implicit, or implicit-explicit, and on the type of the ODE. More precisely, we have the following table.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":" Nonlinear Quasilinear Semilinear Linear\nExplicit Nonlinear Linear Linear Linear\nImplicit Nonlinear Nonlinear Nonlinear Linear","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"When the system is linear, another important practical consideration is whether the matrix of the system is constant across iterations or not. This is important because a linear solver typically performs a factorisation of the matrix, and this operation may only be performed once if the matrix is constant.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"If the linear system comes from an explicit scheme, the matrix of the system is constant if the mass matrix is. This means that the ODE has to be quasilinear.\nIf the linear system comes from an implicit scheme, all the linear forms must be constant for the system to have a constant matrix.","category":"page"},{"location":"ODEs/#Reuse-across-iterations","page":"Gridap.ODEs","title":"Reuse across iterations","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For performance reasons, it is thus important that the ODE be described in the most specific way. In particular, we consider that the mass term of a quasilinear ODE is not constant, because if it is, the ODE is semilinear. We enable the user to specify the following constant annotations:","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For nonlinear and quasilinear ODE, no quantity can be described as constant.\nFor a semilinear ODE, whether the mass term is constant.\nFor a linear ODE, whether all the linear forms are constant.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"If a linear form is constant, regardless of whether the numerical scheme relies on a linear or nonlinear system, it is always possible to compute the jacobian of the residual with respect to the corresponding time derivative only once and retrieve it in subsequent computations of the jacobian.","category":"page"},{"location":"ODEs/#High-level-API-in-Gridap","page":"Gridap.ODEs","title":"High-level API in Gridap","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The ODE module of Gridap relies on the following structure.","category":"page"},{"location":"ODEs/#Finite-element-spaces","page":"Gridap.ODEs","title":"Finite element spaces","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The time-dependent counterpart of TrialFESpace is TransientTrialFESpace. It is built from a standard TestFESpace and is equipped with time-dependent Dirichlet boundary conditions.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"By definition, test spaces have zero Dirichlet boundary conditions so they need not be seen as time-dependent objects.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"A TransientTrialFESpace can be evaluated at any time derivative order, and the corresponding Dirichlet values are the time derivatives of the Dirichlet boundary conditions.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For example, the following creates a transient FESpace and evaluates its first two time derivatives.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"g(t) = x -> x[1] + x[2] * t\nV = FESpace(model, reffe, dirichlet_tags=\"boundary\")\nU = TransientTrialFESpace (V, g)\n\nt0 = 0.0\nU0 = U(t0)\n\nâˆ‚tU = âˆ‚t(U)\nâˆ‚tU0 = âˆ‚tU(t0)\n\nâˆ‚ttU = âˆ‚tt(U) # or âˆ‚ttU = âˆ‚t(âˆ‚t(U))\nâˆ‚ttU0 = âˆ‚ttU(t0)","category":"page"},{"location":"ODEs/#Cell-fields","page":"Gridap.ODEs","title":"Cell fields","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The time-dependent equivalent of CellField is TransientCellField. It stores the cell field itself together with its derivatives up to the order of the ODE.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For example, the following creates a TransientCellField with two time derivatives.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"u0 = zero(get_free_dof_values(U0))\nâˆ‚tu0 = zero(get_free_dof_values(âˆ‚tU0))\nâˆ‚ttu0 = zero(get_free_dof_values(âˆ‚ttU0))\nu = TransientCellField(u0, (âˆ‚tu0, âˆ‚ttu0))","category":"page"},{"location":"ODEs/#Finite-element-operators","page":"Gridap.ODEs","title":"Finite element operators","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The time-dependent analog of FEOperator is TransientFEOperator. It has the following constructors based on the nonlinearity type of the underlying ODE.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"TransientFEOperator(res, jacs, trial, test) and TransientFEOperator(res, trial, test; order) for the version with automatic jacobians. The residual is expected to have the signature residual(t, u, v).\nTransientQuasilinearFEOperator(mass, res, jacs, trial, test) and TransientQuasilinearFEOperator(mass, res, trial, test; order) for the version with automatic jacobians. The mass and residual are expected to have the signatures mass(t, u, dtNu, v) and residual(t, u, v), i.e. the mass is written as a linear form of the highest-order time derivative dtNu. In this setting, the mass matrix is supposed to depend on lower-order time derivatives, so u is provided for the nonlinearity of the mass matrix.\nTransientSemilinearFEOperator(mass, res, jacs, trial, test; constant_mass) and TransientSemilinearFEOperator(mass, res, trial, test; order, constant_mass) for the version with automatic jacobians. (The jacobian with respect to partial_t^n boldsymbolu is simply the mass term). The mass and residual are expected to have the signatures mass(t, dtNu, v) and residual(t, u, v), where here again dtNu is the highest-order derivative. In particular, the mass is specified as a linear form of dtNu.\nTransientLinearFEOperator(forms, res, jacs, trial, test; constant_forms) and TransientLinearFEOperator(forms, res, trial, test; constant_forms) for the version with automatic jacobians. (In fact, the jacobians are simply the forms themselves). The forms and residual are expected to have the signatures form_k(t, dtku, v) and residual(t, v), i.e. form_k is a linear form of the k-th order derivative, and the residual does not depend on u.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"It is important to note that all the terms are gathered in the residual, including the forcing term. In the common case where the ODE is linear, the residual is only the forcing term, and it is subtracted from the bilinear forms (see example below).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Here, in the signature of the residual, t is the time at which the residual is evaluated, u is a function in the trial space, and v is a test function. Time derivatives of u can be included in the residual via the âˆ‚t operator, applied as many times as needed, or using the shortcut âˆ‚t(u, N).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Let us take the heat equation as an example. The original ODE is","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"partial_t u - nabla cdot (kappa(t) nabla u) = f(t)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where kappa is the (time-dependent) thermal conductivity and f is the forcing term. We readily obtain the weak form","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"int_Omega v partial_t u(t) + nabla v cdot (kappa(t) nabla u(t))  mathrmd Omega = int_Omega v f(t)  mathrmd Omega","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"It could be described as follows.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"As a TransientFEOperator:","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"res(t, u, v) = âˆ«( v â‹… âˆ‚t(u) + âˆ‡(v) â‹… (Îº(t) â‹… âˆ‡(u)) - v â‹… f(t) ) dÎ©\nTransientFEOperator(res, U, V)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"As a TransientQuasilinearFEOperator:","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"mass(t, u, dtNu, v) = âˆ«( v â‹… dtNu ) dÎ©\nres(t, u, v) = âˆ«( âˆ‡(v) â‹… (Îº(t) â‹… âˆ‡(u)) - v â‹… f(t) ) dÎ©\nTransientQuasilinearFEOperator(mass, res, U, V)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"As a TransientSemilinearFEOperator:","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"mass(t, dtu, v) = âˆ«( v â‹… dtu ) dÎ©\nres(t, u, v) = âˆ«( âˆ‡(v) â‹… (Îº(t) â‹… âˆ‡(u)) - v â‹… f(t) ) dÎ©\nTransientSemilinearFEOperator(mass, res, U, V, constant_mass=true)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"As a TransientLinearFEOperator:","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"stiffness(t, u, v) = âˆ«( âˆ‡(v) â‹… (Îº(t) â‹… âˆ‡(u)) ) dÎ©\nmass(t, dtu, v) = âˆ«( v â‹… dtu ) dÎ©\nres(t, u, v) = âˆ«( v â‹… f(t) ) dÎ©\nTransientLinearFEOperator((stiffness, mass), res, U, V, constant_forms=(false, true))","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"If kappa is constant, the keyword constant_forms could be replaced by (true, true).","category":"page"},{"location":"ODEs/#The-TimeSpaceFunction-constructor","page":"Gridap.ODEs","title":"The TimeSpaceFunction constructor","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Apply differential operators on a function that depends on time and space is somewhat cumbersome. Let f be a function of time and space, and g(t) = x -> f(t, x) (as in the prescription of the boundary conditions g above). Applying the operator partial_t - Delta  to g and evaluating at (t x) is written âˆ‚t(g)(t)(x) - Î”(g(t))(x).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The constructor TimeSpaceFunction allows for simpler notations: let h = TimeSpaceFunction(g). The object h is a functor that supports the notations ","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"op(h): a TimeSpaceFunction representing both t -> x -> op(f)(t, x) and (t, x) -> op(f)(t, x),\nop(h)(t): a function of space representing x -> op(f)(t, x)\nop(h)(t, x): the quantity op(f)(t, x) (this notation is equivalent to op(h)(t)(x)),","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"for all spatial and temporal differential operator, i.e. op in (time_derivative, gradient, symmetric_gradient, divergence, curl, laplacian) and their symbolic aliases (âˆ‚t, âˆ‚tt, âˆ‡, ...). The operator above applied to h and evaluated at (t, x) can be conveniently written âˆ‚t(h)(t, x) - Î”(h)(t, x).","category":"page"},{"location":"ODEs/#Solver-and-solution","page":"Gridap.ODEs","title":"Solver and solution","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The next step is to choose an ODE solver (see below for a full list) and specify the boundary conditions. The solution can then be iterated over until the final time is reached.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For example, to use the theta-method with a nonlinear solver, one could write","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"t0 = 0.0\ntF = 1.0\ndt = 0.1\nuh0 = interpolate_everywhere(t0, U(t0))\n\nres(t, u, v) = âˆ«( v â‹… âˆ‚t(u) + âˆ‡(v) â‹… (Îº(t) â‹… âˆ‡(u)) - v â‹… f(t) ) dÎ©\njac(t, u, du, v) = âˆ«( âˆ‡(v) â‹… (Îº(t) â‹… âˆ‡(du)) ) dÎ©\njac_t(t, u, dtu, v) = âˆ«( v â‹… dtu ) dÎ©\ntfeop = TransientFEOperator(res, (jac, jac_t), U, V)\n\nls = LUSolver()\nnls = NLSolver(ls, show_trace=true, method=:newton, iterations=10)\nodeslvr = ThetaMethod(nls, dt, 0.5)\n\nsol = solve(odeslvr, tfeop, t0, tF, uh0)\nfor (tn, un) in enumerate(sol)\n    # ...\nend","category":"page"},{"location":"ODEs/#Low-level-implementation","page":"Gridap.ODEs","title":"Low-level implementation","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We now briefly describe the low-level implementation of the ODE module in Gridap.","category":"page"},{"location":"ODEs/#ODE-operators","page":"Gridap.ODEs","title":"ODE operators","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The ODEOperator type represents an ODE according to the description above. It implements the NonlinearOperator interface, which enables the computation of residuals and jacobians.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The algebraic equivalent of TransientFEOperator is an ODEOpFromTFEOp, which is a subtype of ODEOperator. Conceptually, ODEOpFromTFEOp can be thought of as an assembled TransientFEOperator, i.e. it deals with vectors of degrees of freedom. This operator comes with a cache (ODEOpFromTFEOpCache) that stores the transient space, its evaluation at the current time step, a cache for the TransientFEOperator itself (if any), and the constant forms (if any).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For now TransientFEOperator does not implement the FEOperator interface, i.e. it is not possible to evaluate residuals and jacobians directly on it. Rather, they are meant to be evaluated on the ODEOpFromFEOp. This is to cut down on the number of conversions between a TransientCellField and its vectors of degrees of freedom (one per time derivative). Indeed, when linear forms are constant, no conversion is needed as the jacobian matrix will be stored.","category":"page"},{"location":"ODEs/#ODE-solvers","page":"Gridap.ODEs","title":"ODE solvers","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"An ODE solver has to implement the following interface.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"allocate_odecache(odeslvr, odeop, t0, us0). This function allocates a cache that can be reused across the three functions ode_start, ode_march!, and ode_finish!. In particular, it is necessary to call allocate_odeopcache within this function, so as to instantiate the ODEOpFromTFEOpCache and be able to update the Dirichlet boundary conditions in the subsequent functions.\node_start(odeslvr, odeop, t0, us0, odecache). This function creates the state vectors from the initial conditions. By default, this is the identity.\node_march!(stateF, odeslvr, odeop, t0, state0, odecache). This is the update map that evolves the state vectors.\node_finish!(uF, odeslvr, odeop, t0, tF, stateF, odecache). This function converts the state vectors into the evaluation of the solution at the current time step. By default, this copies the first state vector into uF.","category":"page"},{"location":"ODEs/#Stage-operator","page":"Gridap.ODEs","title":"Stage operator","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"A StageOperator represents the linear or nonlinear operator that a numerical scheme relies on to evolve the state vector. It is essentially a special kind of NonlinearOperator but it overwrites the behaviour of nonlinear and linear solvers to take advantage of the matrix of a linear system being constant. The following subtypes of StageOperator are the building blocks of all numerical schemes.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"LinearStageOperator represents the system boldsymbolJ boldsymbolx + boldsymbolr = boldsymbol0, and can build boldsymbolJ and boldsymbolr by evaluating the residual at a given point.\nNonlinearStageOperator represents boldsymbolr(boldsymbolt boldsymbolell_0(boldsymbolx) ldots boldsymbolell_N(boldsymbolx)) = boldsymbol0, where it is assumed that all the boldsymbolell_k(boldsymbolx) are linear in boldsymbolx.","category":"page"},{"location":"ODEs/#ODE-solution","page":"Gridap.ODEs","title":"ODE solution","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This type is a simple wrapper around an ODEOperator, an ODESolver, and initial conditions that can be iterated on to evolve the ODE.","category":"page"},{"location":"ODEs/#Numerical-schemes-formulation-and-implementation","page":"Gridap.ODEs","title":"Numerical schemes formulation and implementation","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We conclude this note by describing some numerical schemes and their implementation in Gridap.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Suppose that the scheme has been evolved up to time t_n already and that the state vectors boldsymbols_n are known. We are willing to evolve the ODE up to time t_n+1  t_n, i.e. compute the state vectors boldsymbols_n+1. Generally speaking, a numerical scheme constructs an approximation of the map boldsymbols_n to boldsymbols_n+1 by solving one or more relationships of the type","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolr(t_i Delta_i^0(boldsymbols_n boldsymbols_n+1) ldots Delta_i^n(boldsymbols_n boldsymbols_n+1)) = boldsymbol0","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where t_i is an intermediate time and Delta_i^k are discrete operators that approximates the k-th order time derivative of boldsymbolu at time t_i.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We now describe the numerical schemes implemented in Gridap using this framework. It is usually convenient to perform a change of variables so that the unknown boldsymbolx has the dimension of the highest-order time derivative of boldsymbolu, i.e. boldsymbolx = t^-n boldsymbolu (where bullet stands for \"the dimension of bullet\"). We always perform such a change of variable in practice.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We also briefly characterise these schemes in terms of their order and linear stability.","category":"page"},{"location":"ODEs/#\\theta-method","page":"Gridap.ODEs","title":"theta-method","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This scheme is used to solve first-order ODEs and relies on the simple state vector boldsymbols(t) = boldsymbolu(t). This means that the starting and finishing procedures are simply the identity.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The theta-method relies on the following approximation","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolu(t_n+1) = boldsymbolu(t_n) + int_t_n^t_n+1 partial_t boldsymbolu(t)  mathrmd t approx boldsymbolu(t_n) + h_n partial_t boldsymbolu(t_n + theta)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where we have introduced the intermediate time t_n + theta doteq (1 - theta) t_n + theta t_n+1. By replacing boldsymbolu(t_n) and boldsymbolu(t_n+1) by their discrete equivalents, we have partial_t boldsymbolu(t_n + theta) approx frac1h (boldsymbolu_n+1 - boldsymbolu_n). This quantity is found by enforcing that the residual is zero at t_n + theta. In that sense, the theta-method can be framed as a collocation method at t_n + theta. For that purpose, we use the same quadrature rule as above to approximate boldsymbolu(t_n + theta), i.e. boldsymbolu(t_n + theta) approx boldsymbolu_n + theta h_n partial_t boldsymbolu(t_n + theta). Using the notations of the framework above, we have defined","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\nt_1 = (1 - theta) t_n + theta t_n+1 \nDelta_1^0 = (1 - theta) boldsymbolu_n + theta boldsymbolu_n+1 \nDelta_1^1 = frac1h (boldsymbolu_n+1 - boldsymbolu_n)\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"To summarize and to be more concrete, let boldsymbolx = frac1h (boldsymbolu_n+1 - boldsymbolu_n). The theta-method solves the following stage operator","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolr(t_n + theta h_n boldsymbolu_n + theta h_n boldsymbolx boldsymbolx) = boldsymbol0","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"and sets boldsymbolu_n+1 = boldsymbolu_n + h_n boldsymbolx. The output state is simply boldsymbols_n+1 = boldsymbolu_n+1.","category":"page"},{"location":"ODEs/#Analysis","page":"Gridap.ODEs","title":"Analysis","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Since this scheme uses boldsymbolu(t) as its only state vector, the amplification matrix has dimension one, and its coefficient is the stabilisation function, given by","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"rho(z) = frac1 + (1 - theta) z1 - theta z","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We plug the Taylor expansion of boldsymbolu_n+1 around boldsymbolu_n in boldsymbolu_n+1 = rho(z) boldsymbolu_n and obtain the exactness condition rho(z) - exp(z) = 0. We then seek to match as many coefficients in the Taylor expansion of both sides to obtain order conditions. We readily obtain the following expansion","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"rho(z) - exp(z) = sum_k geq 0 lefttheta^k - frac1(k+1)right z^k+1","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The order conditions are as follows.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Order 0 and 1. The first two coefficients are always zero, so the method has at least order one.\nOrder 2. The third coefficient is theta - frac12, and it is zero when theta = frac12. This value of theta corresponds to a second-order scheme. The next coefficient is theta^2 - frac16, so this method cannot reach order three.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"By looking at the behaviour of the stability function at infinity, we find that the scheme is L-stable only when theta = 1. We determine whether the scheme is A-stable or not by looking at stability region. We distinguish three cases based on the value of theta.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"theta  frac12. The stability region is the circle of radius frac11 - 2 theta centered at left(frac-11 - 2 theta 0right). In particular, it is not A-stable. The special case theta = 0 is known as the Forward Euler scheme, which is the only explicit scheme of the theta-method family.\ntheta = frac12. The stability region is the whole left complex plane, so the scheme is A-stable. This case is known as the implicit midpoint scheme. \ntheta  frac12. The stability region is the whole complex plane except the circle of radius frac12 theta - 1 centered at left(frac12 theta - 1 0right). In particular, the scheme is A-stable. The special case theta = 1 is known as the Backward Euler scheme. ","category":"page"},{"location":"ODEs/#Generalised-\\alpha-scheme-for-first-order-ODEs","page":"Gridap.ODEs","title":"Generalised-alpha scheme for first-order ODEs","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This scheme relies on the state vector boldsymbols(t) = boldsymbolu(t) partial_t boldsymbolu(t). In particular, it needs a nontrivial starting procedure that evaluates partial_t boldsymbolu(t_0) by enforcing a zero residual at t_0. The finaliser can still return the first vector of the state vectors. For convenience, let partial_t boldsymbolu_n denote the approximation partial_t boldsymbolu(t_n).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Alternatively, the initial velocity can be provided manually: when calling solve(odeslvr, tfeop, t0, tF, uhs0), set uhs0 = (u0, v0, a0) instead of uhs0 = (u0, v0). This is useful when enforcing a zero initial residual would lead to a singular system.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This method extends the theta-method by considering the two-point quadrature rule","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolu(t_n+1) = boldsymbolu_n + int_t_n^t_n+1 partial_t boldsymbolu(t)  mathrmd t approx boldsymbolu_n + h_n (1 - gamma) partial_t boldsymbolu(t_n) + gamma partial_t boldsymbolu(t_n+1)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where 0 leq gamma leq 1 is a free parameter. The question is now how to estimate partial_t boldsymbolu(t_n+1). This is achieved by enforcing a zero residual at t_n + alpha_F doteq (1 - alpha_F) t_n + alpha_F t_n+1, where 0 leq alpha_F leq 1 is another free parameter. The value of boldsymbolu at that time, boldsymbolu_n + alpha_F, is obtained by the same linear combination of boldsymbolu at t_n and t_n+1. Regarding partial_t boldsymbolu, it is taken as a linear combination weighted by another free parameter 0  alpha_M leq 1 of the time derivative at times t_n and t_n+1. Note that alpha_M cannot be zero. Altogether, we have defined the discrete operators","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\nt_1 = (1 - alpha_F) t_n +  alpha_F t_n+1 \nDelta_1^0 = (1 - alpha_F) boldsymbolu_n + alpha_F boldsymbolu_n+1 \nDelta_1^1 = (1 - alpha_M) partial_t boldsymbolu_n + alpha_M partial_t boldsymbolu_n+1\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"In more concrete terms, we solve the following system:","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\nboldsymbol0 = boldsymbolr(t_n + alpha_F boldsymbolu_n + alpha_F partial_t boldsymbolu_n + alpha_M) \nt_n + alpha_F = (1 - alpha_F) t_n + alpha_F t_n+1 \nboldsymbolu_n + alpha_F = (1 - alpha_F) boldsymbolu_n + alpha_F boldsymbolu_n+1 \npartial_t boldsymbolu_n + alpha_M = (1 - alpha_M) partial_t boldsymbolu_n + alpha_M partial_t boldsymbolu_n+1 \nboldsymbolu_n+1 = boldsymbolu_n + h_n (1 - gamma) partial_t boldsymbolu_n + gamma boldsymbolx \npartial_t boldsymbolu_n+1 = boldsymbolx\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The state vector is updated to boldsymbols_n+1 = boldsymbolu_n+1 partial_t boldsymbolu_n+1.","category":"page"},{"location":"ODEs/#Analysis-2","page":"Gridap.ODEs","title":"Analysis","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The amplification matrix for the state vector is","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolA(z) = frac1alpha_M - alpha_F gamma z beginbmatrixalpha_M + (1 - alpha_F) gamma z  alpha_M - gamma  z  alpha_M - 1 + alpha_F (1 - gamma) zendbmatrix","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"It is then immediate to see that boldsymbolu_n+1 = mathrmtr(boldsymbolA) boldsymbolu_n - det(boldsymbolA) boldsymbolu_n-1. This time, plugging the Taylor expansion of boldsymbolu_n+1 and boldsymbolu_n-1 around boldsymbolu_n in this expression, the exactness condition is mathrmtr(boldsymbolA(z)) - det(boldsymbolA(z)) exp(-z) - exp(z) = 0. To simplify the analysis, we write the trace and determinant of boldsymbolA as follows","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"mathrmtr(boldsymbolA(z)) = a + fracb1 - c z qquad det(boldsymbolA(z)) = d + frace1 - c z","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\na = 2 - frac1alpha_F - frac1gamma \nb = frac1alpha_F + frac1gamma - frac1alpha_M \nc = fracalpha_F gammaalpha_M \nd = frac(1 - alpha_F) (1 - gamma)alpha_F gamma \ne = fracalpha_M (alpha_F + gamma - 1) - alpha_F gammaalpha_F alpha_M gamma\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Next, we obtain the Taylor expansion of the exactness condition and find","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"(a + b - d - e - 1) + sum_k geq 1 left(b c^k - frac1k - frac(-1)^kk d - sum_0 leq l leq k e c^(k - l)frac(-1)^llright) z^k = 0","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The order conditions are as follows.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Order 0 and 1. The first two coefficients are always zero, so the method is at least of order 2.\nOrder 2. The third coefficient has a zero at gamma = frac12 + alpha_M - alpha_F.\nOrder 3. The fourth coefficient has a zero at alpha_M = frac1 + 6 alpha_F - 12 alpha_F^26(1 - 2 alpha_F) (provided that alpha_F neq frac12). In that case we simplify gamma into gamma = frac2 - 3 alpha_F3(1 - 2 alpha_F).\nOrder 4. The fifth coefficient has zeros at alpha_F = frac3 pm sqrt36 and poles at alpha_F = frac3 pm sqrt2112. The corresponding values of alpha_M and gamma are alpha_M = frac12, gamma = frac3 mp sqrt36.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We finally study the stability in the extreme cases z to 0 and z to +infty. We want the spectral radius of the amplification matrix to be smaller than one so that perturbations are damped away.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"When z to 0, we have rho(boldsymbolA(z)) to max1 left1 - frac1alpha_Mright.\nWhen z to +infty, we have rho(boldsymbolA(z)) to maxleft1 - frac1alpha_Fright left1 - frac1gammaright.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We thus require alpha_M geq frac12, alpha_F geq frac12 and gamma geq frac12 to ensure stability. In particular when the scheme has order 3, the stability conditions become alpha_M geq alpha_F geq frac12. We verify that the scheme is unstable whenever it has an order greater than 3. We notice that L-stability is only achieved when alpha_F = 1 and gamma = 1. The corresponding value of alpha_M for a third-order scheme is alpha_M = frac32.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This scheme was originally devised to control the damping of high frequencies. One parameterisation consists in prescribing the eigenvalues at z to +infty, and this leads to","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"alpha_F = gamma = frac11 + rho_infty qquad alpha_M = frac3 - rho_infty2 (1 + rho_infty)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where rho_infty is the spectral radius at infinity. Setting rho_infty cuts all the highest frequencies in one step, whereas taking rho_infty = 1 preserves high frequencies.","category":"page"},{"location":"ODEs/#Runge-Kutta","page":"Gridap.ODEs","title":"Runge-Kutta","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Runge-Kutta methods are multi-stage, i.e. they build estimates of boldsymbolu at intermediate times between t_n and t_n+1. They can be written as follows","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\nboldsymbol0 = boldsymbolr(t_n + c_i h_n  boldsymbolu_n + sum_1 leq j leq s a_ij h_n boldsymbolx_j boldsymbolx_i)  1 leq i leq p \nboldsymbolu_n+1 = boldsymbolu_n + sum_1 leq i leq p b_i h_n boldsymbolx_i\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where p is the number of stages, boldsymbolA = (a_ij)_1 leq i j leq p is a matrix of free parameters, boldsymbolb = (b_i)_1 leq i leq p and boldsymbolc = (c_i)_1 leq i leq p are two vectors of free parameters. The stage unknowns (boldsymbolx_i)_1 leq i leq p are involved in a coupled system of equations. This system can take a simpler form when the matrix boldsymbolA has a particular structure.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"When boldsymbolA is lower triangular, the equations are decoupled and can thus be solved sequentially. These schemes are called Diagonally-Implicit Runge-Kutta (DIRK). If the diagonal coefficients of the matrix boldsymbolA are the same, the method is called Singly-Diagonally Implicit (SDIRK).\nIf the diagonal coefficients are also zero, the method is explicit. These schemes are called Explicit Runge-Kutta (EXRK).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Implementation details It is particularly advantageous to save the factorisation of the matrices of the stage operators for Runge-Kutta methods. This is always possible when the method is explicit and the mass matrix is constant, in which case all the stage matrices are the mass matrix. When the method is diagonally-implicit and the stiffness and mass matrices are constant, the matrices of the stage operators are boldsymbolM + a_ii h_n boldsymbolK. In particular, if two diagonal coefficients coincide, the corresponding operators will have the same matrix. We implement these reuse strategies by storing them in CompressedArrays, and introducing a map i -> NumericalSetup.","category":"page"},{"location":"ODEs/#Analysis-3","page":"Gridap.ODEs","title":"Analysis","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The stability function of a Runge-Kutta scheme is","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"rho(z) = 1 + z boldsymbolb^T (boldsymbolI - z boldsymbolA)^-1 boldsymbol1","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The analysis of Runge-Kutta methods is well-established but we only derive order conditions for schemes with one, two, or three stages in the diagonally-implicit case.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"One stage. These schemes coincide with the theta-method presented above.\nTwo stages. We solve the order conditions given by the differential trees and find the following families of tableaus of orders two and three","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"defarraystretch15\nbeginarrayccc\nalpha  alpha  \nbeta  beta - hatbeta  hatbeta  hline\n frac2 beta - 12 (beta - alpha)  frac1 - 2 alpha2 (beta - alpha)\nendarray qquad\nbeginarrayccc\nfrac12 - fracsqrt36 frac1lambda  frac12 - fracsqrt36 frac1lambda  \nfrac12 + fracsqrt36 lambda  fracsqrt33 lambda  frac12 - fracsqrt36 lambda  hline\n fraclambda^2lambda^2 + 1  frac1lambda^2 + 1\nendarray","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Three stages. We only solve the explicit schemes in full generality. We find three families of order three","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"defarraystretch15\nbeginarrayccc\n0  \nalpha  alpha  \nbeta  beta - fracbeta (beta - alpha)alpha (2 - 3alpha)  fracbeta (beta - alpha) alpha(2 - 3 alpha)  hline\n 1 - frac3 (beta + alpha) - 26 alpha beta  frac3 beta - 26 alpha (beta - alpha)  frac2 - 3 alpha6 beta (beta - alpha)\nendarray qquad\nbeginarrayccc\n0  \nfrac23  frac23  \nfrac23  frac23 - frac14 alpha  frac14 alpha  hline\n frac14  frac34 - alpha  alpha\nendarray qquad\nbeginarrayccc\n0  \nfrac23  frac23  \n0  -frac14 alpha  frac14 alpha  hline\n frac14 - alpha  frac34  alpha\nendarray","category":"page"},{"location":"ODEs/#Implicit-Explicit-Runge-Kutta","page":"Gridap.ODEs","title":"Implicit-Explicit Runge-Kutta","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"When the residual has an implicit-explicit decomposition, usually because we can identify a stiff part that we want to solve implicitly and a nonstiff part that we want to solve explicitly, the Runge-Kutta method reads as follows","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\nboldsymbol0 = boldsymbolr(t_n + c_i h_n boldsymbolu_n + sum_1 leq j leq i-1 (a_i j h_n boldsymbolx_j + hata_i j h_n hatboldsymbolx_j) + a_i i h_n boldsymbolx_i boldsymbolx_i) \nboldsymbol0 = hatboldsymbolr(t_n + c_i h_n boldsymbolu_n + sum_1 leq j leq i-1 (a_i j h_n boldsymbolx_j + hata_i j h_n hatboldsymbolx_j) + a_i i h_n boldsymbolx_i hatboldsymbolx_i)  1 leq i leq p \nboldsymbolu_n+1 = boldsymbolu_n + sum_1 leq i leq p (b_i h_n boldsymbolx_i + hatb_i h_n hatboldsymbolx_i)\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"In these expressions, quantities that wear a hat are the explicit counterparts of the implicit quantity with the same name. The implicit and explicit stages are alternated, i.e. the implicit and explicit stage unknowns boldsymbolx_i and hatboldsymbolx_i are solved alternatively. As seen above, we require that the nodes c_i of the implicit and explicit tableaus coincide. This implies that the first step for the implicit part is actually explicit.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Implementation details Many methods can be created by padding a DIRK tableau with zeros to give it an additional step. In this case, the first stage for the implicit part does not need to be solved, as all linear combinations give it a zero weight. As an example, an L-stable, 2-stage, second-order SDIRK IMEX scheme is given by","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"defarraystretch15\nbeginarraycccc\n0  0   \nfrac2 - sqrt22  0  frac2 - sqrt22  \n1  0  fracsqrt22  frac2 - sqrt22  hline\n  0  fracsqrt22  frac2 - sqrt22\nendarray qquad\nbeginarraycccc\n0    \nfrac2 - sqrt22  frac2 - sqrt22   \n1  -fracsqrt22  1 + fracsqrt22   hline\n  -fracsqrt22  1 + fracsqrt22 \nendarray","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"We note that the first column of the matrix and the first weight are all zero, so the first stage for the implicit part does not need to be solved.","category":"page"},{"location":"ODEs/#Generalised-\\alpha-scheme-for-second-order-ODEs","page":"Gridap.ODEs","title":"Generalised-alpha scheme for second-order ODEs","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This scheme relies on the state vector boldsymbols(t) = boldsymbolu(t) partial_t boldsymbolu(t) partial_tt boldsymbolu(t). It needs a nontrivial starting procedure that evaluates partial_tt boldsymbolu(t_0) by enforcing a zero residual at t_0. The finaliser can still return the first vector of the state vectors. For convenience, let partial_tt boldsymbolu_n denote the approximation partial_tt boldsymbolu(t_n).","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The initial acceleration can alternatively be provided manually: when calling solve(odeslvr, tfeop, t0, tF, uhs0), set uhs0 = (u0, v0, a0) instead of uhs0 = (u0, v0). This is useful when enforcing a zero initial residual would lead to a singular system.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This method is built out of the following update rule","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"beginalign*\nboldsymbol0 = boldsymbolr(t_n + 1 - alpha_F boldsymbolu_n + 1 - alpha_F partial_t boldsymbolu_n + 1 - alpha_F partial_tt boldsymbolu_n + 1 - alpha_M) \nt_n + 1 - alpha_F = alpha_F t_n + (1 - alpha_F) t_n+1 \nboldsymbolu_n + 1 - alpha_F = alpha_F boldsymbolu_n + (1 - alpha_F) boldsymbolu_n+1 \npartial_t boldsymbolu_n + 1 - alpha_F = alpha_F partial_t boldsymbolu_n + (1 - alpha_F) partial_t boldsymbolu_n+1 \npartial_tt boldsymbolu_n + 1 - alpha_M = alpha_M partial_tt boldsymbolu_n + (1 - alpha_M) partial_tt boldsymbolu_n+1 \nboldsymbolu_n+1 = boldsymbolu_n + h_n partial_t boldsymbolu_n + frac12 h_n^2 (1 - 2 beta) partial_tt boldsymbolu_n + 2 beta boldsymbolx \npartial_t boldsymbolu_n+1 = partial_t boldsymbolu_n + h_n (1 - gamma) partial_tt boldsymbolu_n + gamma boldsymbolx \npartial_tt boldsymbolu_n+1 = boldsymbolx\nendalign*","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The state vector is then updated to boldsymbols_n+1 = boldsymbolu_n+1 partial_t boldsymbolu_n+1 partial_tt boldsymbolu_n+1.","category":"page"},{"location":"ODEs/#Analysis-4","page":"Gridap.ODEs","title":"Analysis","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The amplification matrix for the state vector is","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolA(z) = frac1overlinealpha_M + overlinealpha_F beta z^2 beginbmatrix\noverlinealpha_M - alpha_F beta z^2  overlinealpha_M  overlinebeta overlinealpha_M - beta alpha_M \n-gamma z^2  overlinealpha_M + overlinealpha_F (beta - gamma) z^2  overlinealpha_M  overlinegamma - alpha_M gamma + overlinealpha_F overlinegamma beta - overlinebeta gamma z^2 \n-z^2  -overlinealpha_F z^2  -alpha_M - overlinealpha_F overlinebeta z^2\nendbmatrix","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"where overlinealpha_M = 1 - alpha_M, overlinealpha_F = 1 - alpha_F, overlinegamma = 1 - gamma and overlinebeta = frac12(1 - 2 beta). Here again, we immediately see that boldsymbolu_n+1 satisfies the recurrence","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"boldsymbolu_n+1 = mathrmtr(boldsymbolA(z)) boldsymbolu_n - frac12 (mathrmtr(boldsymbolA(z))^2 - mathrmtr(boldsymbolA(z)^2)) boldsymbolu_n-1 + det(boldsymbolA(z)) boldsymbolu_n-2","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"By plugging the Taylor expansion of boldsymbolu at times t_n+1, t_n-1 and t_n-2, we obtain the exactness condition","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"cos(z) = mathrmtr(boldsymbolA(z)) - frac12 (mathrmtr(boldsymbolA(z))^2 - mathrmtr(boldsymbolA(z)^2)) cos(z) + det(boldsymbolA(z)) cos(2z)","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"These conditions are hard to examine analytically, but one can verify that this scheme is at least of order 1. Second-order is achieved by setting gamma = frac12 - alpha_M + alpha_F.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"It is easier to consider the limit cases z to 0 and z to +infty and look at the eigenvalues of the amplification matrix.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"When z to 0, we find rho(boldsymbolA(z)) = maxleft1 leftfracalpha_M1 - alpha_Mrightright.\nWhen z to +infty, we find rho(boldsymbolA(z)) = maxleftleftfracalpha_F1 - alpha_Fright leftfrac4 beta - (1 + 2 gamma) pm sqrt(1 + 2 gamma)^2 - 16 beta4 betarightright.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"For all these eigenvalues to have a modulus smaller than one, we need alpha_M leq frac12, alpha_F leq frac12, gamma geq frac12, i.e. alpha_F geq alpha_M and beta geq frac12 gamma. Since dissipation of high-frequency is maximised when the eigenvalues are real at infinity, we also impose beta = frac116 (1 + 2 gamma)^2, i.e. beta = frac14 (1 - alpha_M + alpha_F)^2.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"This method was also designed to damp high-frequency perturbations so it is common practice to parameter this scheme in terms of its spectral radius.","category":"page"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The Hilbert-Huges-Taylor-alpha (HHT-alpha) method is obtained by setting alpha_M = 0, alpha_F = frac1 - rho_infty1 + rho_infty.\nThe Wood-Bossak-Zienkiewicz-alpha (WBZ-alpha) method is recovered by setting alpha_F = 0 and alpha_M = fracrho_infty - 1rho_infty + 1.\nThe standard generalised-alpha method is obtained by setting alpha_M = frac2 rho_infty - 1rho_infty + 1, alpha_F = fracrho_inftyrho_infty + 1.\nThe Newmark method corresponds to alpha_F = alpha_M = 0. In this case, the values of beta and gamma are usually chosen as beta = 0, gamma = frac12 (explicit central difference scheme), or beta = frac14 and gamma = frac12 (midpoint rule).","category":"page"},{"location":"ODEs/#Reference","page":"Gridap.ODEs","title":"Reference","text":"","category":"section"},{"location":"ODEs/","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"Modules = [ODEs,]","category":"page"},{"location":"ODEs/#Gridap.ODEs","page":"Gridap.ODEs","title":"Gridap.ODEs","text":"The exported names are\n\nAbstractLinearODE\nAbstractQuasilinearODE\nAbstractSemilinearODE\nAbstractTableau\nBackwardEuler\nButcherTableau\nDiagonallyImplicitTableau\nEmbeddedTableau\nExplicitTableau\nForwardEuler\nFullyImplicitTableau\nGeneralizedAlpha1\nGeneralizedAlpha2\nGenericIMEXODEOperator\nGenericODESolution\nGenericTableau\nGenericTransientIMEXFEOperator\nIMEXODEOperator\nIMEXTableau\nImplicitExplicitTableau\nImplicitTableau\nLinearODE\nLinearStageOperator\nMidPoint\nNewmark\nNonlinearODE\nNonlinearStageOperator\nODEOpFromTFEOp\nODEOpFromTFEOpCache\nODEOperator\nODEOperatorType\nODESolution\nODESolver\nQuasilinearODE\nRungeKutta\nSemilinearODE\nStageOperator\nTableauName\nTableauType\nThetaMethod\nTimeSpaceFunction\nTransientCellField\nTransientFEBasis\nTransientFEOpFromWeakForm\nTransientFEOperator\nTransientFESolution\nTransientIMEXFEOperator\nTransientLinearFEOpFromWeakForm\nTransientLinearFEOperator\nTransientMultiFieldCellField\nTransientMultiFieldFESpace\nTransientQuasilinearFEOpFromWeakForm\nTransientQuasilinearFEOperator\nTransientSemilinearFEOpFromWeakForm\nTransientSemilinearFEOperator\nTransientSingleFieldCellField\nTransientTrialFESpace\nallocate_odecache\nallocate_odeopcache\nallocate_space\nallocate_tfeopcache\navailable_imex_tableaus\navailable_tableaus\nget_assembler\nget_embedded_order\nget_embedded_weights\nget_forms\nget_imex_operators\nget_imex_tableaus\nget_jacs\nget_num_forms\nget_res\nis_form_constant\nis_padded\njacobian_add!\nmassless_residual_weights\node_finish!\node_march!\node_start\ntest_ode_operator\ntest_ode_solution\ntest_ode_solver\ntest_tfe_operator\ntest_tfe_solution\ntest_tfe_solver\ntest_tfe_space\ntime_derivative\nupdate_odeopcache!\nupdate_tfeopcache!\nâˆ‚t\nâˆ‚tt\n\n\n\n\n\n","category":"module"},{"location":"ODEs/#Gridap.ODEs.AbstractLinearODE","page":"Gridap.ODEs","title":"Gridap.ODEs.AbstractLinearODE","text":"abstract type AbstractLinearODE <: AbstractSemilinearODE end\n\nODE operator whose residual is linear with respect to all time derivatives, i.e.\n\nresidual(t, âˆ‚t^0[u], ..., âˆ‚t^N[u]) = âˆ‘_{0 â‰¤ k â‰¤ N} A_k(t) âˆ‚t^k[u] - res(t),\n\nwhere N is the order of the ODE operator, and âˆ‚t^k[u] is the k-th-order time derivative of u.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.AbstractQuasilinearODE","page":"Gridap.ODEs","title":"Gridap.ODEs.AbstractQuasilinearODE","text":"abstract type AbstractQuasilinearODE <: ODEOperatorType end\n\nODE operator whose residual is linear with respect to the highest-order time derivative, i.e.\n\nresidual(t, âˆ‚t^0[u], ..., âˆ‚t^N[u]) = mass(t, âˆ‚t^0[u], ..., âˆ‚t^(N-1)[u]) âˆ‚t^N[u]\n                                   +  res(t, âˆ‚t^0[u], ..., âˆ‚t^(N-1)[u]),\n\nwhere N is the order of the ODE operator, âˆ‚t^k[u] is the k-th-order time derivative of u, and both mass and res have order N-1.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.AbstractSemilinearODE","page":"Gridap.ODEs","title":"Gridap.ODEs.AbstractSemilinearODE","text":"abstract type AbstractSemilinearODE <: AbstractQuasilinearODE end\n\nODE operator whose residual is linear with respect to the highest-order time derivative, and whose mass matrix only depend on time, i.e.\n\nresidual(t, âˆ‚t^0[u], ..., âˆ‚t^N[u]) = mass(t) âˆ‚t^N[u]\n                                   +  res(t, âˆ‚t^0[u], ..., âˆ‚t^(N-1)[u]),\n\nwhere N is the order of the ODE operator, âˆ‚t^k[u] is the k-th-order time derivative of u, mass is independent of u and res has order N-1.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.AbstractTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.AbstractTableau","text":"abstract type AbstractTableau{T} <: GridapType end\n\nType that stores the Butcher tableau corresponding to a Runge-Kutta scheme.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIMRungeKutta","page":"Gridap.ODEs","title":"Gridap.ODEs.DIMRungeKutta","text":"struct DIMRungeKutta <: ODESolver end\n\nDiagonally-implicit Runge-Kutta ODE solver.\n\nresidual(tx, ux, vx) = 0,\n\ntx = t_n + c[i] * dt\nux = u_n + dt * âˆ‘_{1 â‰¤ j < i} A[i, j] * slopes[j] + dt * A[i, i] * x\nvx = x,\n\nu_(n+1) = u_n + dt * âˆ‘_{1 â‰¤ i â‰¤ s} b[i] * slopes[i].\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_CrankNicolson_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_CrankNicolson_2_2","text":"DIRK_CrankNicolson_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_LobattoIIIA_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_LobattoIIIA_2_2","text":"DIRK_LobattoIIIA_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_LobattoIIIC_3_4","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_LobattoIIIC_3_4","text":"DIRK_LobattoIIIC_3_4\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_RadauII_2_3","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_RadauII_2_3","text":"DIRK_RadauII_2_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_RadauI_2_3","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_RadauI_2_3","text":"DIRK_RadauI_2_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_TRBDF_3_2","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_TRBDF_3_2","text":"DIRK_TRBDF_3_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DIRK_TRX_3_2","page":"Gridap.ODEs","title":"Gridap.ODEs.DIRK_TRX_3_2","text":"DIRK_TRX_3_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.DiagonallyImplicitTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.DiagonallyImplicitTableau","text":"struct DiagonallyImplicitTableau <: ImplicitTableau end\n\nTableau whose matrix is lower triangular, with at least one nonzero diagonal coefficient.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_BogackiShampine_4_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_BogackiShampine_4_3","text":"EXRK_BogackiShampine_4_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Euler_1_1","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Euler_1_1","text":"EXRK_Euler_1_1\nFE\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Fehlberg_3_2","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Fehlberg_3_2","text":"EXRK_Fehlberg_3_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Heun_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Heun_3_3","text":"EXRK_Heun_3_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Kutta_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Kutta_3_3","text":"EXRK_Kutta_3_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Midpoint_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Midpoint_2_2","text":"EXRK_Midpoint_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Ralston_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Ralston_2_2","text":"EXRK_Ralston_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Ralston_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Ralston_3_3","text":"EXRK_Ralston_3_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Ralston_4_4","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Ralston_4_4","text":"EXRK_Ralston_4_4\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_RungeKutta_4_4","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_RungeKutta_4_4","text":"EXRK_RungeKutta_4_4\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_SSP_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_SSP_2_2","text":"EXRK_SSP_2_2\nEXRK_Heun_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_SSP_3_2","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_SSP_3_2","text":"EXRK_SSP_3_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_SSP_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_SSP_3_3","text":"EXRK_SSP_3_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_SSP_4_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_SSP_4_3","text":"EXRK_SSP_4_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Simpson_4_4","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Simpson_4_4","text":"EXRK_Simpson_4_4\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRK_Wray_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRK_Wray_3_3","text":"EXRK_Wray_3_3\nEXRK_VanDerHouwen_3_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EXRungeKutta","page":"Gridap.ODEs","title":"Gridap.ODEs.EXRungeKutta","text":"struct EXRungeKutta <: ODESolver end\n\nExplicit Runge-Kutta ODE solver.\n\nresidual(tx, ux, vx) = 0,\n\ntx = t_n + c[i] * dt\nux = u_n + âˆ‘_{1 â‰¤ j < i} A[i, j] * dt * slopes[j]\nvx = x\nslopes[i] = x,\n\nu_(n+1) = u_n + âˆ‘_{1 â‰¤ i â‰¤ s} b[i] * dt * slopes[i].\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.EmbeddedTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.EmbeddedTableau","text":"struct EmbeddedTableau <: AbstractTableau end\n\nGeneric type that stores any type of embedded Butcher tableau.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ExplicitTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.ExplicitTableau","text":"struct ExplicitTableau <: TableauType end\n\nTableau whose matrix is strictly lower triangular.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ForwardEuler","page":"Gridap.ODEs","title":"Gridap.ODEs.ForwardEuler","text":"struct ForwardEuler <: ODESolver end\n\nForward Euler ODE solver.\n\nresidual(tx, ux, vx) = 0,\n\ntx = t_n\nux = u_n\nvx = x,\n\nu_(n+1) = u_n + dt * x.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.FullyImplicitTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.FullyImplicitTableau","text":"struct FullyImplicitTableau <: ImplicitTableau end\n\nTableau whose matrix has at least one nonzero coefficient in its strict upper triangular part.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.GeneralizedAlpha1","page":"Gridap.ODEs","title":"Gridap.ODEs.GeneralizedAlpha1","text":"struct GeneralizedAlpha1 <: ODESolver\n\nGeneralized-Î± first-order ODE solver.\n\nresidual(tx, ux, vx) = 0,\n\ntx = (1 - Î±f) * t_n + Î±f * t_(n+1)\nux = (1 - Î±f) * u_n + Î±f * u_(n+1)\nvx = (1 - Î±m) * v_n + Î±m * v_(n+1),\n\nu_(n+1) = u_n + dt * ((1 - Î³) * v_n + Î³ * x)\nv_(n+1) = x.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.GeneralizedAlpha2","page":"Gridap.ODEs","title":"Gridap.ODEs.GeneralizedAlpha2","text":"struct GeneralizedAlpha2 <: ODESolver\n\nGeneralized-Î± second-order ODE solver.\n\nresidual(tx, ux, vx, ax) = 0,\n\ntx = Î±f * t_n + (1 - Î±f) * t_(n+1)\nux = Î±f * u_n + (1 - Î±f) * u_(n+1)\nvx = Î±f * v_n + (1 - Î±f) * v_(n+1)\nax = Î±m * a_n + (1 - Î±m) * a_(n+1),\n\nu_(n+1) = u_n + dt * v_n + dt^2 / 2 * ((1 - 2 * Î²) * a_n + 2 * Î² * x)\nv_(n+1) = v_n + dt * ((1 - Î³) * a_n + Î³ * x)\na_(n+1) = x.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.GenericIMEXODEOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.GenericIMEXODEOperator","text":"struct GenericIMEXODEOperator <: IMEXODEOperator end\n\nGeneric IMEXODEOperator.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.GenericODESolution","page":"Gridap.ODEs","title":"Gridap.ODEs.GenericODESolution","text":"struct GenericODESolution <: ODESolution end\n\nGeneric wrapper for the evolution of an ODEOperator with an ODESolver.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.GenericTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.GenericTableau","text":"struct GenericTableau <: AbstractTableau end\n\nGeneric type that stores any type of Butcher tableau.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.GenericTransientIMEXFEOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.GenericTransientIMEXFEOperator","text":"struct GenericTransientIMEXFEOperator <: TransientIMEXFEOperator end\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXODEOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXODEOperator","text":"abstract type IMEXODEOperator <: ODEOperator end\n\nImplicit-Explicit decomposition of a residual defining an ODEOperator:\n\nresidual(t, âˆ‚t^0[u], ..., âˆ‚t^N[u]) = implicit_residual(t, âˆ‚t^0[u], ..., âˆ‚t^N[u])\n                                   + explicit_residual(t, âˆ‚t^0[u], ..., âˆ‚t^(N-1)[u]),\n\nwhere\n\nThe implicit operator defined by the implicit residual is considered stiff and is meant to be solved implicitly,\nThe explicit operator defined by the explicit residual is considered non-stiff and is meant to be solved explicitly.\n\nImportant\n\nThe explicit operator must have one order less than the implicit operator, so that the mass term of the global operator is fully contained in the implicit operator.\n\nMandatory\n\nget_imex_operators(odeop)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_1_1_1","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_1_1_1","text":"IMEXRK_1_1_1\n\nBackward-Forward Euler pair, order 1\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_1_2_1","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_1_2_1","text":"IMEXRK_1_2_1\n\nBackward-Forward Euler pair with same weights, order 1\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_1_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_1_2_2","text":"IMEXRK_1_2_2\n\nImplicit-Explicit midpoint pair, order 2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_2_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_2_2_2","text":"IMEXRK_2_2_2\n\nL-stable, 2-stage, 2-order SDIRK\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_2_3_2","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_2_3_2","text":"IMEXRK_2_3_2\n\nL-stable, 2-stage, 2-order SDIRK\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_2_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_2_3_3","text":"IMEXRK_2_3_3\n\n2-stage, 3-order SDIRK scheme with best damping properties\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_3_4_3","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_3_4_3","text":"IMEXRK_3_4_3\n\nL-stable, 3-stage, 3-order SDIRK\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRK_4_4_3","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRK_4_4_3","text":"IMEXRK_4_4_3\n\nL-stable, 4-stage, 3-order SDIRK\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXRungeKutta","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXRungeKutta","text":"struct IMEXRungeKutta <: ODESolver\n\nImplicit-Explicit Runge-Kutta ODE solver.\n\nmass(tx, ux) vx + im_res(tx, ux) = 0,\n\ntx = t_n + c[i] * dt\nux = u_n + âˆ‘_{1 â‰¤ j < i} im_A[i, j] * dt * im_slopes[j] + im_A[i, i] * dt * x\n         + âˆ‘_{1 â‰¤ j < i} ex_A[i, j] * dt * ex_slopes[j]\nvx = x\nim_slopes[i] = x,\n\nmass(tx, ux) vx + ex_res(tx, ux) = 0,\n\ntx = t_n + c[i] * dt\nux = u_n + âˆ‘_{1 â‰¤ j â‰¤ i} im_A[i, j] * dt * im_slopes[j]\n         + âˆ‘_{1 â‰¤ j < i} ex_A[i, j] * dt * ex_slopes[j]\nvx = x\nex_slopes[i] = x,\n\nu_(n+1) = u_n + âˆ‘_{1 â‰¤ i â‰¤ s} im_b[i] * dt * im_slopes[i]\n              + âˆ‘_{1 â‰¤ i â‰¤ s} ex_b[i] * dt * ex_slopes[i].\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.IMEXTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXTableau","text":"struct IMEXTableau <: AbstractTableau end\n\nGeneric type that stores any type of implicit-explicit pair of Butcher tableaus, that form a valid IMEX scheme.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ImplicitExplicitTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.ImplicitExplicitTableau","text":"struct ImplicitExplicitTableau <: ImplicitTableau end\n\nPair of implicit and explicit tableaus that form a valid implicit-explicit scheme.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ImplicitTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.ImplicitTableau","text":"abstract type ImplicitTableau <: TableauType end\n\nTableau whose matrix has at least one nonzero coefficient outside its strict lower triangular part.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.LinearStageOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.LinearStageOperator","text":"struct LinearStageOperator <: StageOperator end\n\nLinear stage operator representing res(x) = J(t, us) x + r(t, us) = 0, where x is the stage unknown and us denotes the point where the residual of the ODE is to be evaluated.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.NonlinearStageOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.NonlinearStageOperator","text":"struct NonlinearStageOperator <: StageOperator end\n\nNonlinear stage operator representing res(x) = residual(t, us(x)...) = 0, where x is the stage unknown and us(x) denotes the point where the residual of the ODE is to be evaluated. It is assumed that the coordinates of us(x) are linear in x, and the coefficients in front of x called ws are scalar, i.e. ws[k] = d/dx us[k](x) is a scalar constant.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ODEOpFromTFEOp","page":"Gridap.ODEs","title":"Gridap.ODEs.ODEOpFromTFEOp","text":"struct ODEOpFromTFEOp <: ODEOperator end\n\nWrapper that transforms a TransientFEOperator into an ODEOperator, i.e. takes residual(t, uh, âˆ‚t[uh], ..., âˆ‚t^N[uh], vh) and returns residual(t, us), where us[k] = âˆ‚t^k[us] and uf represents the free values of uh.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ODEOpFromTFEOpCache","page":"Gridap.ODEs","title":"Gridap.ODEs.ODEOpFromTFEOpCache","text":"struct ODEOpFromTFEOpCache <: GridapType\n\nStructure that stores the TransientFESpace and cache of a TransientFEOperator, as well as the jacobian matrices and residual if they are constant.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ODEOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.ODEOperator","text":"abstract type ODEOperator <: GridapType end\n\nGeneral implicit, nonlinear ODE operator defined by a residual of the form\n\nresidual(t, âˆ‚t^0[u], ..., âˆ‚t^N[u]) = 0,\n\nwhere N is the order of the ODE operator and âˆ‚t^k[u] is the k-th-order time derivative of u.\n\nMandatory\n\nget_order(odeop)\nget_forms(odeop)\nallocate_residual(odeop, t, us, odeopcache)\nresidual!(r, odeop, t, us, odeopcache; add::Bool)\nallocate_jacobian(odeop, t, us, odeopcache)\njacobian_add!(J, odeop, t, us, ws, odeopcache)\n\nOptional\n\nget_num_forms(odeop)\nis_form_constant(odeop, k)\nallocate_odeopcache(odeop, t, us)\nupdate_odeopcache!(odeopcache, odeop, t)\nresidual(odeop, t, us, odeopcache)\njacobian!(odeop, t, us, ws, odeopcache)\njacobian(odeop, t, us, ws, odeopcache)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ODEOperatorType","page":"Gridap.ODEs","title":"Gridap.ODEs.ODEOperatorType","text":"abstract type ODEOperatorType <: GridapType end\n\nTrait that indicates the linearity type of an ODE operator.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ODEOperatorType-Union{Tuple{Gridap.ODEs.ODEOperator{T}}, Tuple{T}} where T","page":"Gridap.ODEs","title":"Gridap.ODEs.ODEOperatorType","text":"ODEOperatorType(odeop::ODEOperator) -> ODEOperatorType\n\nReturn the ODEOperatorType of the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ODEOperatorType-Union{Tuple{TransientFEOperator{T}}, Tuple{T}} where T","page":"Gridap.ODEs","title":"Gridap.ODEs.ODEOperatorType","text":"ODEOperatorType(::Type{<:TransientFEOperator}) -> ODEOperatorType\n\nReturn the ODEOperatorType of the TransientFEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ODESolution","page":"Gridap.ODEs","title":"Gridap.ODEs.ODESolution","text":"abstract type ODESolution <: GridapType end\n\nWrapper around an ODEOperator and ODESolver that represents the solution at a set of time steps. It is an iterator that computes the solution at each time step in a lazy fashion when accessing the solution.\n\nMandatory\n\niterate(odesltn)\niterate(odesltn, state)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.ODESolver","page":"Gridap.ODEs","title":"Gridap.ODEs.ODESolver","text":"abstract type ODESolver <: GridapType end\n\nAn ODESolver is a map that update state vectors. These state vectors are created at the first iteration from the initial conditions, and are then converted back into the evaluation of the solution at the current time step.\n\nIn the simplest case, the state vectors correspond to the first N-1 time derivatives of u at time t_n, where N is the order of the ODEOperator, but some solvers rely on other state variables (values at previous times,  higher-order derivatives...).\n\nMandatory\n\nallocate_odecache(odeslvr, odeop, t0, us0)\node_march!(stateF, odeslvr, odeop, t0, state0, odecache)\n\nOptional\n\node_start(odeslvr, odeop, t0, us0, odecache)\node_finish!(uF, odeslvr, odeop, t0, tF, stateF, odecache)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_2_2","text":"SDIRK_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_3_2","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_3_2","text":"SDIRK_3_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_3_3","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_3_3","text":"SDIRK_3_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_4_3","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_4_3","text":"SDIRK_4_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_Crouzeix_3_4","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_Crouzeix_3_4","text":"SDIRK_Crouzeix_3_4\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_Euler_1_1","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_Euler_1_1","text":"SDIRK_Euler_1_1\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_LobattoIIIC_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_LobattoIIIC_2_2","text":"SDIRK_LobattoIIIC_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_Midpoint_1_2","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_Midpoint_1_2","text":"SDIRK_Midpoint_1_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_Norsett_3_4","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_Norsett_3_4","text":"SDIRK_Norsett_3_4\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_QinZhang_2_2","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_QinZhang_2_2","text":"SDIRK_QinZhang_2_2\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.SDIRK_SSP_2_3","page":"Gridap.ODEs","title":"Gridap.ODEs.SDIRK_SSP_2_3","text":"SDIRK_SSP_2_3\nSDIRK_Crouzeix_2_3\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.StageOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.StageOperator","text":"abstract type StageOperator <: NonlinearOperator end\n\nOperator used to perform one stage within one time step of an ODESolver.\n\nMandatory\n\nallocate_residual(nlop, x)\nresidual!(r, nlop, x)\nallocate_jacobian(nlop, x)\njacobian!(J, nlop, x)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TableauName","page":"Gridap.ODEs","title":"Gridap.ODEs.TableauName","text":"abstract type TableauName <: GridapType end\n\nName of a Butcher tableau.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TableauType","page":"Gridap.ODEs","title":"Gridap.ODEs.TableauType","text":"abstract type TableauType <: GridapType end\n\nTrait that indicates whether a tableau is explicit, implicit or implicit-explicit.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TableauType-Union{Tuple{Gridap.ODEs.AbstractTableau{T}}, Tuple{T}} where T","page":"Gridap.ODEs","title":"Gridap.ODEs.TableauType","text":"TableauType(::AbstractTableau) -> TableauType\n\nReturn the TableauType of the tableau.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ThetaMethod","page":"Gridap.ODEs","title":"Gridap.ODEs.ThetaMethod","text":"struct ThetaMethod <: ODESolver end\n\nÎ¸-method ODE solver.\n\nresidual(tx, ux, vx) = 0,\n\ntx = t_n + Î¸ * dt\nux = u_n + Î¸ * dt * x\nvx = x,\n\nu_(n+1) = u_n + dt * x.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TimeSpaceFunction","page":"Gridap.ODEs","title":"Gridap.ODEs.TimeSpaceFunction","text":"struct TimeSpaceFunction{F} <: Function end\n\nTimeSpaceFunction allows for convenient ways to apply differential operators to functions that depend on time and space. More precisely, if f is a function that, to a given time, returns a function of space (i.e. f is evaluated at time t and position x via f(t)(x)), then F = TimeSpaceFunction(f) supports the following syntax:\n\nop(F): a TimeSpaceFunction representing both t -> x -> op(f)(t)(x) and (t, x) -> op(f)(t)(x),\nop(F)(t): a function of space representing x -> op(f)(t)(x)\nop(F)(t, x): the quantity op(f)(t)(x) (this notation is equivalent to op(F)(t)(x)),\n\nfor all spatial and temporal differential operator, i.e. op in (time_derivative, gradient, symmetric_gradient, divergence, curl, laplacian) and their symbolic aliases (âˆ‚t, âˆ‚tt, âˆ‡, ...).\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientCellField","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientCellField","text":"abstract type TransientCellField <: CellField end\n\nTransient version of CellField.\n\nMandatory\n\ntime_derivative(f)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientFEBasis","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientFEBasis","text":"struct TransientFEBasis <: FEBasis end\n\nTransient FEBasis.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientFEOpFromWeakForm","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientFEOpFromWeakForm","text":"struct TransientFEOpFromWeakForm <: TransientFEOperator end\n\nGeneric TransientFEOperator constructed from the weak formulation of a partial differential equation.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientFEOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientFEOperator","text":"abstract type TransientFEOperator <: GridapType end\n\nTransient version of FEOperator corresponding to a residual of the form\n\nresidual(t, u, v) = 0,\n\nwhere residual is linear in v. Time derivatives of u can be included by using the âˆ‚t operator.\n\nImportant\n\nFor now, the residual and jacobians cannot be directly computed on a TransientFEOperator. They have to be evaluated on the corresponding algebraic operator, which is an ODEOperator. As such, TransientFEOperator is not exactly a subtype of FEOperator, but rather at the intersection of FEOperator and ODEOperator. This is because the ODEOperator works with vectors and it is optimised to take advantage of constant forms.\n\nMandatory\n\nget_test(tfeop)\nget_trial(tfeop)\nget_order(tfeop)\nget_res(tfeop::TransientFEOperator)\nget_jacs(tfeop::TransientFEOperator)\nget_forms(tfeop::TransientFEOperator)\nget_assembler(tfeop)\n\nOptional\n\nget_algebraic_operator(tfeop)\nget_num_forms(tfeop::TransientFEOperator)\nis_form_constant(tfeop, k)\nallocate_tfeopcache(tfeop)\nupdate_tfeopcache!(tfeopcache, tfeop, t)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientFESolution","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientFESolution","text":"abstract type TransientFESolution <: GridapType end\n\nWrapper around a TransientFEOperator and ODESolver that represents the solution at a set of time steps. It is an iterator that computes the solution at each time step in a lazy fashion when accessing the solution.\n\nMandatory\n\niterate(tfesltn)\niterate(tfesltn, state)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientIMEXFEOperator","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientIMEXFEOperator","text":"abstract type TransientIMEXFEOperator <: TransientFEOperator end\n\nImplicit-Explicit decomposition of a residual defining a TransientFEOperator:\n\nresidual(t, u, v) = implicit_residual(t, u, v)\n                  + explicit_residual(t, u, v),\n\nwhere\n\nThe implicit operator defined by the implicit residual is considered stiff and is meant to be solved implicitly,\nThe explicit operator defined by the explicit residual is considered non-stiff and is meant to be solved explicitly.\nBoth the implicit and explicit residuals are linear in v.\n\nImportant\n\nThe explicit operator must have one order less than the implicit operator, so that the mass term of the global operator is fully contained in the implicit operator.\n\nMandatory\n\nget_imex_operators(tfeop)\n\nOptional\n\nget_test(tfeop)\nget_trial(tfeop)\nget_algebraic_operator(tfeop)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientLinearFEOpFromWeakForm","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientLinearFEOpFromWeakForm","text":"struct TransientLinearFEOpFromWeakForm <: TransientFEOperator end\n\nTransient FEOperator defined by a transient weak form\n\nresidual(t, u, v) = âˆ‘_{0 â‰¤ k â‰¤ N} form_k(t, âˆ‚t^k[u], v) - res(t, v) = 0,\n\nwhere N is the order of the operator, form_k is linear in âˆ‚t^k[u] and does not depend on the other time derivatives of u, and the form_k and res are linear in v.\n\nFor convenience, the form corresponding to order k has to be written as a function of âˆ‚t^k[u], i.e. as a linear form, and the residual as a function of t and v only.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientMultiFieldCellField","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientMultiFieldCellField","text":"struct TransientMultiFieldCellField <: TransientCellField end\n\nTransient CellField for a multi-field FESpace.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientQuasilinearFEOpFromWeakForm","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientQuasilinearFEOpFromWeakForm","text":"struct TransientQuasilinearFEOpFromWeakForm <: TransientFEOperator end\n\nTransient FEOperator defined by a transient weak form\n\nresidual(t, u, v) = mass(t, u, âˆ‚t^N[u], v) + res(t, u, v) = 0.\n\nLet N be the order of the operator. We impose the following conditions:\n\nmass is linear in the N-th-order time derivative of u,\nres has order N-1,\nboth mass and res are linear in v.\n\nFor convenience, the mass matrix has to be specified as a function of u for the nonlinear part, and âˆ‚t^N[u].\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientSemilinearFEOpFromWeakForm","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientSemilinearFEOpFromWeakForm","text":"struct TransientSemilinearFEOpFromWeakForm <: TransientFEOperator end\n\nTransient FEOperator defined by a transient weak form\n\nresidual(t, u, v) = mass(t, âˆ‚t^N[u], v) + res(t, u, v) = 0.\n\nLet N be the order of the operator. We impose the following conditions:\n\nmass is linear in the N-th-order time derivative of u,\nres has order N-1,\nboth mass and res are linear in v.\n\nFor convenience, the mass matrix has to be specified as a function of âˆ‚t^N[u], i.e. as a linear form.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientSingleFieldCellField","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientSingleFieldCellField","text":"struct TransientSingleFieldCellField <: TransientCellField end\n\nTransient CellField for a single-field FESpace.\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientTrialFESpace","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientTrialFESpace","text":"struct TransientTrialFESpace <: SingleFieldFESpace end\n\nTransient version of TrialFESpace: the Dirichlet boundary conditions are allowed to be time-dependent.\n\nMandatory\n\nallocate_space(space)\nevaluate!(space, t)\nevaluate(space, t)\ntime_derivative(space)\n\nOptional\n\nevaluate(space, t::Real)\n\n\n\n\n\n","category":"type"},{"location":"ODEs/#Gridap.ODEs.TransientTrialFESpace-Tuple{Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.TransientTrialFESpace","text":"(space::TransientTrialFESpace)(t) -> FESpace\n\nAlias for evaluate(space, t).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Base.iterate-Tuple{Gridap.ODEs.ODESolution, Any}","page":"Gridap.ODEs","title":"Base.iterate","text":"Base.iterate(odesltn::ODESolution) -> ((Real, AbstractVector), StateType)\n\nPerform one time step of the ODEOperator with the ODESolver attached to the ODESolution.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Base.iterate-Tuple{Gridap.ODEs.ODESolution}","page":"Gridap.ODEs","title":"Base.iterate","text":"Base.iterate(odesltn::ODESolution) -> ((Real, AbstractVector), StateType)\n\nAllocate the operators and cache and perform one time step of the ODEOperator with the ODESolver attached to the ODESolution.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Base.iterate-Tuple{Gridap.ODEs.TransientFESolution, Any}","page":"Gridap.ODEs","title":"Base.iterate","text":"Base.iterate(tfesltn::TransientFESolution) -> ((Real, FEFunction), StateType)\n\nPerform one step of the ODEOperator with the ODESolver attached to the TransientFESolution.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Base.iterate-Tuple{Gridap.ODEs.TransientFESolution}","page":"Gridap.ODEs","title":"Base.iterate","text":"Base.iterate(tfesltn::TransientFESolution) -> ((Real, FEFunction), StateType)\n\nAllocate a cache and perform one step of the ODEOperator with the ODESolver attached to the TransientFESolution.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.Algebra.allocate_jacobian","text":"allocate_jacobian(\n  odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}},\n  odeopcache\n) -> AbstractMatrix\n\nAllocate a jacobian matrix for the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.allocate_residual-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.Algebra.allocate_residual","text":"allocate_residual(\n  odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}},\n  odeopcache\n) -> AbstractVector\n\nAllocate a residual vector for the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.get_matrix-Tuple{Gridap.ODEs.AbstractTableau}","page":"Gridap.ODEs","title":"Gridap.Algebra.get_matrix","text":"get_matrix(tableau::AbstractTableau) -> AbstractMatrix\n\nReturn the matrix of the tableau.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}","page":"Gridap.ODEs","title":"Gridap.Algebra.jacobian!","text":"jacobian!(\n  J::AbstractMatrix, odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}}, ws::Tuple{Vararg{Real}},\n  odeopcache\n) -> AbstractMatrix\n\nCompute the jacobian of the residual of the ODEOperator with respect to all time derivatives, weighted by some factors ws.\n\nThe weights are ordered by increasing order of time derivative, i.e. the first weight corresponds to âˆ‚residual / âˆ‚u and the last to âˆ‚residual / âˆ‚(d^N u / dt^N).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.jacobian-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}","page":"Gridap.ODEs","title":"Gridap.Algebra.jacobian","text":"jacobian(\n  odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}}, ws::Tuple{Vararg{Real}},\n  odeopcache\n) -> AbstractMatrix\n\nAllocate a jacobian matrix for the ODEOperator and compute the jacobian of the residual of the ODEOperator with respect to all time derivatives, weighted by some factors ws.\n\nThe weights are ordered by increasing order of time derivative, i.e. the first weight corresponds to âˆ‚residual / âˆ‚u and the last to âˆ‚residual / âˆ‚(d^N u / dt^N).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.Algebra.residual!","text":"residual!(\n  r::AbstractVector, odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}},\n  odeopcache; add::Bool=false\n) -> AbstractVector\n\nCompute the residual of the ODEOperator. If add is true, this function adds to r instead of erasing it.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.residual-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.Algebra.residual","text":"residual(\n  odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}},\n  odeopcache\n) -> AbstractVector\n\nAllocate a vector and evaluate the residual of the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.solve-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}","page":"Gridap.ODEs","title":"Gridap.Algebra.solve","text":"solve(\n  odeslvr::ODESolver, odeop::ODEOperator,\n  t0::Real, tF::Real, us0::Tuple{Vararg{AbstractVector}},\n) -> ODESolution\n\nCreate an ODESolution wrapper around the ODEOperator and ODESolver, starting with state us0 at time t0, to be evolved until tF.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Algebra.solve-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{CellField}}}","page":"Gridap.ODEs","title":"Gridap.Algebra.solve","text":"solve(\n  odeslvr::ODESolver, tfeop::TransientFEOperator,\n  t0::Real, tF::Real, uhs0\n) -> TransientFESolution\n\nCreate a TransientFESolution wrapper around the TransientFEOperator and ODESolver, starting at time t0 with state us0, to be evolved until tF.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Arrays.evaluate!-Tuple{FESpace, TransientTrialFESpace, Real}","page":"Gridap.ODEs","title":"Gridap.Arrays.evaluate!","text":"evaluate!(\n  transient_space::FESpace,\n  space::TransientTrialFESpace, t::Real\n) -> FESpace\n\nReplace the Dirichlet values of the space by those at time t.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Arrays.evaluate-Tuple{TransientTrialFESpace, Nothing}","page":"Gridap.ODEs","title":"Gridap.Arrays.evaluate","text":"evaluate(space::TransientTrialFESpace, t::Nothing) -> FESpace\n\nEvaluating at nothing means that the Dirichlet values are not important.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Arrays.evaluate-Tuple{TransientTrialFESpace, Real}","page":"Gridap.ODEs","title":"Gridap.Arrays.evaluate","text":"evaluate(space::TransientTrialFESpace, t::Real) -> FESpace\n\nAllocate a transient space and evaluate the Dirichlet values at time t.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ButcherTableau","page":"Gridap.ODEs","title":"Gridap.ODEs.ButcherTableau","text":"ButcherTableau(name::TableauName, type::Type) -> AbtractTableau\n\nBuilds the Butcher tableau corresponding to a TableauName.\n\n\n\n\n\n","category":"function"},{"location":"ODEs/#Gridap.ODEs.IMEXODEOperatorType-Tuple{Type{<:Gridap.ODEs.ODEOperatorType}, Type{<:Gridap.ODEs.ODEOperatorType}}","page":"Gridap.ODEs","title":"Gridap.ODEs.IMEXODEOperatorType","text":"IMEXODEOperatorType(\n  T_im::Type{<:ODEOperatorType},\n  T_ex::Type{<:ODEOperatorType}\n) -> ODEOperatorType\n\nReturn the ODEOperatorType of the operator defined by an IMEX decomposition. This function should be called in the constructors of concrete IMEX operators.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs._to_transient_single_fields-Tuple{Any, Any}","page":"Gridap.ODEs","title":"Gridap.ODEs._to_transient_single_fields","text":"_to_transient_single_fields(\n  multi_field,\n  derivatives\n) -> Vector{<:TransientSingleFieldCellField}\n\nConvert a TransientMultiFieldCellField into a vector of TransientSingleFieldCellFields.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.allocate_odecache-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}","page":"Gridap.ODEs","title":"Gridap.ODEs.allocate_odecache","text":"allocate_odecache(\n  odeslvr::ODESolver, odeop::ODEOperator,\n  t0::Real, us0::Tuple{Vararg{AbstractVector}}\n) -> CacheType\n\nAllocate the cache of the ODESolver applied to the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.allocate_odeopcache-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}","page":"Gridap.ODEs","title":"Gridap.ODEs.allocate_odeopcache","text":"allocate_odeopcache(\n  odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}}, args...\n) -> CacheType\n\nAllocate the cache required by the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.allocate_space-Tuple{TransientTrialFESpace}","page":"Gridap.ODEs","title":"Gridap.ODEs.allocate_space","text":"allocate_space(space::TransientTrialFESpace) -> FESpace\n\nAllocate a transient space, intended to be updated at every time step.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.allocate_tfeopcache-Tuple{TransientFEOperator, Real, Tuple{Vararg{AbstractVector}}}","page":"Gridap.ODEs","title":"Gridap.ODEs.allocate_tfeopcache","text":"allocate_tfeopcache(\n  tfeop::TransientFEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}}\n) -> CacheType\n\nAllocate the cache of the TransientFEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.check_imex_compatibility-Tuple{Integer, Integer}","page":"Gridap.ODEs","title":"Gridap.ODEs.check_imex_compatibility","text":"check_imex_compatibility(im_order::Integer, ex_order::Integer) -> Bool\n\nCheck whether two operators can make a valid IMEX operator decomposition. This function should be called in the constructors of concrete IMEX operators.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_assembler-Tuple{TransientFEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_assembler","text":"get_assembler(tfeop::TransientFEOperator) -> Assembler\n\nReturn the assembler of the TransientFEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_embedded_order-Tuple{Gridap.ODEs.EmbeddedTableau}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_embedded_order","text":"get_embedded_order(tableau::EmbeddedTableau) -> Integer\n\nReturn the embedded order of the tableau.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_embedded_weights-Tuple{Gridap.ODEs.EmbeddedTableau}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_embedded_weights","text":"get_embedded_weights(tableau::EmbeddedTableau) -> AbstractVector\n\nReturn the embedded weight of the tableau.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_forms-Tuple{Gridap.ODEs.ODEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_forms","text":"get_forms(odeop::ODEOperator) -> Tuple{Vararg{Function}}\n\nReturn the linear forms of the ODEOperator:\n\nFor a general ODE operator, return an empty tuple,\nFor a quasilinear ODE operator, return a tuple with the mass matrix,\nFor a linear ODE operator, return all the linear forms.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_forms-Tuple{TransientFEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_forms","text":"get_forms(tfeop::TransientFEOperator) -> Function\n\nReturn the bilinear forms of the TransientFEOperator:\n\nFor a general transient FE operator, return nothing,\nFor a quasilinear transient FE operator, return the mass matrix,\nFor a linear transient FE operator, return all the linear forms.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_imex_operators-Tuple{Gridap.ODEs.IMEXODEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_imex_operators","text":"get_imex_operators(odeop::IMEXODEOperator) -> (ODEOperator, ODEOperator)\n\nReturn the implicit and explicit parts of the IMEXODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_imex_operators-Tuple{TransientIMEXFEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_imex_operators","text":"get_imex_operators(tfeop::TransientIMEXFEOperator) -> (TransientFEOperator, TransientFEOperator)\n\nReturn the implicit and explicit parts of the TransientIMEXFEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_jacs-Tuple{TransientFEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_jacs","text":"get_jacs(tfeop::TransientFEOperator) -> Tuple{Vararg{Function}}\n\nReturn the jacobians of the TransientFEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_num_forms-Tuple{Gridap.ODEs.ODEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_num_forms","text":"get_num_forms(odeop::ODEOperator) -> Integer\n\nReturn the number of linear forms of the ODEOperator. See get_forms\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_num_forms-Tuple{TransientFEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_num_forms","text":"get_num_forms(tfeop::TransientFEOperator) -> Integer\n\nReturn the number of bilinear forms of the TransientFEOperator. See get_forms.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.get_res-Tuple{TransientFEOperator}","page":"Gridap.ODEs","title":"Gridap.ODEs.get_res","text":"get_res(tfeop::TransientFEOperator) -> Function\n\nReturn the lowest-order element in the decomposition of the residual of the ODEOperator:\n\nIn the general case, return the whole residual,\nFor an AbstractQuasilinearODE, return the residual excluding the mass term,\nFor an AbstractLinearODE, return the forcing term.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.is_form_constant-Tuple{Gridap.ODEs.ODEOperator, Integer}","page":"Gridap.ODEs","title":"Gridap.ODEs.is_form_constant","text":"is_form_constant(odeop::ODEOperator, k::Integer) -> Bool\n\nIndicate whether the linear form of the ODEOperator corresponding to the k-th-order time derivative of u is constant with respect to t.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.is_form_constant-Tuple{TransientFEOperator, Integer}","page":"Gridap.ODEs","title":"Gridap.ODEs.is_form_constant","text":"is_form_constant(tfeop::TransientFEOperator, k::Integer) -> Bool\n\nIndicate whether the bilinear form of the TransientFEOperator corresponding to the k-th-order time derivative of u is constant with respect to t.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.jacobian_add!-Tuple{AbstractMatrix, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Tuple{Vararg{Real}}, Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.jacobian_add!","text":"jacobian_add!(\n  J::AbstractMatrix, odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}}, ws::Tuple{Vararg{Real}},\n  odeopcache\n) -> AbstractMatrix\n\nAdd the jacobian of the residual of the ODEOperator with respect to all time derivatives, weighted by some factors ws.\n\nThe weights are ordered by increasing order of time derivative, i.e. the first weight corresponds to âˆ‚residual / âˆ‚u and the last to âˆ‚residual / âˆ‚(d^N u / dt^N).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ode_finish!-Tuple{AbstractVector, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Any, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.ode_finish!","text":"ode_finish!(\n  uF::AbstractVector,\n  odeslvr::ODESolver, odeop::ODEOperator,\n  t0::Real, tF, stateF::Tuple{Vararg{AbstractVector}},\n  odecache\n) -> (AbstractVector, CacheType)\n\nConvert the state vectors into the evaluation of the solution of the ODE at the current time.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ode_march!-Tuple{Tuple{Vararg{AbstractVector}}, Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.ode_march!","text":"ode_march!(\n  stateF::Tuple{Vararg{AbstractVector}},\n  odeslvr::ODESolver, odeop::ODEOperator,\n  t0::Real, state0::Tuple{Vararg{AbstractVector}},\n  odecache\n) -> (Real, Tuple{Vararg{AbstractVector}}, CacheType)\n\nMarch the state vector for one time step.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.ode_start-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.ode_start","text":"ode_start(\n  odeslvr::ODESolver, odeop::ODEOperator,\n  t0::Real, us0::Tuple{Vararg{AbstractVector}},\n  odecache\n) -> (Tuple{Vararg{AbstractVector}}, CacheType)\n\nConvert the initial conditions into state vectors.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_ode_operator-Tuple{Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}, Vararg{Any}}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_ode_operator","text":"test_ode_operator(\n  odeop::ODEOperator,\n  t::Real, us::Tuple{Vararg{AbstractVector}}, args...\n) -> Bool\n\nTest the interface of ODEOperator specializations.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_ode_solution-Tuple{Gridap.ODEs.ODESolution}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_ode_solution","text":"test_ode_solution(odesltn::ODESolution) -> Bool\n\nTest the interface of ODESolution specializations.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_ode_solver-Tuple{Gridap.ODEs.ODESolver, Gridap.ODEs.ODEOperator, Real, Tuple{Vararg{AbstractVector}}}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_ode_solver","text":"test_ode_solver(\n  odeslvr::ODESolver, odeop::ODEOperator,\n  t0::Real, us0::Tuple{Vararg{AbstractVector}}\n) -> Bool\n\nTest the interface of ODESolver specializations.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_tfe_operator-Tuple{TransientFEOperator, Real, Gridap.ODEs.TransientCellField}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_tfe_operator","text":"test_tfe_operator(\n  tfeop::TransientFEOperator,\n  t::Real, uh::TransientCellField\n) -> Bool\n\nTest the interface of TransientFEOperator specializations.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_tfe_solution-Tuple{Gridap.ODEs.TransientFESolution}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_tfe_solution","text":"test_tfe_solution(tfesltn::TransientFESolution) -> Bool\n\nTest the interface of TransientFESolution specializations.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_tfe_solver-Tuple{Gridap.ODEs.ODESolver, TransientFEOperator, Real, Real, Tuple{Vararg{AbstractVector}}}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_tfe_solver","text":"test_tfe_solver(\n  odeslvr::ODESolver, tfeop::TransientFEOperator,\n  t0::Real, tF::Real, uhs0\n) -> Bool\n\nTest the interface of ODESolver specializations on TransientFEOperators.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.test_tfe_space-Tuple{FESpace}","page":"Gridap.ODEs","title":"Gridap.ODEs.test_tfe_space","text":"test_tfe_space(U::FESpace) -> Bool\n\nTest the transient interface of FESpace specializations.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.time_derivative-Tuple{Any, Val{0}}","page":"Gridap.ODEs","title":"Gridap.ODEs.time_derivative","text":"time_derivative(f::DerivableType, ::Val{k}) -> DerivableType\n\nBuild the k-th-order time derivative operator for f.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.time_derivative-Tuple{Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.time_derivative","text":"time_derivative(f::DerivableType) -> DerivableType\n\nBuild the first-order time derivative operator for f.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.time_derivative-Tuple{TransientTrialFESpace}","page":"Gridap.ODEs","title":"Gridap.ODEs.time_derivative","text":"time_derivative(space::TransientTrialFESpace) -> FESpace\n\nFirst-order time derivative of the Dirichlet functions.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.update_odeopcache!-Tuple{Any, Gridap.ODEs.ODEOperator, Real, Vararg{Any}}","page":"Gridap.ODEs","title":"Gridap.ODEs.update_odeopcache!","text":"update_odeopcache!(odeopcache, odeop::ODEOperator, t::Real, args...) -> CacheType\n\nUpdate the cache of the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.update_tfeopcache!-Tuple{Any, TransientFEOperator, Real}","page":"Gridap.ODEs","title":"Gridap.ODEs.update_tfeopcache!","text":"update_tfeopcache!(tfeopcache, tfeop::TransientFEOperator, t::Real) -> CacheType\n\nUpdate the cache of the TransientFEOperator at time t.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.âˆ‚t-Tuple{Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.âˆ‚t","text":"âˆ‚t(f::DerivableType) -> DerivableType\n\nBuild the first-th-order time derivative operator for f.\n\nAlias for time_derivative(f).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.âˆ‚t-Union{Tuple{k}, Tuple{Any, Val{k}}} where k","page":"Gridap.ODEs","title":"Gridap.ODEs.âˆ‚t","text":"âˆ‚t(f::DerivableType, ::Val{k}) -> DerivableType\n\nBuild the k-th-order time derivative operator for f.\n\nAlias for time_derivative(f, Val(k)).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ODEs.âˆ‚tt-Tuple{Any}","page":"Gridap.ODEs","title":"Gridap.ODEs.âˆ‚tt","text":"âˆ‚tt(f::DerivableType) -> DerivableType\n\nSecond-order time derivative operator for f.\n\nAlias for time_derivative(f, Val(2)).\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.AbstractTableau}","page":"Gridap.ODEs","title":"Gridap.Polynomials.get_order","text":"get_order(tableau::AbstractTableau) -> Integer\n\nReturn the order of the scheme corresponding to the tableau.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.Polynomials.get_order-Tuple{Gridap.ODEs.ODEOperator}","page":"Gridap.ODEs","title":"Gridap.Polynomials.get_order","text":"get_order(odeop::ODEOperator) -> Integer\n\nReturn the order of the ODEOperator.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ReferenceFEs.get_nodes-Tuple{Gridap.ODEs.AbstractTableau}","page":"Gridap.ODEs","title":"Gridap.ReferenceFEs.get_nodes","text":"get_nodes(tableau::AbstractTableau) -> AbstractVector\n\nReturn the nodes of the tableau.\n\n\n\n\n\n","category":"method"},{"location":"ODEs/#Gridap.ReferenceFEs.get_weights-Tuple{Gridap.ODEs.AbstractTableau}","page":"Gridap.ODEs","title":"Gridap.ReferenceFEs.get_weights","text":"get_weights(tableau::AbstractTableau) -> AbstractVector\n\nReturn the weights of the tableau.\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation-requirements","page":"Getting Started","title":"Installation requirements","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Gridap is tested on Linux, but it should be also possible to use it on Mac OS and Windows since it is written exclusively in Julia and it only depends on registered Julia packages.","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Gridap is a registered package. Thus, the installation should be straight forward using the Julia's package manager Pkg. To this end, open the Julia REPL (i.e., execute the julia binary), type ] to enter package mode, and install Gridap as follows","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add Gridap","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"That's all.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For further information about how to install and manage Julia packages, see the Pkg documentation.","category":"page"},{"location":"getting-started/#Further-steps","page":"Getting Started","title":"Further steps","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We recommend to follow the Gridap Tutorials in order to get familiar with the library.","category":"page"},{"location":"FESpaces/","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"CurrentModule = Gridap.FESpaces","category":"page"},{"location":"FESpaces/#Gridap.FESpaces","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"","category":"section"},{"location":"FESpaces/","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"Modules = [FESpaces,]","category":"page"},{"location":"FESpaces/#Gridap.FESpaces","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"The exported names are\n\nAffineFEOperator\nAssembler\nAssemblyStrategy\nBasisStyle\nCLagrangianFESpace\nCellConformity\nCellFE\nConstantFESpace\nConstrained\nConstraintStyle\nDefaultAssemblyStrategy\nDirichletFESpace\nDiscreteModelWithFEMap\nEvaluationFunction\nFEBasis\nFEFunction\nFEOperator\nFESolver\nFESpace\nFESpaceWithConstantFixed\nFESpaceWithLinearConstraints\nFiniteElements\nGenericAssemblyStrategy\nGenericSparseMatrixAssembler\nGridWithFEMap\nHomogeneousTrialFESpace\nHomogeneousTrialFESpace!\nLinearFESolver\nNonlinearFESolver\nSingleFieldFEFunction\nSingleFieldFESpace\nSparseMatrixAssembler\nTestFESpace\nTrialFESpace\nTrialFESpace!\nUnConstrained\nUnconstrainedFESpace\nZeroMeanFESpace\nadd_mesh_displacement!\nallocate_matrix\nallocate_matrix_and_vector\nallocate_vector\nassemble_matrix\nassemble_matrix!\nassemble_matrix_add!\nassemble_matrix_and_vector\nassemble_matrix_and_vector!\nassemble_matrix_and_vector_add!\nassemble_vector\nassemble_vector!\nassemble_vector_add!\ncol_map\ncol_mask\ncollect_cell_matrix\ncollect_cell_matrix_and_vector\ncollect_cell_vector\ncompute_cell_space\ncompute_conforming_cell_dofs\ncompute_dirichlet_values_for_tags\ncompute_dirichlet_values_for_tags!\ngather_dirichlet_values\ngather_dirichlet_values!\ngather_free_and_dirichlet_values!\ngather_free_values\ngather_free_values!\nget_algebraic_operator\nget_cell_constraints\nget_cell_dof_ids\nget_cell_dof_values\nget_cell_is_dirichlet\nget_cell_isconstrained\nget_cols\nget_dirichlet_dof_ids\nget_dirichlet_dof_tag\nget_dirichlet_dof_values\nget_dirichlet_values\nget_dof_value_type\nget_fe_basis\nget_fe_dof_basis\nget_fe_space\nget_free_dof_ids\nget_free_dof_values\nget_free_values\nget_matrix_builder\nget_matrix_type\nget_rows\nget_test\nget_trial\nget_trial_fe_basis\nget_vector_builder\nget_vector_type\nhas_constraints\ninterpolate\ninterpolate!\ninterpolate_dirichlet\ninterpolate_dirichlet!\ninterpolate_everywhere\ninterpolate_everywhere!\nnum_dirichlet_dofs\nnum_dirichlet_tags\nnum_free_dofs\nnumeric_loop_matrix!\nnumeric_loop_matrix_and_vector!\nnumeric_loop_vector!\nrow_map\nrow_mask\nscatter_free_and_dirichlet_values\nsymbolic_loop_matrix!\nsymbolic_loop_matrix_and_vector!\nsymbolic_loop_vector!\ntest_assembler\ntest_fe_function\ntest_fe_operator\ntest_fe_solver\ntest_fe_space\ntest_single_field_fe_space\ntest_sparse_matrix_assembler\nupdate_coordinates!\nzero_dirichlet_values\nzero_free_values\n\n\n\n\n\n","category":"module"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"AffineFEOperator\n\nRepresent a fully assembled affine (linear) finite element problem. See also FEOperator\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator-Tuple{FESpace, FESpace, AbstractMatrix, AbstractVector}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.Assembler","page":"Gridap.FESpaces","title":"Gridap.FESpaces.Assembler","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AssemblyStrategy","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AssemblyStrategy","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CellConformity","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellConformity","text":"Minimum data required to describe dof ownership. At this moment, the cell-wise ownership is compressed on cell types. This can be relaxed in the future, to have an arbitrary cell-wise dof ownership.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CellConformity-Tuple{AbstractArray{<:ReferenceFE}, Gridap.ReferenceFEs.Conformity}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellConformity","text":"Generate A CellConformity from a vector of reference fes\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.CellFE","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellFE","text":"Minimum data required to build a conforming FE space. At this moment, the some cell-wise info is compressed on cell types. This can be relaxed in the future, and have an arbitrary cell-wise data.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CellFE-Tuple{DiscreteModel, AbstractArray{<:ReferenceFE}, Gridap.ReferenceFEs.Conformity, Vararg{Any}}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellFE","text":"Generate a CellFE from a vector of reference fes\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.ConstantFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ConstantFESpace","text":"struct ConstantFESpace <: SingleFieldFESpace\n\nprivate fields\n\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.DirichletFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.DirichletFESpace","text":"struct DirichletFESpace <: SingleFieldFESpace\n  space::SingleFieldFESpace\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FEFunction-Tuple{FESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunction","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEFunction-Tuple{Gridap.FESpaces.SingleFieldFESpace, AbstractVector, AbstractVector}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunction","text":"FEFunction(\n  fs::SingleFieldFESpace, free_values::AbstractVector, dirichlet_values::AbstractVector)\n\nThe resulting FEFunction will be in the space if and only if dirichlet_values are the ones provided by get_dirichlet_dof_values(fs)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEOperator","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEOperator","text":"abstract type FEOperator <: GridapType\n\nA FEOperator contains finite element problem, that is assembled as far as possible and ready to be solved. See also FETerm\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESolver","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESolver-Tuple{Gridap.Algebra.NonlinearSolver}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FESpaceWithConstantFixed","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESpaceWithConstantFixed","text":"FESpaceWithConstantFixed(space::SingleFieldFESpace, fix_constant::Bool,\ndof_to_fix::Int=num_free_dofs(space))\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.GridWithFEMap","page":"Gridap.FESpaces","title":"Gridap.FESpaces.GridWithFEMap","text":"Given a Discrete Model and a reffe, builds a new grid in which the geometrical map is a FEFunction. This is useful when considering geometrical maps that are the result of a FE problem (mesh displacement).\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFESolver","text":"The solver that solves a LinearFEOperator\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFESolver-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.NodeToDofGlue","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NodeToDofGlue","text":"struct NodeToDofGlue{T}\n  free_dof_to_node::Vector{Int32}\n  free_dof_to_comp::Vector{Int16}\n  dirichlet_dof_to_node::Vector{Int32}\n  dirichlet_dof_to_comp::Vector{Int16}\n  node_and_comp_to_dof::Vector{T}\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.NonlinearFESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NonlinearFESolver","text":"A general NonlinearFESolver\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.NonlinearFESolver-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NonlinearFESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.SingleFieldFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SingleFieldFESpace","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SparseMatrixAssembler","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SparseMatrixAssembler","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SparseMatrixAssembler-Tuple{FESpace, FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SparseMatrixAssembler","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.UnconstrainedFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.UnconstrainedFESpace","text":"Generic implementation of an unconstrained single-field FE space Private fields and type parameters\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ZeroMeanFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ZeroMeanFESpace","text":"struct ZeroMeanFESpace <: SingleFieldFESpace\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ZeroMeanFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, Measure}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ZeroMeanFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Base.zero-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Base.zero","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_jacobian-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_jacobian","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_matrix-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_matrix_and_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_residual-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_residual","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.get_matrix-Tuple{AffineFEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.get_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.get_vector-Tuple{AffineFEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.get_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.jacobian!","text":"jacobian!(A, op, u)\n\n\nInplace version of jacobian.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.jacobian-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.jacobian","text":"jacobian(op, u)\n\n\nCompute the jacobian of an operator op. See also get_algebraic_operator, residual_and_jacobian!.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual!-Tuple{AbstractVector, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual!","text":"residual!(b, op, u)\n\n\nInplace version of residual.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual","text":"residual(op, u)\n\n\nCompute the residual of op at u. See also residual_and_jacobian\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual_and_jacobian!-Tuple{AbstractVector, AbstractMatrix, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual_and_jacobian!","text":"residual_and_jacobian!(b, A, op, u)\n\n\nInplace version of residual_and_jacobian.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual_and_jacobian-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual_and_jacobian","text":"residual, jacobian =\n\nresidual_and_jacobian(op, u)\n\n\nCompute the residual and jacobian of an operator op at a given point u. Depending on the nature of op the point u can either be a plain array or a FEFunction.\n\nSee also jacobian, residual, get_algebraic_operator.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve!-Tuple{Any, FESolver, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve!","text":"uh, cache = solve!(uh,solver,op,cache)\n\nThis function changes the state of the input and can render it in a corrupted state. It is recommended to rewrite the input uh with the output as illustrated to prevent any issue. If cache===nothing, then it creates a new cache object.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve!-Tuple{Any, FESolver, FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve!","text":"uh, cache = solve!(uh,solver,op)\n\nThis function changes the state of the input and can render it in a corrupted state. It is recommended to rewrite the input uh with the output as illustrated to prevent any issue.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve-Tuple{FESolver, FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve","text":"Solve that allocates, and sets initial guess to zero and returns the solution\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.CLagrangianFESpace-Union{Tuple{T}, Tuple{Type{T}, Triangulation, Type, AbstractVector{<:Integer}, AbstractVector}, Tuple{Type{T}, Triangulation, Type, AbstractVector{<:Integer}, AbstractVector, Triangulation}} where T","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CLagrangianFESpace","text":"CLagrangianFESpace(\n::Type{T},\ngrid::Triangulation,\nvector_type::Type,\nnode_to_tag::AbstractVector,\ntag_to_mask::AbstractVector) where T\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.CLagrangianFESpace-Union{Tuple{T}, Tuple{Type{T}, Triangulation}, Tuple{Type{T}, Triangulation, Triangulation}} where T","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CLagrangianFESpace","text":"CLagrangianFESpace(::Type{T},grid::Triangulation) where T\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TestFESpace-Tuple","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TestFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace!-Tuple{AbstractVector, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace!-Tuple{TrialFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_add!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_add!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_and_vector!-Tuple{Any, Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_and_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_and_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector_add!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector_add!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.col_map-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.col_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.col_mask-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.col_mask","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.compute_conforming_cell_dofs","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_conforming_cell_dofs","text":"The result is the tuple\n\n(cell_dofs, nfree, ndiri, dirichlet_dof_tag, dirichlet_cells)\n\nIf dirichlet_components  is given, then get_dof_to_comp has to be defined for the reference elements in reffes.\n\n\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.compute_dirichlet_values_for_tags-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_dirichlet_values_for_tags","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_dirichlet_values!-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_dirichlet_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_and_dirichlet_values!-Tuple{Any, Any, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_and_dirichlet_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_and_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_and_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_values!-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_algebraic_operator-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_algebraic_operator","text":"get_algebraic_operator(feop)\n\n\nReturn an \"algebraic view\" of an operator. Algebraic means, that the resulting operator acts on plain arrays, instead of FEFunctions. This can be useful for solving with external tools like NLsolve.jl. See also FEOperator.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_assembly_strategy-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_assembly_strategy","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_dof_ids-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_dof_ids","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_dof_values-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_dof_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cols-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cols","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_ids-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_ids","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_tag-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_tag","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_values-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_basis-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_dof_basis-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_dof_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_space-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_free_dof_ids-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_free_dof_ids","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_free_dof_values-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_free_dof_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_matrix_builder-Tuple{SparseMatrixAssembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_matrix_builder","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_rows-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_rows","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_test-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_test","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_trial-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_trial","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_vector_builder-Tuple{SparseMatrixAssembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_vector_builder","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate!-Tuple{Any, Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate","text":"The resulting FE function is in the space (in particular it fulfills Dirichlet BCs even in the case that the given cell field does not fulfill them)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_dirichlet!-Tuple{Any, Any, Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_dirichlet!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_dirichlet-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_dirichlet","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_everywhere!-Tuple{Any, Any, Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_everywhere!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_everywhere-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_everywhere","text":"like interpolate, but also compute new degrees of freedom for the dirichlet component. The resulting FEFunction does not necessary belongs to the underlying space\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_dirichlet_dofs-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_dirichlet_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_dirichlet_tags-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_dirichlet_tags","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_free_dofs-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_free_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.row_map-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.row_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.row_mask-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.row_mask","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.scatter_free_and_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.scatter_free_and_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_assembler-Tuple{Gridap.FESpaces.Assembler, Any, Any, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_assembler","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_function-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_function","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_operator-Tuple{FEOperator, Vararg{Any}}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_operator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_solver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_solver","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_space-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_single_field_fe_space","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_single_field_fe_space","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.zero_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.zero_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.zero_free_values-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.zero_free_values","text":"\n\n\n\n","category":"method"},{"location":"Arrays/","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CurrentModule = Gridap.Arrays","category":"page"},{"location":"Arrays/#Gridap.Arrays","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"","category":"section"},{"location":"Arrays/","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Modules = [Arrays,]","category":"page"},{"location":"Arrays/#Gridap.Arrays","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"This module provides:\n\nAn extension of the AbstractArray interface in order to properly deal with mutable caches.\nA mechanism to generate lazy arrays resulting from operations between arrays.\nA collection of concrete implementations of AbstractArray.\n\nThe exported names in this module are:\n\nAddEntriesMap\nAppendedArray\nAutoDiffMap\nBroadcasting\nCachedArray\nCachedMatrix\nCachedVector\nCompressedArray\nConfigMap\nDualizeMap\nFilterMap\nIdentityVector\nKeyToValMap\nLazyArray\nMap\nMulAddMap\nOperation\nPosNegPartition\nPosNegReindex\nReindex\nTable\nTouchEntriesMap\nTreeNode\nUNSET\nVectorWithEntryInserted\nVectorWithEntryRemoved\nappend_ptrs\nappend_ptrs!\nappend_tables_globally\nappend_tables_locally\narray_cache\nautodiff_array_gradient\nautodiff_array_hessian\nautodiff_array_jacobian\ncollect1d\nempty_table\nevaluate\nevaluate!\nfind_inverse_index_map\nfind_inverse_index_map!\nfind_local_index\nflatten_partition\ngenerate_data_and_ptrs\nget_array\nget_data_eltype\nget_local_item\nget_ptrs_eltype\ngetindex!\nidentity_table\ninverse_map\nlazy_append\nlazy_map\nlazy_split\nlength_to_ptrs!\npair_arrays\nprint_op_tree\nreturn_cache\nreturn_type\nreturn_value\nrewind_ptrs!\nsetsize!\nsimilar_tree_node\ntest_array\ntest_map\ntestargs\ntestitem\ntestvalue\nunpair_arrays\nâˆ‘\n\n\n\n\n\n","category":"module"},{"location":"Arrays/#Gridap.Arrays.UNSET","page":"Gridap.Arrays","title":"Gridap.Arrays.UNSET","text":"\n\n\n\n","category":"constant"},{"location":"Arrays/#Gridap.Arrays.Broadcasting","page":"Gridap.Arrays","title":"Gridap.Arrays.Broadcasting","text":"Broadcasting(f)\n\nReturns a mapping that represents the \"broadcasted\" version of the function f.\n\nExample\n\nusing Gridap.Arrays\n\na = [3,2]\nb = [2,1]\n\nbm = Broadcasting(+)\n\nc = evaluate(bm,a,b)\n\nprintln(c)\n\n# output\n[5, 3]\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedArray","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"mutable struct CachedArray{T, N, A<:AbstractArray{T, N}} <: AbstractArray{T, N}\n\nType providing a re-sizable array.\n\nThe size of a CachedArray is changed via the setsize! function.\n\nA CachedArray can be build with the constructors\n\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\n\nusing Gridap.Arrays\n# Create an empty CachedArray\na = CachedArray(Float64,2)\n# Resize to new shape (2,3)\nsetsize!(a,(2,3))\nsize(a)\n# output\n(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedArray-Tuple{Any, Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"CachedArray(T,N)\n\nConstructs an empty CachedArray of element type T and N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedArray-Union{Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A<:AbstractArray{T, N}}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"CachedArray(a::AbstractArray)\n\nConstructs a CachedArray from a given array.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"const CachedMatrix{T,A} = CachedArray{T,2,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix-Tuple{AbstractMatrix}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"CachedMatrix(a)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"CachedMatrix(T)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedVector","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"const CachedVector{T,A} = CachedArray{T,1,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedVector-Tuple{AbstractVector}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"CachedVector(a)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedVector-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"CachedVector(T)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CompressedArray","page":"Gridap.Arrays","title":"Gridap.Arrays.CompressedArray","text":"struct CompressedArray{T,N,A,P} <: AbstractArray{T,N}\n  values::A\n  ptrs::P\nend\n\nType representing an array with a reduced set of values. The array is represented by a short array of values, namely the field values, and a large array of indices, namely the field ptrs. The i-th component of the resulting array is defined as values[ptrs[i]]. The type parameters A, and P are restricted to be array types by the inner constructor of this struct.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CompressedArray-Tuple{AbstractArray, AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.CompressedArray","text":"CompressedArray(values::AbstractArray,ptrs::AbstractArray)\n\nCreates a CompressedArray object by the given arrays of values and ptrs.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.IdentityVector","page":"Gridap.Arrays","title":"Gridap.Arrays.IdentityVector","text":"\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.LazyArray","page":"Gridap.Arrays","title":"Gridap.Arrays.LazyArray","text":"Subtype of AbstractArray which is the result of lazy_map. It represents the result of lazy_mapping a Map to a set of arrays that contain the mapping arguments. This struct makes use of the cache provided by the mapping in order to compute its indices (thus allowing to prevent allocation). The array is lazy, i.e., the values are only computed on demand. It extends the AbstractArray API with two methods:\n\narray_cache(a::AbstractArray)    getindex!(cache,a::AbstractArray,i...)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Map","page":"Gridap.Arrays","title":"Gridap.Arrays.Map","text":"Abstract type representing a function (mapping) that provides a cache and an in-place evaluation for performance. This is the type to be used in the lazy_map function.\n\nDerived types must implement the following method:\n\nevaluate!(cache,k,x...)\n\nand optionally these ones:\n\nreturn_cache(k,x...)\nreturn_type(k,x...)\n\nThe mapping interface can be tested with the test_map function.\n\nNote that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from Map. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Map. For instance, a default implementation is available for Function objects.  However, we recommend that new types inherit from Map.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Operation","page":"Gridap.Arrays","title":"Gridap.Arrays.Operation","text":"Operation(op)\n\nReturns the map that results after applying an operation f over a set of map(s) args. That is Operation(f)(args)(x...) is formally defined as f(map(a->a(x...),args)...).\n\nExample\n\nusing Gridap.Arrays\n\nfa(x) = x.*x\nfb(x) = sqrt.(x)\n\nx = collect(0:5)\n\nfab = Operation(fa)(fb)\nc = evaluate(fab,x)\n\nprintln(c)\n\n# output\n[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.OperationMap","page":"Gridap.Arrays","title":"Gridap.Arrays.OperationMap","text":"OperationMap(f,args)\n\nReturns a mapping that represents the result of applying the function f to the arguments in the tuple args. That is, OperationMap(f,args)(x...) is formally defined as f(map(a->a(x...),args)...)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.PosNegPartition","page":"Gridap.Arrays","title":"Gridap.Arrays.PosNegPartition","text":"struct representing a binary partition of a range of indices\n\nUsing this allows one to do a number of important optimizations when working with PosNegReindex\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.PosNegReindex","page":"Gridap.Arrays","title":"Gridap.Arrays.PosNegReindex","text":"PosNegReindex(values_pos,values_neg)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Reindex","page":"Gridap.Arrays","title":"Gridap.Arrays.Reindex","text":"Reindex(values) -> Map\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.SubVector","page":"Gridap.Arrays","title":"Gridap.Arrays.SubVector","text":"struct SubVector{T,A<:AbstractVector{T}} <: AbstractVector{T}\n  vector::A\n  pini::Int\n  pend::Int\nend\n\nSubVector is deprecated, use view instead.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Table","page":"Gridap.Arrays","title":"Gridap.Arrays.Table","text":" struct Table{T,Vd<:AbstractVector{T},Vp<:AbstractVector} <: AbstractVector{Vector{T}}\n    data::Vd\n    ptrs::Vp\n end\n\nType representing a list of lists (i.e., a table) in compressed format.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Table-Tuple{AbstractArray{<:AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.Table","text":"Table(a::AbstractArray{<:AbstractArray})\n\nBuild a table from a vector of vectors. If the inputs are multidimensional arrays instead of vectors, they are flattened.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.append_ptrs!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.append_ptrs","text":"append_ptrs(pa,pb)\n\nAppend two vectors of pointers.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_globally-Union{Tuple{Vararg{Gridap.Arrays.Table{T, Vd, Vp}}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_globally","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_locally","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table}}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_locally","text":"append_tables_locally(tables::Table...)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.array_cache-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.array_cache","text":"array_cache(a::AbstractArray)\n\nReturns a cache object to be used in the getindex! function. It defaults to\n\narray_cache(a::T) where T = nothing\n\nfor types T such that uses_hash(T) == Val(false), and\n\nfunction array_cache(a::T) where T\n  hash = Dict{UInt,Any}()\n  array_cache(hash,a)\nend\n\nfor types T such that uses_hash(T) == Val(true), see the uses_hash function. In the later case, the type T should implement the following signature:\n\narray_cache(hash::Dict,a::AbstractArray)\n\nwhere we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object a has already built a cache and re-use it as follows\n\nid = objectid(a)\nif haskey(hash,id)\n  cache = hash[id] # Reuse cache\nelse\n  cache = ... # Build a new cache depending on your needs\n  hash[id] = cache # Register the cache in the hash table\nend\n\nThis mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.collect1d-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.collect1d","text":"collect1d(a)\n\nEquivalent to\n\n[a[i] for in 1:length(a)]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}","page":"Gridap.Arrays","title":"Gridap.Arrays.empty_table","text":"empty_table(::Type{T},::Type{P}, l::Integer) where {T,P}\nempty_table(l::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.evaluate!","text":"evaluate!(cache,f,x...)\n\nApplies the mapping f at the arguments x... using the scratch data provided in the given cache object. The cache object is built with the return_cache function using arguments of the same type as in x. In general, the returned value y can share some part of its state with the cache object. If the result of two or more calls to this function need to be accessed simultaneously (e.g., in multi-threading), create and use several cache objects (e.g., one cache per thread).\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.evaluate","text":"evaluate(f,x...)\n\nevaluates the mapping f at the arguments in x by creating a temporary cache internally. This functions is equivalent to\n\ncache = return_cache(f,x...)\nevaluate!(cache,f,x...)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_inverse_index_map","page":"Gridap.Arrays","title":"Gridap.Arrays.find_inverse_index_map","text":"\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.find_inverse_index_map!-Tuple{Any, Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_inverse_index_map!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_local_index-Tuple{Any, Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_local_index","text":"find_local_index(a_to_b, b_to_la_to_a)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.flatten_partition","page":"Gridap.Arrays","title":"Gridap.Arrays.flatten_partition","text":"flatten_partition(a_to_bs::Table,nb::Integer)\nflatten_partition(a_to_bs::Table)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{<:AbstractArray{T}}}, Tuple{T}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.generate_data_and_ptrs","text":"data, ptrs = generate_data_and_ptrs(vv)\n\nGiven a vector of vectors, compress it and return the corresponding data and and ptrs\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_array-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_array","text":"get_array(a::AbstractArray)\n\nReturns a.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_data_eltype","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_ptrs_eltype","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.getindex!-Tuple{Any, AbstractArray, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.getindex!","text":"getindex!(cache,a::AbstractArray,i...)\n\nReturns the item of the array a associated with index i by (possibly) using the scratch data passed in the cache object.\n\nIt defaults to\n\ngetindex!(cache,a::AbstractArray,i...) = a[i...]\n\nAs for standard Julia arrays, the user needs to implement only one of the following signatures depending on the IndexStyle of the array.\n\ngetindex!(cache,a::AbstractArray,i::Integer)\ngetindex!(cache,a::AbstractArray{T,N},i::Vararg{Integer,N}) where {T,N}\n\nExamples\n\nIterating over an array using the getindex! function\n\nusing Gridap.Arrays\n\na = collect(10:15)\n\ncache = array_cache(a)\nfor i in eachindex(a)\n  ai = getindex!(cache,a,i)\n  println(\"$i -> $ai\")\nend\n\n# output\n1 -> 10\n2 -> 11\n3 -> 12\n4 -> 13\n5 -> 14\n6 -> 15\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}","page":"Gridap.Arrays","title":"Gridap.Arrays.identity_table","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.inverse_map-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.inverse_map","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_append-Tuple{AbstractArray, AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_append","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_map-Tuple{Any, Type, Vararg{AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_map","text":"lazy_map(f,::Type{T},a::AbstractArray...) where T\n\nLike lazy_map(f,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_map-Tuple{Any, Vararg{AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_map","text":"lazy_map(f,a::AbstractArray...) -> AbstractArray\n\nApplies the Map (or Function) f to the entries of the arrays in a (see the definition of Map).\n\nThe resulting array r is such that r[i] equals to evaluate(f,ai...) where ai is the tuple containing the i-th entry of the arrays in a (see function evaluate for more details). In other words, the resulting array is numerically equivalent to:\n\nmap( (x...)->evaluate(f,x...), a...)\n\nExamples\n\nUsing a function as mapping\n\nusing Gridap.Arrays\n\na = collect(0:5)\nb = collect(10:15)\n\nc = lazy_map(+,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\nUsing a user-defined mapping\n\nusing Gridap.Arrays\nimport Gridap.Arrays: evaluate!\n\na = collect(0:5)\nb = collect(10:15)\n\nstruct MySum <: Map end\n\nevaluate!(cache,::MySum,x,y) = x + y\n\nk = MySum()\n\nc = lazy_map(k,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_split-Tuple{AbstractArray, Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_split","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.pair_arrays-Tuple{AbstractArray, AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.pair_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.return_cache","text":"return_cache(f,x...)\n\nReturns the cache needed to lazy_map mapping f with arguments of the same type as the objects in x. This function returns nothing by default, i.e., no cache.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.return_type-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.return_type","text":"return_type(f,x...)\n\nReturns the type of the result of calling mapping f with arguments of the types of the objects x.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{Gridap.Arrays.CachedArray{T, N, A} where A<:AbstractArray{T, N}, Tuple{Vararg{Int64, N}}}} where {T, N}","page":"Gridap.Arrays","title":"Gridap.Arrays.setsize!","text":"setsize!(a, s)\n\n\nChanges the size of the CachedArray a to the size described the the tuple s. After calling setsize!, the array can store uninitialized values.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.test_array-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}, Any}} where {T, S, N}","page":"Gridap.Arrays","title":"Gridap.Arrays.test_array","text":"test_array(\n  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}\n\nChecks if the entries in a and b are equal using the comparison function cmp. It also stresses the new methods added to the AbstractArray interface.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.test_map-Tuple{Any, Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.test_map","text":"test_map(y,f,x...;cmp=(==))\n\nFunction used to test if the mapping f has been implemented correctly. f is a Map sub-type, x is a tuple in the domain of the mapping and y is the expected result. Function cmp is used to compare the computed result with the expected one. The checks are done with the @test macro.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testargs-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.testargs","text":"testargs(f,x...)\n\nThe default implementation of this function is testargs(f,x...) = x. One can overload it in order to use lazy_map with 0-length array and maps with non-trivial domains.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testitem-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.testitem","text":"testitem(a::AbstractArray{T}) -> Any\n\n\nReturns an arbitrary instance of eltype(a). The default returned value is the first entry in the array if length(a)>0 and testvalue(eltype(a)) if length(a)==0 See the testvalue function.\n\nExamples\n\nusing Gridap.Arrays\n\na = collect(3:10)\nai = testitem(a)\n\nb = Int[]\nbi = testitem(b)\n\n(ai, bi)\n\n# output\n(3, 0)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testvalue","page":"Gridap.Arrays","title":"Gridap.Arrays.testvalue","text":"testvalue(::Type{T}) where T\n\nReturns an arbitrary instance of type T. It defaults to zero(T) for non-array types and to an empty array for array types. It can be overloaded for new types T if zero(T) does not makes sense. This function is used to compute  testitem for 0-length arrays.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{<:Tuple{var\"#s78\", var\"#s77\"} where {var\"#s78\", var\"#s77\"}}}","page":"Gridap.Arrays","title":"Gridap.Arrays.unpair_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.uses_hash-Tuple{Type{<:AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.uses_hash","text":"uses_hash(::Type{<:AbstractArray})\n\nThis function is used to specify if the type T uses the hash-based mechanism to reuse caches.  It should return either Val(true) or Val(false). It defaults to\n\nuses_hash(::Type{<:AbstractArray}) = Val(false)\n\nOnce this function is defined for the type T it can also be called on instances of T.\n\n\n\n\n\n","category":"method"},{"location":"CellData/","page":"Gridap.CellData","title":"Gridap.CellData","text":"CurrentModule = Gridap.CellData","category":"page"},{"location":"CellData/#Gridap.CellData","page":"Gridap.CellData","title":"Gridap.CellData","text":"","category":"section"},{"location":"CellData/","page":"Gridap.CellData","title":"Gridap.CellData","text":"Modules = [CellData,]","category":"page"},{"location":"CellData/#Gridap.CellData","page":"Gridap.CellData","title":"Gridap.CellData","text":"The exported names are\n\nCellDatum\nCellDof\nCellField\nCellPoint\nCellQuadrature\nCellState\nDiracDelta\nDomainContribution\nDomainStyle\nGenericCellField\nIntegrand\nInterpolable\nKDTreeSearch\nMeasure\nPhysicalDomain\nReferenceDomain\nSkeletonCellFieldPair\nadd_contribution!\nattach_constraints_cols\nattach_constraints_rows\nattach_dirichlet\nchange_domain\ncompute_cell_points_from_vector_of_points\ncross\ndet\ndot\ndouble_contraction\nget_cell_measure\nget_cell_points\nget_contribution\nget_data\nget_domains\nget_normal_vector\nget_physical_coordinate\nget_triangulation\ngradient\nidentity_constraints\ninner\njump\nmake_inverse_table\nmean\nnum_domains\nouter\nsymmetric_part\ntest_cell_datum\ntr\nupdate_state!\nÃ—\nâˆ‡\nâˆ‡âˆ‡\nâˆ«\nâŠ—\nâŠ™\nâ‹…\nâ‹…Â²\nâ‹…Â¹\n\n\n\n\n\n","category":"module"},{"location":"CellData/#Gridap.CellData.CellDatum","page":"Gridap.CellData","title":"Gridap.CellData.CellDatum","text":"Data associated with the cells of a Triangulation. CellDatum objects behave as if they are defined in the physical space of the triangulation. But in some cases they are implemented as reference quantities plus some transformation to the physical domain.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellDof","page":"Gridap.CellData","title":"Gridap.CellData.CellDof","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellField","page":"Gridap.CellData","title":"Gridap.CellData.CellField","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellPoint","page":"Gridap.CellData","title":"Gridap.CellData.CellPoint","text":"A single point or an array of points on the cells of a Triangulation CellField objects can be evaluated efficiently at CellPoint instances.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellQuadrature","page":"Gridap.CellData","title":"Gridap.CellData.CellQuadrature","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellState","page":"Gridap.CellData","title":"Gridap.CellData.CellState","text":"This can be used as a CellField as long as one evaluates it on the stored CellPoint.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CompositeMeasure","page":"Gridap.CellData","title":"Gridap.CellData.CompositeMeasure","text":"Composite Measure\n\nMeasure such that the integration and target triangulations are different. \n\nttrian: Target triangulation, where the domain contribution lives.\nitrian: Integration triangulation, where the integration takes place.\nquad  : CellQuadrature, defined in itrian\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.DomainContribution","page":"Gridap.CellData","title":"Gridap.CellData.DomainContribution","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.DomainStyle","page":"Gridap.CellData","title":"Gridap.CellData.DomainStyle","text":"Trait that signals if a CellDatum type is implemented in the physical or the reference domain\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.DomainStyle-Tuple{Type{<:Gridap.CellData.CellDatum}}","page":"Gridap.CellData","title":"Gridap.CellData.DomainStyle","text":"Tell if the stored array is in the reference or physical domain\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.GenericCellField","page":"Gridap.CellData","title":"Gridap.CellData.GenericCellField","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.SkeletonCellFieldPair","page":"Gridap.CellData","title":"Gridap.CellData.SkeletonCellFieldPair","text":"SkeletonCellFieldPair is a special construct for allowing uh.plus   and uh.minus to be two different CellFields. In particular, it is   useful when we need one of the CellFields to be the dualized   version of the other for performing ForwardDiff AD of a Skeleton   integration DomainContribution wrt to the degrees of freedom   of the CellField, plus and minus sensitivities done separately,   so as to restrict the interaction between the dual numbers.\n\nIt takes in two CellFields and stores plus version of CellFieldAt   of the first CellField and minus version of CellFieldAt of the   second the CellField. SkeletonCellFieldPair is associated with   same triangulation as that of the CellFields (we check if the   triangulations of both CellFields match)\n\nSkeletonCellFieldPair is an internal convenience artifact/construct   to aid in dualizing plus and minus side around a Skeleton face separately   to perform the sensitivity of degrees of freedom of cells sharing the   Skeleton face, without the interaction dual numbers of the two cells.   The user doesn't have to deal with this construct anywhere when   performing AD of functionals involving integration over Skeleton faces   using the public API.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.Arrays.get_array-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.Arrays.get_array","text":"Get the raw array of cell data defined in the physical space.\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.change_domain-Tuple{Gridap.CellData.CellDatum, DomainStyle}","page":"Gridap.CellData","title":"Gridap.CellData.change_domain","text":"Change the underlying data to the target domain\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.distance-Tuple{Gridap.ReferenceFEs.ExtrusionPolytope, Gridap.Fields.Field, VectorValue}","page":"Gridap.CellData","title":"Gridap.CellData.distance","text":"dist = distance(polytope::ExtrusionPolytope,                    inv_cmap::Field,                    x::Point)\n\nCalculate distance from point x to the polytope. The polytope is given by its type and by the inverse cell map, i.e. by the map from the physical to the reference space.\n\nPositive distances are outside the polytope, negative distances are inside the polytope.\n\nThe distance is measured in an unspecified norm, currently the Lâˆž norm.\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.get_cell_points-Tuple{Triangulation}","page":"Gridap.CellData","title":"Gridap.CellData.get_cell_points","text":"\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.get_data-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.CellData.get_data","text":"Get the stored array of cell-wise data. It can be defined in the physical or the reference domain.\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.get_physical_coordinate-Tuple{Triangulation}","page":"Gridap.CellData","title":"Gridap.CellData.get_physical_coordinate","text":"get_physical_coordinate(trian::Triangulation)\n\nIn contrast to getcellmap, the returned object:\n\nis a CellField\nits gradient is the identity tensor\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.test_cell_datum-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.CellData.test_cell_datum","text":"\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.Geometry.get_triangulation-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.Geometry.get_triangulation","text":"Return the underlying Triangulation object\n\n\n\n\n\n","category":"method"},{"location":"Gridap/#Gridap","page":"Gridap","title":"Gridap","text":"","category":"section"},{"location":"Gridap/","page":"Gridap","title":"Gridap","text":"Gridap","category":"page"},{"location":"Gridap/#Gridap","page":"Gridap","title":"Gridap","text":"Gridap, grid-based approximation of PDEs in the Julia programming language\n\nThis module provides rich set of tools for the numerical solution of PDE, mainly based on finite element methods.\n\nThe module is structured in the following sub-modules:\n\nGridap.Helpers\nGridap.Io\nGridap.Algebra\nGridap.Arrays\nGridap.TensorValues\nGridap.Fields\nGridap.Polynomials\nGridap.ReferenceFEs\nGridap.CellData\nGridap.Geometry\nGridap.Visualization\nGridap.FESpaces\nGridap.MultiField\nGridap.ODEs\nGridap.Adaptivity\n\nThe exported names are:\n\nAffineFEOperator\nAffineFETerm\nBDM\nBackslashSolver\nBackwardEuler\nBoundary\nBoundaryTriangulation\nBroadcasting\nButcherTableau\nCartesianDiscreteModel\nCartesianGrid\nCellField\nCellQuadrature\nCellState\nConstantFESpace\nDIV\nDiracDelta\nDiscreteModel\nDiscreteModelFromFile\nDomainStyle\nFEEnergy\nFEFunction\nFEOperator\nFESolver\nFESource\nFESpace\nFETerm\nFiniteElements\nForwardEuler\nGeneralizedAlpha1\nGridapType\nHEX\nHEX8\nInterface\nInterfaceTriangulation\nInterior\nLUSolver\nLagrangian\nLinearFESolver\nLinearFETerm\nMeasure\nMidPoint\nModalC0\nMultiFieldFESpace\nNLSolver\nNedelec\nOperation\nPYRAMID\nPhysicalDomain\nPoint\nPolytope\nQUAD\nQUAD4\nRaviartThomas\nReferenceDomain\nReferenceFE\nReindex\nRungeKutta\nSEG2\nSEGMENT\nSkeleton\nSkeletonTriangulation\nSparseMatrixAssembler\nTET\nTET4\nTRI\nTRI3\nTensorValue\nTestFESpace\nThetaMethod\nTransientFEOperator\nTransientIMEXFEOperator\nTransientLinearFEOperator\nTransientMultiFieldFESpace\nTransientQuasilinearFEOperator\nTransientSemilinearFEOperator\nTransientTrialFESpace\nTrialFESpace\nTriangulation\nVERTEX\nVERTEX1\nVectorValue\nWEDGE\nadd_tag!\nadd_tag_from_tags!\napply\narray_cache\nassemble_matrix\nassemble_matrix_and_vector\nassemble_vector\navailable_tableaus\nbdm\ncell_measure\ncreatepvd\ncreatevtk\ncross\ncurl\ndet\ndiagonal_tensor\ndivergence\ndot\nevaluate\nevaluate!\nget_active_model\nget_array\nget_background_model\nget_cell_coordinates\nget_cell_dof_ids\nget_cell_dof_values\nget_cell_map\nget_cell_measure\nget_cell_points\nget_cell_ref_coordinates\nget_dirichlet_dof_ids\nget_dirichlet_dof_values\nget_dirichlet_values\nget_face_labeling\nget_fe_basis\nget_free_dof_ids\nget_free_dof_values\nget_free_values\nget_glue\nget_grid\nget_matrix\nget_normal_vector\nget_physical_coordinate\nget_trial_fe_basis\nget_triangulation\nget_vector\ngetindex!\ngradient\nhessian\ninner\nintegrate\ninterpolate\ninterpolate_dirichlet\ninterpolate_everywhere\ninv\nis_P\nis_Q\nis_S\nis_first_order\nis_n_cube\nis_simplex\njacobian\njump\nlagrangian\nlaplacian\nlazy_map\nmean\nmodalC0\nmove_contributions\nnedelec\nnorm\nnum_cell_dims\nnum_cells\nnum_components\nnum_dims\nnum_dirichlet_dofs\nnum_dirichlet_tags\nnum_edges\nnum_entities\nnum_faces\nnum_facets\nnum_fields\nnum_free_dofs\nnum_point_dims\nnum_tags\nnum_vertices\nnumerical_setup\nnumerical_setup!\nouter\nprint_op_tree\nraviart_thomas\nrestrict\nsavepvd\nsimplexify\nsolve\nsolve!\nsymbolic_setup\nsymmetric_gradient\ntr\nupdate_state!\nwritevtk\nzero_initial_guess\nÃ—\nÎ”\nÎµ\nâˆ‚t\nâˆ‚tt\nâˆ‡\nâˆ‡âˆ‡\nâˆ‘\nâˆ«\nâŠ—\nâŠ™\nâ‹…\n\n\n\n\n\n","category":"module"},{"location":"Algebra/","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"CurrentModule = Gridap.Algebra","category":"page"},{"location":"Algebra/#Gridap.Algebra","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"","category":"section"},{"location":"Algebra/","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"Modules = [Algebra,]","category":"page"},{"location":"Algebra/#Gridap.Algebra","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"The exported names are\n\nAffineOperator\nArrayBuilder\nBackslashSolver\nDoNotLoop\nLUSolver\nLinearSolver\nLoop\nLoopStyle\nMinCPU\nMinMemory\nNLSolver\nNewtonRaphsonSolver\nNonlinearOperator\nNonlinearSolver\nNumericalSetup\nSparseMatrixBuilder\nSymbolicSetup\nadd_entries!\nadd_entry!\nallocate_coo_vectors\nallocate_in_domain\nallocate_in_range\nallocate_jacobian\nallocate_matrix\nallocate_matrix_and_vector\nallocate_residual\nallocate_residual_and_jacobian\nallocate_vector\naxpy_entries!\ncopy_entries!\ncreate_from_nz\nfinalize_coo!\nget_array_type\nget_matrix\nget_vector\nhessian\nhessian!\nis_entry_stored\njacobian\njacobian!\nlength_to_ptrs!\nmuladd!\nnumerical_setup\nnumerical_setup!\nnz_allocation\nnz_counter\nnz_index\npush_coo!\nresidual\nresidual!\nresidual_and_jacobian\nresidual_and_jacobian!\nrewind_ptrs!\nsolve\nsolve!\nsparse_from_coo\nsymbolic_setup\ntest_linear_solver\ntest_nonlinear_operator\ntest_nonlinear_solver\nzero_initial_guess\n\n\n\n\n\n","category":"module"},{"location":"Algebra/#Gridap.Algebra.AffineOperator","page":"Gridap.Algebra","title":"Gridap.Algebra.AffineOperator","text":"struct AffineOperator{A<:AbstractMatrix,B<:AbstractVector} <: NonlinearOperator\n  matrix::A\n  vector::B\nend\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.BackslashSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.BackslashSolver","text":"struct BackslashSolver <: LinearSolver end\n\nWrapper of the backslash solver available in julia This is typically faster than LU for a single solve\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.LUSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.LUSolver","text":"struct LUSolver <: LinearSolver end\n\nWrapper of the LU solver available in julia\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.LinearSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.LinearSolver","text":"abstract type LinearSolver <: NonlinearSolver end\n\nsymbolic_setup(::LinearSolver,mat::AbstractMatrix)\ntest_linear_solver\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NLSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NLSolver","text":"struct NLSolver <: NonlinearSolver\n  # private fields\nend\n\nThe cache generated when using this solver has a field result that hosts the result object generated by the underlying nlsolve function. It corresponds to the most latest solve.\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NLSolver-Tuple{}","page":"Gridap.Algebra","title":"Gridap.Algebra.NLSolver","text":"NLSolver(ls::LinearSolver;kwargs...)\nNLSolver(;kwargs...)\n\nSame kwargs as in nlsolve. If ls is provided, it is not possible to use the linsolve kw-argument.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.NewtonRaphsonSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NewtonRaphsonSolver","text":"struct NewtonRaphsonSolver <:NonlinearSolver\n  # Private fields\nend\n\nVanilla Newton-Raphson method\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NonlinearOperator","page":"Gridap.Algebra","title":"Gridap.Algebra.NonlinearOperator","text":"abstract type NonlinearOperator <: GridapType end\n\nresidual!(b::AbstractVector,op::NonlinearOperator,x::AbstractVector)\njacobian!(A::AbstractMatrix,op::NonlinearOperator,x::AbstractVector)\nzero_initial_guess(op::NonlinearOperator)\nallocate_residual(op::NonlinearOperator,x::AbstractVector)\nallocate_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NonlinearSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NonlinearSolver","text":"abstract type NonlinearSolver <: GridapType end\n\nsolve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator)\nsolve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator, cache)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NumericalSetup","page":"Gridap.Algebra","title":"Gridap.Algebra.NumericalSetup","text":"abstract type NumericalSetup <: GridapType end\n\nnumerical_setup!(::NumericalSetup,mat::AbstractMatrix)\nsolve!(x::AbstractVector,::NumericalSetup,b::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.SymbolicSetup","page":"Gridap.Algebra","title":"Gridap.Algebra.SymbolicSetup","text":"abstract type SymbolicSetup <: GridapType end\n\nnumerical_setup(::SymbolicSetup,mat::AbstractMatrix)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.add_entries!-Tuple{Function, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entries!","text":"add_entries!(combine::Function,A,vs,is,js)\n\nAdd several entries only for positive input indices. Returns A.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.add_entry!-Tuple{Function, Vararg{Any}}","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entry!","text":"add_entry!(combine::Function,A,v,i...)\nadd_entry!(A,v,i...)\n\nAdd an entry. Returns A.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_domain-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_domain","text":"allocate_in_domain(matrix::AbstractMatrix{T}) where T\n\nAllocate a vector in the domain of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_domain-Union{Tuple{V}, Tuple{Type{V}, Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_domain","text":"allocate_in_domain(::Type{V},matrix) where V\n\nAllocate a vector of type V in the domain of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_range-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_range","text":"allocate_in_range(matrix::AbstractMatrix{T}) where T\n\nAllocate a vector in the range of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_range-Union{Tuple{V}, Tuple{Type{V}, Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_range","text":"allocate_in_range(::Type{V},matrix) where V\n\nAllocate a vector of type V in the range of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_jacobian","text":"allocate_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_residual","text":"allocate_residual(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_residual_and_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_residual_and_jacobian","text":"allocate_residual_and_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_vector-Union{Tuple{V}, Tuple{Type{V}, Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_vector","text":"allocate_vector(::Type{V},indices) where V\n\nAllocate a vector of type V indexable at the indices indices\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.axpy_entries!-Union{Tuple{T}, Tuple{Number, T, T}} where T<:(AbstractMatrix)","page":"Gridap.Algebra","title":"Gridap.Algebra.axpy_entries!","text":"axpy_entries!(Î±::Number, A::T, B::T) where {T<: AbstractMatrix} -> T\n\nEfficient implementation of axpy! for sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.copy_entries!-Tuple{Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.copy_entries!","text":"copy_entries!(a,b)\n\nCopy the entries of array b into array a. Returns a.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.finalize_coo!-Tuple{Type, Any, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.finalize_coo!","text":"finalize_coo!(::Type,I,J,V,m,n)\n\nCheck and insert diagonal entries in COO vectors if needed.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.get_matrix-Tuple{Gridap.Algebra.AffineOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.get_matrix","text":"get_matrix(operator)\n\nReturn the matrix corresponding to the assembled left hand side of the operator. This matrix incorporates all boundary conditions and constraints.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.get_vector-Tuple{Gridap.Algebra.AffineOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.get_vector","text":"get_vector(operator)\n\nReturn the vector corresponding to the assembled right hand side of the operator. This vector includes all boundary conditions and constraints.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.is_entry_stored-Tuple{Type, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.is_entry_stored","text":"is_entry_stored(::Type,i,j) -> Bool\n\nTells if the entry with coordinates [i,j] will be stored in the coo vectors.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.jacobian!","text":"jacobian!(A::AbstractMatrix,op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.jacobian","text":"jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.length_to_ptrs!-Tuple{AbstractArray{<:Integer}}","page":"Gridap.Algebra","title":"Gridap.Algebra.length_to_ptrs!","text":"length_to_ptrs!(ptrs)\n\nGiven a vector of integers, mutate it from length state to pointer state.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.muladd!-Tuple{Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.muladd!","text":"muladd!(c,a,b)\n\nMatrix multiply a*b and add to result to c. Returns c.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.numerical_setup!-Tuple{Gridap.Algebra.NumericalSetup, AbstractMatrix}","page":"Gridap.Algebra","title":"Gridap.Algebra.numerical_setup!","text":"numerical_setup!(::NumericalSetup,mat::AbstractMatrix)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.numerical_setup-Tuple{Gridap.Algebra.SymbolicSetup, AbstractMatrix}","page":"Gridap.Algebra","title":"Gridap.Algebra.numerical_setup","text":"numerical_setup(::SymbolicSetup,mat::AbstractMatrix) -> NumericalSetup\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.push_coo!-Tuple{Type, Any, Any, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.push_coo!","text":"push_coo!(::Type, I,J,V,i,j,v)\n\nInserts entries in COO vectors for further building a sparse matrix of type T.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual!","text":"residual!(b::AbstractVector,op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual","text":"residual(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual_and_jacobian!-Tuple{AbstractVector, AbstractMatrix, Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual_and_jacobian!","text":"residual_and_jacobian!(\n  b::AbstractVector, A::AbstractMatrix,\n  op::NonlinearOperator, x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual_and_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual_and_jacobian","text":"residual_and_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.rewind_ptrs!-Tuple{AbstractVector{<:Integer}}","page":"Gridap.Algebra","title":"Gridap.Algebra.rewind_ptrs!","text":"rewind_ptrs!(ptrs)\n\nRewind the given vector of pointers.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.LinearSolver, AbstractMatrix, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,ls::LinearSolver,A::AbstractMatrix,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.LinearSolver, Gridap.Algebra.AffineOperator, Any, Bool}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(\n  x::AbstractVector,\n  ls::LinearSolver,\n  op::AffineOperator,\n  cache,\n  newmatrix::Bool)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.NonlinearSolver, Gridap.Algebra.NonlinearOperator, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator,cache)\n\nSolve using the cache object from a previous solve.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.NonlinearSolver, Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator)\n\nUsage:\n\ncache = solve!(x,nls,op)\n\nThe returned cache object can be used in subsequent solves:\n\ncache = solve!(x,nls,op,cache)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.NumericalSetup, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,::NumericalSetup,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve-Tuple{Gridap.Algebra.LinearSolver, AbstractMatrix, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve","text":"solve(ls::LinearSolver,A::AbstractMatrix,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve-Tuple{Gridap.Algebra.NonlinearSolver, Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve","text":"solve(nls::NonlinearSolver,op::NonlinearOperator)\n\nCreates and uses a zero initial guess.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.sparse_from_coo-Tuple{Type, Any, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.sparse_from_coo","text":"sparse_from_coo(::Type,I,J,V,m,n)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.symbolic_setup-Tuple{Gridap.Algebra.LinearSolver, AbstractMatrix}","page":"Gridap.Algebra","title":"Gridap.Algebra.symbolic_setup","text":"symbolic_setup(::LinearSolver,mat::AbstractMatrix) -> SymbolicSetup\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.test_linear_solver-Tuple{Gridap.Algebra.LinearSolver, AbstractMatrix, AbstractVector, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.test_linear_solver","text":"test_linear_solver(\n  ls::LinearSolver,\n  A::AbstractMatrix,\n  b::AbstractVector,\n  x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.test_nonlinear_operator","page":"Gridap.Algebra","title":"Gridap.Algebra.test_nonlinear_operator","text":"test_nonlinear_operator(\n  op::NonlinearOperator,\n  x::AbstractVector,\n  b::AbstractVector,\n  pred=isapprox;\n  jac=nothing)\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.test_nonlinear_solver","page":"Gridap.Algebra","title":"Gridap.Algebra.test_nonlinear_solver","text":"test_nonlinear_solver(\n  nls::NonlinearSolver,\n  op::NonlinearOperator,\n  x0::AbstractVector,\n  x::AbstractVector,\n  pred::Function=isapprox)\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.zero_initial_guess-Tuple{Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.zero_initial_guess","text":"zero_initial_guess(op::NonlinearOperator)\n\n\n\n\n\n","category":"method"},{"location":"Io/","page":"Gridap.Io","title":"Gridap.Io","text":"CurrentModule = Gridap.Io","category":"page"},{"location":"Io/#Gridap.Io","page":"Gridap.Io","title":"Gridap.Io","text":"","category":"section"},{"location":"Io/","page":"Gridap.Io","title":"Gridap.Io","text":"Modules = [Io,]","category":"page"},{"location":"Io/#Gridap.Io","page":"Gridap.Io","title":"Gridap.Io","text":"The exported names in this module are:\n\nfrom_bson_file\nfrom_dict\nfrom_jld2_file\nfrom_json\nfrom_json_file\nto_bson_file\nto_dict\nto_jld2_file\nto_json\nto_json_file\n\n\n\n\n\n","category":"module"},{"location":"Io/#Gridap.Io.check_dict-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"Gridap.Io","title":"Gridap.Io.check_dict","text":"check_dict(::Type{T},dict::Dict) where T\n\nCheck validity of a dictionary dict for an object of type T. It runs successfully if the dictionary is valid for a particular  type or throws an error in any other case.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_bson_file-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_bson_file","text":"function from_bson_file(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_dict-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"Gridap.Io","title":"Gridap.Io.from_dict","text":"from_dict(::Type{T},dict::Dict) where T\n\nDe-serialize an object of type T from the dictionary dict. Values stored into this dictionary must be of any native  Julia data type (Real, Integer, String, etc.) Dictionary keys are Symbols.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_jld2_file","page":"Gridap.Io","title":"Gridap.Io.from_jld2_file","text":"function from_jld2_file(filename::AbstractString,dataset::AbstractString=\"data\")\n\nLoads an object from a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the generated JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"Io/#Gridap.Io.from_jld2_file-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_jld2_file","text":"function from_jld2_file(::Type{T},filename::AbstractString,dataset::AbstractString=\"data\") where T\n\nLoads an object from a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the generated JLD2 file. Checks if the returned object is of the expected Type{T}, if not return error.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_json-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_json","text":"from_json(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_json_file-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_json_file","text":"from_json_file(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_bson_file-Tuple{Any, Any}","page":"Gridap.Io","title":"Gridap.Io.to_bson_file","text":"to_bson_file(object,filename)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_dict-Tuple{Any}","page":"Gridap.Io","title":"Gridap.Io.to_dict","text":"to_dict(object) -> Dict\n\nSerialize object into a dictionary of type Dict{Symbol,Any}. Values stored into this dictionary must be of any native  Julia data type (Real, Integer, String, etc.) Dictionary keys are Symbols.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_jld2_file","page":"Gridap.Io","title":"Gridap.Io.to_jld2_file","text":"function to_jld2_file(object,filename::AbstractString,dataset::AbstractString=\"data\")\n\nStores an object to a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"Io/#Gridap.Io.to_json-Tuple{Any}","page":"Gridap.Io","title":"Gridap.Io.to_json","text":"to_json(object)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_json_file-Tuple{Any, Any}","page":"Gridap.Io","title":"Gridap.Io.to_json_file","text":"to_json_file(object,filename)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"CurrentModule = Gridap.Polynomials","category":"page"},{"location":"Polynomials/#Gridap.Polynomials","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"","category":"section"},{"location":"Polynomials/","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"Modules = [Polynomials,]","category":"page"},{"location":"Polynomials/#Gridap.Polynomials","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"This module provides a collection of multivariate polynomial bases.\n\nThe exported names are:\n\nJacobiPolynomialBasis\nModalC0Basis\nMonomialBasis\nPCurlGradMonomialBasis\nQCurlGradMonomialBasis\nQGradMonomialBasis\nget_exponents\nget_order\nget_orders\nnum_terms\n\n\n\n\n\n","category":"module"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"struct MonomialBasis{D,T} <: AbstractVector{Monomial}\n\nType representing a basis of multivariate scalar-valued, vector-valued, or tensor-valued, iso- or aniso-tropic monomials. The fields of this struct are not public. This type fully implements the Field interface, with up to second order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}, Tuple{Type{T}, Int64, Function}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, order::Int [, filter::Function]) where {D,T}\n\nReturns an instance of MonomialBasis representing a multivariate polynomial basis in D dimensions, of polynomial degree order, whose value is represented by the type T. The type T is typically <:Number, e.g., Float64 for scalar-valued functions and VectorValue{D,Float64} for vector-valued ones.\n\nFilter function\n\nThe filter function is used to select which terms of the tensor product space of order order in D dimensions are to be used. If the filter is not provided, the full tensor-product space is used by default leading to a multivariate polynomial space of type Q. The signature of the filter function is\n\n(e,order) -> Bool\n\nwhere e is a tuple of D integers containing the exponents of a multivariate monomial. The following filters are used to select well known polynomial spaces\n\nQ space: (e,order) -> true\nP space: (e,order) -> sum(e) <= order\n\"Serendipity\" space: (e,order) -> sum( [ i for i in e if i>1 ] ) <= order\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Tuple{Vararg{Int64, D}}}, Tuple{Type{T}, Tuple{Vararg{Int64, D}}, Function}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, orders::Tuple [, filter::Function]) where {D,T}\n\nThis version of the constructor allows to pass a tuple orders containing the polynomial order to be used in each of the D dimensions in order to  construct an anisotropic tensor-product space.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.PCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.PCurlGradMonomialBasis","text":"struct PCurlGradMonomialBasis{...} <: AbstractArray{Monomial}\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on simplices. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.PCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.PCurlGradMonomialBasis","text":"PCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a PCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the divergence of the  functions in this basis is in the P space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.QCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QCurlGradMonomialBasis","text":"struct QCurlGradMonomialBasis{...} <: AbstractArray{Monomial}\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on n-cubes. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.QCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QCurlGradMonomialBasis","text":"QCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the divergence of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.QGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QGradMonomialBasis","text":"struct QGradMonomialBasis{...} <: AbstractVector{Monomial}\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Nedelec reference elements on n-cubes. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.QGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QGradMonomialBasis","text":"QGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the curl of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Arrays.return_type-Union{Tuple{Gridap.Polynomials.MonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Arrays.return_type","text":"\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_exponents-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_exponents","text":"get_exponents(b::MonomialBasis)\n\nGet a vector of tuples with the exponents of all the terms in the monomial basis.\n\nExamples\n\nusing Gridap.Polynomials\n\nb = MonomialBasis{2}(Float64,2)\n\nexponents = get_exponents(b)\n\nprintln(exponents)\n\n# output\nTuple{Int,Int}[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_order-Tuple{Gridap.Polynomials.ModalC0Basis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_order","text":"get_order(b::ModalC0Basis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_order-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_order","text":"get_order(b::MonomialBasis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_orders-Tuple{Gridap.Polynomials.ModalC0Basis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_orders","text":"get_orders(b::ModalC0Basis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_orders-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_orders","text":"get_orders(b::MonomialBasis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.PCurlGradMonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::PCurlGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.QCurlGradMonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::QCurlGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.QGradMonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::QGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"TensorValues/","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"CurrentModule = Gridap.TensorValues","category":"page"},{"location":"TensorValues/#Gridap.TensorValues","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"","category":"section"},{"location":"TensorValues/","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"Modules = [TensorValues,]","category":"page"},{"location":"TensorValues/#Gridap.TensorValues","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"This module provides concrete implementations of Number that represent 1st, 2nd and general order tensors.\n\nWhy\n\nThe main feature of this module is that the provided types do not extend from AbstractArray, but from Number!\n\nThis allows one to work with them as if they were scalar values in broadcasted operations on arrays of VectorValue objects (also for TensorValue or MultiValue objects). For instance, one can perform the following manipulations:\n\n# Assign a VectorValue to all the entries of an Array of VectorValues\nA = zeros(VectorValue{2,Int}, (4,5))\nv = VectorValue(12,31)\nA .= v # This is possible since  VectorValue <: Number\n\n# Broadcasting of tensor operations in arrays of TensorValues\nt = TensorValue(13,41,53,17) # creates a 2x2 TensorValue\ng = TensorValue(32,41,3,14) # creates another 2x2 TensorValue\nB = fill(t,(1,5))\nC = inner.(g,B) # inner product of g against all TensorValues in the array B\n@show C\n# C = [2494 2494 2494 2494 2494]\n\nThe exported names are:\n\nMultiValue\nMutable\nSymFourthOrderTensorValue\nSymTensorValue\nTensorValue\nThirdOrderTensorValue\nVectorValue\nchange_eltype\ncross\ndata_index\ndet\ndiagonal_tensor\ndot\ndouble_contraction\ninner\ninv\nmeas\nmutable\nn_components\nnorm\nnum_components\nouter\nsymmetric_part\ntr\nÃ—\nâŠ—\nâŠ™\nâ‹…\nâ‹…Â²\nâ‹…Â¹\n\n\n\n\n\n","category":"module"},{"location":"TensorValues/#Gridap.TensorValues.MultiValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.MultiValue","text":"Type representing a multi-dimensional value\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.SymFourthOrderTensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.SymFourthOrderTensorValue","text":"Type representing a symmetric fourth-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.SymTensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.SymTensorValue","text":"Type representing a symmetric second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.TensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.TensorValue","text":"Type representing a second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.ThirdOrderTensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.ThirdOrderTensorValue","text":"Type representing a third-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.VectorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.VectorValue","text":"Type representing a first-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.meas-Union{Tuple{Gridap.TensorValues.MultiValue{Tuple{D}}}, Tuple{D}} where D","page":"Gridap.TensorValues","title":"Gridap.TensorValues.meas","text":"\n\n\n\n","category":"method"},{"location":"TensorValues/#Gridap.TensorValues.outer-Tuple{Number, Number}","page":"Gridap.TensorValues","title":"Gridap.TensorValues.outer","text":"\n\n\n\n","category":"method"},{"location":"TensorValues/#Gridap.TensorValues.symmetric_part-Union{Tuple{Gridap.TensorValues.MultiValue{Tuple{D, D}}}, Tuple{D}} where D","page":"Gridap.TensorValues","title":"Gridap.TensorValues.symmetric_part","text":"\n\n\n\n","category":"method"},{"location":"Fields/","page":"Gridap.Fields","title":"Gridap.Fields","text":"CurrentModule = Gridap.Fields","category":"page"},{"location":"Fields/#Gridap.Fields","page":"Gridap.Fields","title":"Gridap.Fields","text":"","category":"section"},{"location":"Fields/","page":"Gridap.Fields","title":"Gridap.Fields","text":"Modules = [Fields,]","category":"page"},{"location":"Fields/#Gridap.Fields.AffineMap","page":"Gridap.Fields","title":"Gridap.Fields.AffineMap","text":"A Field with this form y = xâ‹…G + y0\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.BroadcastOpFieldArray","page":"Gridap.Fields","title":"Gridap.Fields.BroadcastOpFieldArray","text":"Type that represents a broadcast operation over a set of AbstractArray{<:Field}. The result is a sub-type of AbstractArray{<:Field}\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.Field","page":"Gridap.Fields","title":"Gridap.Fields.Field","text":"abstract type Field <: Map\n\nAbstract type representing a physical (scalar, vector, or tensor) field. The domain is a Point and the range a scalar (i.e., a sub-type of Julia Number), a VectorValue, or a TensorValue.\n\nThese different cases are distinguished by the return value obtained when evaluating them. E.g., a physical field returns a vector of values when evaluated at a vector of points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThe following functions (i.e., the Map API) need to be overloaded:\n\nevaluate!(cache,f,x)\nreturn_cache(f,x)\n\nand optionally\n\nreturn_type(f,x)\n\nA Field can also provide its gradient if the following function is implemented\n\ngradient(f)\n\nHigher derivatives can be obtained if the resulting object also implements this method.\n\nThe next paragraph is out-of-date:\n\nMoreover, if the gradient(f) is not provided, a default implementation that uses the following functions will be used.\n\nevaluate_gradient!(cache,f,x)\nreturn_gradient_cache(f,x)\n\nHigher order derivatives require the implementation of\n\nevaluate_hessian!(cache,f,x)\nreturn_hessian_cache(f,x)\n\nThese four methods are only designed to be called by the default implementation of field_gradient(f) and thus cannot be assumed that they are available for an arbitrary field. For this reason, these functions are not exported. The general way of evaluating a gradient of a field is to build the gradient with gradient(f) and evaluating the resulting object. For evaluating the hessian, use two times gradient.\n\nThe interface can be tested with\n\ntest_field\n\nFor performance, the user can also consider a vectorised version of the Field API that evaluates the field in a vector of points (instead of only one point). E.g., the evaluate! function for a vector of points returns a vector of scalar, vector or tensor values.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.FieldGradient","page":"Gridap.Fields","title":"Gridap.Fields.FieldGradient","text":"Type that represents the gradient of a field. The wrapped field must implement evaluate_gradient! and return_gradient_cache for this gradient to work.\n\nN is how many times the gradient is applied\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.FieldGradientArray","page":"Gridap.Fields","title":"Gridap.Fields.FieldGradientArray","text":"A wrapper that represents the broadcast of gradient over an array of fields. Ng is the number of times the gradient is applied\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.GenericField","page":"Gridap.Fields","title":"Gridap.Fields.GenericField","text":"A wrapper for objects that can act as fields, e.g., functions which implement the Field API.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.OperationField","page":"Gridap.Fields","title":"Gridap.Fields.OperationField","text":"A Field that is obtained as a given operation over a tuple of fields.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.Point","page":"Gridap.Fields","title":"Gridap.Fields.Point","text":"const Point{D,T} = VectorValue{D,T}\n\nType representing a point of D dimensions with coordinates of type T. Fields are evaluated at vectors of Point objects.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.TransposeFieldIndices","page":"Gridap.Fields","title":"Gridap.Fields.TransposeFieldIndices","text":"Given a matrix np x nf1 x nf2 result of the evaluation of a field vector on a vector of points, it returns an array in which the field axes (second and third axes) are permuted. It is equivalent as Base.permutedims(A,(1,3,2)) but more performant, since it does not involve allocations.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.ZeroField","page":"Gridap.Fields","title":"Gridap.Fields.ZeroField","text":"It represents 0.0*f for a field f.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Base.:âˆ˜-Tuple{Gridap.Fields.Field, Gridap.Fields.Field}","page":"Gridap.Fields","title":"Base.:âˆ˜","text":"fâˆ˜g\n\nIt returns the composition of two fields, which is just Operation(f)(g)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Arrays.evaluate!-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, VectorValue}} where T<:Gridap.Fields.Field","page":"Gridap.Fields","title":"Gridap.Arrays.evaluate!","text":"Implementation of return_cache for a array of Field.\n\nIf the field vector has length nf and it is evaluated in one point, it returns an nf vector with the result. If the same array is applied to a vector of np points, it returns a matrix np x nf.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.DIV-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.DIV","text":"DIV(f)\nReference space divergence\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.curl-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.curl","text":"curl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.divergence-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.divergence","text":"divergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.grad2curl-Tuple{TensorValue{2}}","page":"Gridap.Fields","title":"Gridap.Fields.grad2curl","text":"grad2curl(âˆ‡f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.gradient_type-Union{Tuple{T}, Tuple{Type{T}, VectorValue}} where T","page":"Gridap.Fields","title":"Gridap.Fields.gradient_type","text":"gradient_type(::Type{T},x::Point) where T\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{AbstractArray{<:Gridap.Fields.Field}, AbstractVector{<:VectorValue}, AbstractVector{<:Real}, Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given array of fields in the \"reference\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{AbstractArray{<:Gridap.Fields.Field}, AbstractVector{<:VectorValue}, AbstractVector{<:Real}}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given array of fields in the \"physical\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{Gridap.Fields.Field, AbstractVector{<:VectorValue}, AbstractVector{<:Real}, Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given field in the \"reference\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{Gridap.Fields.Field, AbstractVector{<:VectorValue}, AbstractVector{<:Real}}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given field in the \"physical\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.laplacian-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.laplacian","text":"laplacian(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.symmetric_gradient-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.symmetric_gradient","text":"symmetric_gradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.test_field","page":"Gridap.Fields","title":"Gridap.Fields.test_field","text":"test_field(\n  f::Union{Field,AbstractArray{<:Field}},\n  x,\n  v,\n  cmp=(==);\n  grad=nothing,\n  gradgrad=nothing)\n\nFunction used to test the field interface. v is an array containing the expected result of evaluating the field f at the point or vector of points x. The comparison is performed using the cmp function. For fields objects that support the gradient function, the keyword argument grad can be used. It should contain the result of evaluating gradient(f) at x. Idem for gradgrad. The checks are performed with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.Fields.Î”","page":"Gridap.Fields","title":"Gridap.Fields.Î”","text":"const Î” = laplacian\n\nAlias for the laplacian function\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.Fields.Îµ","page":"Gridap.Fields","title":"Gridap.Fields.Îµ","text":"const Îµ = symmetric_gradient\n\nAlias for the symmetric gradient\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.TensorValues.outer-Tuple{Gridap.Fields.Field, typeof(gradient)}","page":"Gridap.Fields","title":"Gridap.TensorValues.outer","text":"outer(f,âˆ‡)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.TensorValues.outer-Tuple{typeof(gradient), Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.TensorValues.outer","text":"outer(âˆ‡,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.cross-Tuple{typeof(gradient), Gridap.Fields.Field}","page":"Gridap.Fields","title":"LinearAlgebra.cross","text":"cross(âˆ‡,f)\n\nEquivalent to\n\ncurl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.dot-Tuple{typeof(gradient), Gridap.Fields.Field}","page":"Gridap.Fields","title":"LinearAlgebra.dot","text":"âˆ‡â‹…f\n\nEquivalent to\n\ndivergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"CurrentModule = Gridap.Visualization","category":"page"},{"location":"Visualization/#Gridap.Visualization","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"","category":"section"},{"location":"Visualization/","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"Modules = [Visualization,]","category":"page"},{"location":"Visualization/#Gridap.Visualization","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"The exported names are\n\nVisualizationData\ncreatepvd\ncreatevtk\nsavepvd\nvisualization_data\nwrite_vtk_file\nwritevtk\n\n\n\n\n\n","category":"module"},{"location":"Visualization/#Gridap.Visualization.create_vtk_file-Tuple{Gridap.Geometry.Grid, Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.create_vtk_file","text":"create_vtk_file(\n  trian::Grid,\n  filebase;\n  celldata=Dict(),\n  nodaldata=Dict(),\n  vtk_kwargs...\n)\n\nLow level entry point to vtk. Other vtk-related routines in Gridap eventually call this one. This function only creates the vtkFile, without writing to disk.\n\nThe optional WriteVTK kwargs vtk_kwargs are passed to the vtk_grid constructor.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.createpvd-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.createpvd","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.createvtk-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.createvtk","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.get_vtkid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Visualization","title":"Gridap.Visualization.get_vtkid","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.get_vtknodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Visualization","title":"Gridap.Visualization.get_vtknodes","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.savepvd-Tuple{WriteVTK.CollectionFile}","page":"Gridap.Visualization","title":"Gridap.Visualization.savepvd","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.visualization_data-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.visualization_data","text":"This function returns an iterable collection (e.g. a Vector) of VisualizationData objects\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.write_vtk_file-Tuple{Gridap.Geometry.Grid, Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.write_vtk_file","text":"write_vtk_file(\n  trian::Grid,\n  filebase;\n  celldata=Dict(),\n  nodaldata=Dict(),\n  vtk_kwargs...\n  )\n\nLow level entry point to vtk. Other vtk-related routines in Gridap eventually call this one. The optional WriteVTK kwargs vtk_kwargs are passed to the vtk_grid constructor.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"\n\n\n\n","category":"method"},{"location":"ReferenceFEs/","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"CurrentModule = Gridap.ReferenceFEs","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"","category":"section"},{"location":"ReferenceFEs/","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"Modules = [ReferenceFEs,]","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"The exported names are\n\nBDM\nBDMRefFE\nBezier\nBezierRefFE\nCDConformity\nCONT\nConformity\nContraVariantPiolaMap\nCurlConformity\nDISC\nDivConforming\nDivConformity\nDof\nExtrusionPolytope\nGeneralPolytope\nGenericLagrangianRefFE\nGenericQuadrature\nGenericRefFE\nGradConformity\nH1Conformity\nHEX\nHEX8\nHEX_AXIS\nINVALID_PERM\nL2Conformity\nLagrangian\nLagrangianDofBasis\nLagrangianRefFE\nModalC0\nModalC0RefFE\nMomentBasedDofBasis\nNedelec\nNedelecRefFE\nPYRAMID\nPolygon\nPolyhedron\nPolytope\nQUAD\nQUAD4\nQuadrature\nQuadratureName\nRaviartThomas\nRaviartThomasRefFE\nReferenceFE\nReferenceFEName\nSEG2\nSEGMENT\nSerendipityRefFE\nTET\nTET4\nTET_AXIS\nTRI\nTRI3\nVERTEX\nVERTEX1\nWEDGE\nbdm\nbezier\ncompress_cell_data\ncompute_cell_to_modalC0_reffe\ncompute_face_orders\ncompute_lagrangian_reffaces\ncompute_monomial_basis\ncompute_nodes\ncompute_own_nodes\ncompute_own_nodes_permutations\ncompute_shapefuns\nduffy\nevaluate!\nevaluate_dof\nexpand_cell_data\nget_bounding_box\nget_coordinates\nget_dimrange\nget_dimranges\nget_dof_basis\nget_dof_to_comp\nget_dof_to_node\nget_edge_tangent\nget_extrusion\nget_face_coordinates\nget_face_dimranges\nget_face_dofs\nget_face_moments\nget_face_nodes\nget_face_nodes_dofs\nget_face_own_dofs\nget_face_own_dofs_permutations\nget_face_own_nodes\nget_face_own_nodes_permutations\nget_face_type\nget_face_vertex_permutations\nget_face_vertices\nget_facedims\nget_faces\nget_facet_normal\nget_facet_orientations\nget_name\nget_node_and_comp_to_dof\nget_node_coordinates\nget_nodes\nget_offset\nget_offsets\nget_order\nget_orders\nget_own_dofs_permutations\nget_own_nodes_permutations\nget_polytope\nget_prebasis\nget_reffaces\nget_shapefuns\nget_vertex_coordinates\nget_vertex_node\nget_vertex_permutations\nget_weights\nis_P\nis_Q\nis_S\nis_first_order\nis_n_cube\nis_simplex\nlagrangian\nlinear_combination\nmodalC0\nnedelec\nnum_cell_dims\nnum_dims\nnum_dofs\nnum_edges\nnum_faces\nnum_facets\nnum_nodes\nnum_point_dims\nnum_points\nnum_vertices\nraviart_thomas\nreturn_cache\nreturn_type\nsimplexify\nstrang\ntensor_product\ntest_dof\ntest_dof_array\ntest_lagrangian_reference_fe\ntest_polytope\ntest_quadrature\ntest_reference_fe\n\n\n\n\n\n","category":"module"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX","text":"const HEX = Polytope(HEX_AXIS,HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX8","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX8","text":"const HEX8 = LagrangianRefFE(Float64,HEX,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX_AXIS","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX_AXIS","text":"Constant to be used in order to indicate a hex-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.INVALID_PERM","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.INVALID_PERM","text":"Constant of type Int  used to signal that a permutation is not valid.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.PYRAMID","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.PYRAMID","text":"const PYRAMID = Polytope(HEX_AXIS,HEX_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.QUAD","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.QUAD","text":"const QUAD = Polytope(HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.QUAD4","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.QUAD4","text":"const QUAD4 = LagrangianRefFE(Float64,QUAD,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SEG2","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SEG2","text":"const SEG2 = LagrangianRefFE(Float64,SEGMENT,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SEGMENT","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SEGMENT","text":"const SEGMENT = Polytope(HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET","text":"const TET = Polytope(TET_AXIS,TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET4","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET4","text":"const TET4 = LagrangianRefFE(Float64,TET,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET_AXIS","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET_AXIS","text":"Constant to be used in order to indicate a tet-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TRI","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TRI","text":"const TRI = Polytope(TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TRI3","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TRI3","text":"const TRI3 = LagrangianRefFE(Float64,TRI,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.VERTEX","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.VERTEX","text":"const VERTEX = Polytope()\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.VERTEX1","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.VERTEX1","text":"const VERTEX1 = LagrangianRefFE(Float64,VERTEX,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.WEDGE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.WEDGE","text":"const WEDGE = Polytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Conformity-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Conformity","text":"Conformity(reffe::ReferenceFE) -> Conformity\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ExtrusionPolytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ExtrusionPolytope","text":"struct ExtrusionPolytope{D} <: Polytope{D}\n  extrusion::Point{D,Int}\n  # + private fields\nend\n\nConcrete type for polytopes that can be represented with an \"extrusion\" tuple. The underlying extrusion is available in the field extrusion. Instances of this type can be obtained with the constructors\n\nPolytope(extrusion::Int...)\nExtrusionPolytope(extrusion::Int...)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ExtrusionPolytope","text":"ExtrusionPolytope(extrusion::Int...)\n\nGenerates an ExtrusionPolytope from the tuple extrusion. The values in extrusion are either equal to the constant HEX_AXIS or the constant TET_AXIS.\n\nExamples\n\nCreating a quadrilateral, a triangle, and a wedge\n\nusing Gridap.ReferenceFEs\n\nquad = ExtrusionPolytope(HEX_AXIS,HEX_AXIS)\n\ntri = ExtrusionPolytope(TET_AXIS,TET_AXIS)\n\nwedge = ExtrusionPolytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\nprintln(quad == QUAD)\nprintln(tri == TRI)\nprintln(wedge == WEDGE)\n\n# output\ntrue\ntrue\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GeneralPolytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GeneralPolytope","text":"struct GeneralPolytope{D,Dp,Tp} <: Polytope{D}\n\nThe GeneralPolytope is definded defined by a set of vertices and a rototation   system (a planar oriented graph). This polytopal representation can represent   any polytope in 2 and 3 dimensions.\n\nIn 2 dimensions (Polygon), the representation of the polygon is a closed polyline.\n\nIn 3 dimensions (Polyhedron), the rotation system generates the connectivities, each   facet is a closed cycle of the graph.   This construction allows complex geometrical operations, e.g., intersecting polytopes by halfspaces.   See also,\n\nK. Sugihara, \"A robust and consistent algorithm for intersecting convex polyhedra\", Comput. Graph. Forum 13 (3) (1994) 45â€“54, doi: 10.1111/1467-8659.1330045\n\nD. Powell, T. Abel, \"An exact general remeshing scheme applied to physically conservative voxelization\", J. Comput. Phys. 297 (Sept. 2015) 340â€“356, doi: [10.1016/j.jcp.2015.05.022](https://doi.org/10.1016/j.jcp.2015.05.022.\n\nS. Badia, P. A. Martorell, F. Verdugo. \"Geometrical discretisations for unfitted finite elements on explicit boundary representations\", J.Comput. Phys. 460 (2022): 111162. doi: 10.1016/j.jcp.2022.111162\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GeneralPolytope-Union{Tuple{D}, Tuple{AbstractVector{<:VectorValue}, Vector{<:Vector}}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GeneralPolytope","text":"GeneralPolytope{D}(vertices,graph;kwargs...)\n\nConstructor of a GeneralPolytope that generates a polytope of   D dimensions with the given vertices and graph of connectivities.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericLagrangianRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericLagrangianRefFE","text":"struct GenericLagrangianRefFE{C,D} <: LagrangianRefFE{D}     reffe::GenericRefFE{C,D}     face_nodes::Vector{Vector{Int}}   end\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericQuadrature","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericQuadrature","text":"struct GenericQuadrature{D,T,C <: AbstractVector{Point{D,T}},W <: AbstractVector{T}} <: Quadrature{D,T}\n  coordinates::Vector{Point{D,T}}\n  weights::Vector{T}\n  name::String\nend\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericRefFE","text":"struct GenericRefFE{T,D} <: ReferenceFE{D}\n  # + private fields\nend\n\nThis type is a materialization of the ReferenceFE interface. That is, it is a struct that stores the values of all abstract methods in the ReferenceFE interface. This type is useful to build reference FEs from the underlying ingredients without the need to create a new type.\n\nNote that some fields in this struct are type unstable deliberately in order to simplify the type signature. Don't access them in computationally expensive functions, instead extract the required fields before and pass them to the computationally expensive function.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Int64, Polytope{D}, AbstractVector{<:Gridap.Fields.Field}, AbstractVector{<:Gridap.ReferenceFEs.Dof}, Gridap.ReferenceFEs.Conformity, Any, Vector{Vector{Int64}}}, Tuple{Int64, Polytope{D}, AbstractVector{<:Gridap.Fields.Field}, AbstractVector{<:Gridap.ReferenceFEs.Dof}, Gridap.ReferenceFEs.Conformity, Any, Vector{Vector{Int64}}, AbstractVector{<:Gridap.Fields.Field}}} where {T, D}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericRefFE","text":"  GenericRefFE{T}(\n  ndofs::Int,\n  polytope::Polytope{D},\n  prebasis::AbstractVector{<:Field},\n  dofs::AbstractVector{<:Dof},\n  conformity::Conformity,\n  metadata,\n  face_dofs::Vector{Vector{Int}},\n  shapefuns::AbstractVector{<:Field}=compute_shapefuns(dofs,prebasis)) where {T,D}\n\nConstructs a GenericRefFE object with the provided data.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Int64, Polytope{D}, AbstractVector{<:Gridap.ReferenceFEs.Dof}, Gridap.ReferenceFEs.Conformity, Any, Vector{Vector{Int64}}, AbstractVector{<:Gridap.Fields.Field}}, Tuple{Int64, Polytope{D}, AbstractVector{<:Gridap.ReferenceFEs.Dof}, Gridap.ReferenceFEs.Conformity, Any, Vector{Vector{Int64}}, AbstractVector{<:Gridap.Fields.Field}, AbstractVector{<:Gridap.ReferenceFEs.Dof}}} where {T, D}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericRefFE","text":"  GenericRefFE{T}(\n  ndofs::Int,\n  polytope::Polytope{D},\n  prebasis::AbstractVector{<:Field},\n  predofs::AbstractVector{<:Dof},\n  conformity::Conformity,\n  metadata,\n  face_dofs::Vector{Vector{Int}},\n  shapefuns::AbstractVector{<:Field},\n  dofs::AbstractVector{<:Dof}=compute_dofs(predofs,shapefuns)) where {T,D}\n\nConstructs a GenericRefFE object with the provided data.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianDofBasis","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianDofBasis","text":"struct LagrangianDofBasis{P,V} <: AbstractArray{<:Dof}\n  nodes::Vector{P}\n  dof_to_node::Vector{Int}\n  dof_to_comp::Vector{Int}\n  node_and_comp_to_dof::Vector{V}\nend\n\nType that implements a Lagrangian dof basis.\n\nFields:\n\nnodes::Vector{P} vector of points (P<:Point) storing the nodal coordinates\nnode_and_comp_to_dof::Vector{V} vector such that node_and_comp_to_dof[node][comp] returns the dof associated with node node and the component comp in the type V.\ndof_to_node::Vector{Int} vector of integers such that dof_to_node[dof] returns the node id associated with dof id dof.\ndof_to_comp::Vector{Int} vector of integers such that dof_to_comp[dof] returns the component id associated with dof id dof.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianDofBasis-Union{Tuple{T}, Tuple{Type{T}, Vector{<:VectorValue}}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianDofBasis","text":"LagrangianDofBasis(::Type{T},nodes::Vector{<:Point}) where T\n\nCreates a LagrangianDofBasis for fields of value type T associated with the vector of nodal coordinates nodes.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianRefFE","text":"abstract type LagrangianRefFE{D} <: ReferenceFE{D}\n\nAbstract type representing a Lagrangian reference FE. Lagrangian in the sense that get_dof_basis returns an instance of LagrangianDofBasis. The interface for this type is defined with the methods of ReferenceFE plus the following ones\n\nget_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity)\nget_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\nget_face_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T}, Polytope{D}, Any}} where {T, D}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianRefFE","text":"LagrangianRefFE(::Type{T},p::Polytope,orders) where T\nLagrangianRefFE(::Type{T},p::Polytope,order::Int) where T\n\nBuilds a LagrangianRefFE object on top of the given polytope. T is the type of the value of the approximation space (e.g., T=Float64 for scalar-valued problems, T=VectorValue{N,Float64} for vector-valued problems with N components). The arguments order or orders are for the polynomial order of the resulting space, which allows isotropic or anisotropic orders respectively (provided that the cell topology allows the given anisotropic order). The argument orders should be an indexable collection of D integers (e.g., a tuple or a vector), being D the number of space dimensions.\n\nIn order to be able to use this function, the type of the provided polytope p has to implement the following additional methods. They have been implemented for ExtrusionPolytope in the library. They need to be implemented for new polytope types in order to build Lagangian reference elements on top of them.\n\ncompute_monomial_basis(::Type{T},p::Polytope,orders) where T\ncompute_own_nodes(p::Polytope,orders)\ncompute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nThe following methods are also used in the construction of the LagrangianRefFE object. A default implementation of them is available in terms of the three previous methods. However, the user can also implement them for new polytope types increasing customization possibilities.\n\ncompute_nodes(p::Polytope,orders)\ncompute_own_nodes_permutations(p::Polytope, interior_nodes)\ncompute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LinearCombinationDofVector","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LinearCombinationDofVector","text":"struct LinearCombinationDofVector{T} <: AbstractVector{Dof}\n  change_of_basis::Matrix{T}\n  dof_basis::AbstractVector{<:Dof}\nend\n\nType that implements a dof basis (a) as the linear combination of a dof basis (b). The dofs are first evaluated at dof basis (b) (field dof_basis) and the dof values are next mapped to dof basis (a) applying a change of basis (field change_of_basis).\n\nFields:\n\nchange_of_basis::Matrix{T} the matrix of the change from dof basis (b) to (a)\ndof_basis::AbstractVector{<:Dof} A type representing dof basis (b)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polygon","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polygon","text":"Polygon = GeneralPolytope{2}\n\nA polygon is a GeneralPolytope in 2 dimensions.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polyhedron","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polyhedron","text":"Polyhedron = GeneralPolytope{3}\n\nA polyhedron is a GeneralPolytope in 3 dimensions.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"abstract type Polytope{D} <: GridapType\n\nAbstract type representing a polytope (i.e., a polyhedron in arbitrary dimensions). D is the environment dimension (typically, 0, 1, 2, or 3). This type parameter is needed since there are functions in the Polytope interface that return containers with Point{D} objects. We adopt the usual nomenclature for polytope-related objects. All objects in a polytope (from vertices to the polytope itself) are called n-faces or simply faces. The notation n-faces is used only when it is needed to refer to the object dimension n. Otherwise we simply use face. In addition, we say\n\nvertex (pl. vertices): for 0-faces\nedge: for 1-faces\nfacet: for (D-1)-faces\n\nThe Polytope interface is defined by overloading the following functions\n\nget_faces(p::Polytope)\nget_dimranges(p::Polytope)\nPolytope{N}(p::Polytope,faceid::Integer) where N\nget_vertex_coordinates(p::Polytope)\n(==)(a::Polytope{D},b::Polytope{D}) where D\n\nAnd optionally these ones:\n\nget_edge_tangent(p::Polytope)\nget_facet_normal(p::Polytope)\nget_facet_orientations(p::Polytope)\nget_vertex_permutations(p::Polytope)\nis_n_cube(p::Polytope)\nis_simplex(p::Polytope)\nsimplexify(p::Polytope)\n\nThe interface can be tested with the function\n\ntest_polytope\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope-Tuple{Vararg{Int64}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"Polytope(extrusion::Int...)\n\nEquivalent to ExtrusionPolytope(extrusion...)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope-Union{Tuple{D}, Tuple{Polytope, Integer}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"Polytope{N}(p::Polytope,faceid::Integer) where N\n\nReturns a Polytope{N} object representing the \"reference\" polytope of the N-face with id faceid. The value faceid refers to the numeration restricted to the dimension N (it starts with 1 for the first N-face).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Quadrature","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Quadrature","text":"abstract type Quadrature{D,T} <: GridapType end\n\n-get_coordinates(q::Quadrature) -get_weights(q::Quadrature) -test_quadrature\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Quadrature-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Quadrature","text":"Quadrature(polytope::Polytope{D},degree) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ReferenceFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ReferenceFE","text":"abstract type ReferenceFE{D} <: GridapType\n\nAbstract type representing a Reference finite element. D is the underlying coordinate space dimension. We follow the Ciarlet definition. A reference finite element is defined by a polytope (cell topology), a basis of an interpolation space of top of this polytope (denoted here as the prebasis), and a basis of the dual of this space (i.e. the degrees of freedom). From this information one can compute the shape functions (i.e, the canonical basis of w.r.t. the degrees of freedom) with a simple change of basis. In addition, we also encode in this type information about how the interpolation space in a reference finite element is \"glued\" with neighbors in order to build conforming cell-wise spaces.\n\nThe ReferenceFE interface is defined by overloading these methods:\n\nnum_dofs(reffe::ReferenceFE)\nget_polytope(reffe::ReferenceFE)\nget_prebasis(reffe::ReferenceFE)\nget_dof_basis(reffe::ReferenceFE)\nConformity(reffe::ReferenceFE)\nget_face_own_dofs(reffe::ReferenceFE,conf::Conformity)\nget_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity)\nget_face_dofs(reffe::ReferenceFE)\n\nThe interface is tested with\n\ntest_reference_fe(reffe::ReferenceFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ReferenceFE-Union{Tuple{N}, Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}, Integer}} where N","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ReferenceFE","text":"ReferenceFE{N}(reffe::GenericLagrangianRefFE{GradConformity},iface::Integer) where N\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{Gridap.ReferenceFEs.LagrangianRefFE{D}, Gridap.ReferenceFEs.LagrangianRefFE{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::LagrangianRefFE{D}, b::LagrangianRefFE{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{Polytope{D}, Polytope{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::Polytope{D},b::Polytope{D}) where D\n\nReturns true if the polytopes a and b are equivalent. Otherwise, it returns false. Note that the operator == returns false by default for polytopes of different dimensions. Thus, this function has to be overloaded only for the case of polytopes a and b of same dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.isopen-Tuple{Gridap.ReferenceFEs.GeneralPolytope}","page":"Gridap.ReferenceFEs","title":"Base.isopen","text":"isopen(p::GeneralPolytope) -> Bool\n\nIn return whether the polytope is watter tight or not.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Polynomials.get_order-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.Polynomials.get_order","text":"get_order(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Polynomials.get_orders-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.Polynomials.get_orders","text":"get_orders(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.BDMRefFE-Union{Tuple{et}, Tuple{Type{et}, Polytope, Integer}} where et","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.BDMRefFE","text":"BDMRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the divergence of the  functions in this basis is in the P space of degree order-1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ModalC0RefFE-Union{Tuple{V}, Tuple{D}, Tuple{T}, Tuple{Type{T}, Polytope{D}, Any, Array{VectorValue{D, V}, 1}, Array{VectorValue{D, V}, 1}}} where {T, D, V}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ModalC0RefFE","text":"ModalC0RefFE(::Type{T},p::Polytope{D},orders) where {T,D}\n\nReturns an instance of GenericRefFE{ModalC0} representing a ReferenceFE with Modal C0-continuous shape functions (multivariate scalar-valued, vector-valued, or tensor-valued, iso- or aniso-tropic).\n\nFor more details about the shape functions, see Section 1.1.5 in\n\nErn, A., & Guermond, J. L. (2013). Theory and practice of finite elements (Vol. 159). Springer Science & Business Media.\n\nand references therein.\n\nThe constructor is only implemented for for n-cubes and the minimum order in any dimension must be greater than one. The DoFs are numbered by n-faces in the same way as with CLagrangianRefFEs.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.NedelecRefFE-Union{Tuple{et}, Tuple{Type{et}, Polytope, Integer}} where et","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.NedelecRefFE","text":"NedelecRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the curl of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.RaviartThomasRefFE-Union{Tuple{et}, Tuple{Type{et}, Polytope, Integer}} where et","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.RaviartThomasRefFE","text":"RaviartThomasRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the divergence of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SerendipityRefFE-Union{Tuple{T}, Tuple{Type{T}, Polytope, Int64}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SerendipityRefFE","text":"SerendipityRefFE(::Type{T},p::Polytope,order::Int) where T\nSerendipityRefFE(::Type{T},p::Polytope,orders::Tuple) where T\n\nReturns an instance of LagrangianRefFE, whose underlying approximation space is the serendipity space of order order. Implemented for order from 1 to 4. The type of the polytope p has to implement all the queries detailed in the constructor LagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D}.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\norder = 2\nreffe = SerendipityRefFE(Float64,QUAD,order)\n\nprintln( num_dofs(reffe) )\n\n# output\n8\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.check_polytope_graph-Tuple{Gridap.ReferenceFEs.GeneralPolytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.check_polytope_graph","text":"check_polytope_graph(p::GeneralPolytope) -> Bool\n\nIt checks whether the graph is well-constructed. The graph must be oriented   and planar.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_dofs-Tuple{Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_dofs","text":"compute_dofs(predofs,shapefuns)\n\nHelper function used to compute the dof basis associated with the dof basis predofs and the basis shapefuns.\n\nIt is equivalent to\n\nchange = inv(evaluate(predofs,shapefuns))\nlinear_combination(change,predofs) # i.e. transpose(change)*predofs\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_face_orders-Tuple{Polytope, Polytope, Int64, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_face_orders","text":"compute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nReturns a vector or a tuple with the order per direction at the face face of the polytope p when restricting the order per direction orders to this face. iface is the face id of face in the numeration restricted to the face dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T}, Polytope, Any}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_lagrangian_reffaces","text":"compute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\nReturns a tuple of length D being the number of space dimensions. The entry d+1 of this tuple contains a vector of LagrangianRefFE one for each face of dimension d on the boundary of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T}, Polytope, Any}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_monomial_basis","text":"compute_monomial_basis(::Type{T},p::Polytope,orders) where T -> MonomialBasis\n\nReturns the monomial basis of value type T and order per direction described by orders on top of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_nodes-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_nodes","text":"compute_nodes(p::Polytope,orders)\n\nWhen called\n\nnode_coords, face_own_nodes = compute_nodes(p,orders)\n\nReturns node_coords, the nodal coordinates of all the Lagrangian nodes associated with the order per direction orders, and face_own_nodes, being a vector of vectors indicating which nodes are owned by each of the faces of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_own_nodes-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_own_nodes","text":"compute_own_nodes(p::Polytope{D},orders) where D -> Vector{Point{D,Float64}}\n\nReturns the coordinates of the nodes owned by the interior of the polytope associated with a Lagrangian space with the order per direction described by orders.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_own_nodes_permutations-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_own_nodes_permutations","text":"compute_own_nodes_permutations(\n  p::Polytope, own_nodes_coordinates) -> Vector{Vector{Int}}\n\nReturns a vector of vectors with the permutations of the nodes owned by the interior of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_shapefuns-Tuple{Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_shapefuns","text":"compute_shapefuns(dofs,prebasis)\n\nHelper function used to compute the shape function basis associated with the dof basis dofs and the basis prebasis.\n\nIt is equivalent to\n\nchange = inv(evaluate(dofs,prebasis))\nlinear_combination(change,prebasis) # i.e. transpose(change)*prebasis\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.expand_cell_data-Tuple{Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.expand_cell_data","text":"\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_bounding_box-Union{Tuple{Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_bounding_box","text":"get_bounding_box(p::Polytope{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_coordinates-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_coordinates","text":"get_coordinates(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dimrange-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dimrange","text":"get_dimrange(p::Polytope,d::Integer)\n\nEquivalent to\n\nget_dimranges(p)[d+1]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dimranges-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dimranges","text":"get_dimranges(p::Polytope) -> Vector{UnitRange{Int}}\n\nGiven a polytope p it returns a vector of ranges. The entry d+1 in this vector contains the range of face ids for the faces of dimension d.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nranges = get_dimranges(SEGMENT)\nprintln(ranges)\n\n# output\nUnitRange{Int}[1:2, 3:3]\n\nFace ids for the vertices in the segment range from 1 to 2 (2 vertices), the face ids for edges in the segment range from 3 to 3 (only one edge with id 3).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_basis-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_basis","text":"get_dof_basis(reffe::ReferenceFE) -> Dof\n\nReturns the underlying dof basis encoded in a Dof object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_to_comp-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_to_comp","text":"get_dof_to_comp(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_to_node-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_to_node","text":"get_dof_to_node(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_edge_tangent-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_edge_tangent","text":"get_edge_tangent(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit tangent vectors to the polytope edges.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_extrusion-Tuple{Gridap.ReferenceFEs.ExtrusionPolytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_extrusion","text":"get_extrusion(p::ExtrusionPolytope)\n\nEquivalent to p.extrusion.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_coordinates-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_coordinates","text":"get_face_coordinates(p::Polytope)\nget_face_coordinates(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dimranges-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dimranges","text":"get_face_dimranges(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dofs-Tuple{ReferenceFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dofs","text":"get_face_dofs(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dofs-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dofs","text":"get_face_dofs(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\nReturns a vector of vector that, for each face, stores the dofids in the closure of the face.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,conf::Conformity) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity) -> Vector{Vector{Vector{Int}}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE) -> Vector{Vector{Vector{Int}}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(reffe::GenericLagrangianRefFE{GradConformity}, d::Integer) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_type-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(p::Polytope,d::Integer) -> Vector{Int}\n\nReturn a vector of integers denoting, for each face of dimension d, an index to the vector get_reffaces(Polytope{d},p)\n\nExamples\n\nGet the unique polytopes for the facets of a wedge and identify of which type each face is.\n\nusing Gridap.ReferenceFEs\n\nreffaces = get_reffaces(Polytope{2},WEDGE)\n\nface_types = get_face_type(WEDGE,2)\n\nprintln(reffaces)\nprintln(face_types)\n\n# output\nGridap.ReferenceFEs.ExtrusionPolytope{2}[TRI, QUAD]\n[1, 1, 2, 2, 2]\n\n\nThe three first facets are of type 1, i.e, QUAD, and the last ones of type 2, i.e., TRI.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_vertex_permutations-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_vertex_permutations","text":"get_face_vertex_permutations(p::Polytope)\nget_face_vertex_permutations(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(p::Polytope) -> Vector{Vector{Int}}\nget_face_vertices(p::Polytope,dim::Integer) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facedims-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facedims","text":"get_facedims(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, returns a vector indicating the dimension of each face in the polytope\n\nExamples\n\nusing Gridap.ReferenceFEs\n\ndims = get_facedims(SEGMENT)\nprintln(dims)\n\n# output\n[0, 0, 1]\n\n\nThe first two faces in the segment (the two vertices) have dimension 0 and the third face (the segment itself) has dimension 1\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_faces-Tuple{Polytope, Integer, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(p::Polytope,dimfrom::Integer,dimto::Integer) -> Vector{Vector{Int}}\n\nFor dimfrom >= dimto returns a vector that for each face of dimension dimfrom stores a vector of the ids of faces of dimension dimto on its boundary.\n\nFor dimfrom < dimto returns a vector that for each face of dimfrom stores a vector of the face ids of faces of dimension dimto that touch it.\n\nThe numerations used in this function are the ones restricted to each dimension.\n\nusing Gridap.ReferenceFEs\n\nedge_to_vertices = get_faces(QUAD,1,0)\nprintln(edge_to_vertices)\n\nvertex_to_edges_around = get_faces(QUAD,0,1)\nprintln(vertex_to_edges_around)\n\n# output\nArray{Int,1}[[1, 2], [3, 4], [1, 3], [2, 4]]\nArray{Int,1}[[1, 3], [1, 4], [2, 3], [2, 4]]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_faces-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p the function returns a vector of vectors defining the incidence relation of the faces in the polytope.\n\nEach face in the polytope receives a unique integer id. The id 1 is assigned to the first 0-face. Consecutive increasing ids are assigned to the other 0-faces, then to 1-faces, and so on. The polytope itself receives the largest id which coincides with num_faces(p). For a face id iface, get_faces(p)[iface] is a vector of face ids, corresponding to the faces that are incident with the face labeled with iface. That is, faces that are either on its boundary or the face itself. In this vector of incident face ids, faces are ordered by dimension, starting with 0-faces. Within each dimension, the labels are ordered in a consistent way with the polyope object for the face iface itself.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nfaces = get_faces(SEGMENT)\nprintln(faces)\n\n# output\nArray{Int,1}[[1], [2], [1, 2, 3]]\n\nThe constant SEGMENT is bound to a predefined instance of polytope that represents a segment. The face labels associated with a segment are [1,2,3], being 1 and 2 for the vertices and 3 for the segment itself. In this case, this function returns the vector of vectors [[1],[2],[1,2,3]] meaning that vertex 1 is incident with vertex 1 (idem for vertex 2), and that the segment (id 3) is incident with the vertices 1 and 2 and the segment itself.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facet_normal-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facet_normal","text":"get_facet_normal(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit outward normal vectors to the polytope facets.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facet_orientations-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facet_orientations","text":"get_facet_orientations(p::Polytope) -> Vector{Int}\n\nGiven a polytope p returns a vector of integers of length num_facets(p). Facets, whose vertices are ordered consistently with the outwards normal vector, receive value 1 in this vector. Otherwise, facets receive value -1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_graph-Tuple{Gridap.ReferenceFEs.GeneralPolytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_graph","text":"get_graph(p::GeneralPolytope) -> Vector{Vector{Int32}}\n\nIt returns the edge-vertex graph of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_metadata-Tuple{Gridap.ReferenceFEs.GeneralPolytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_metadata","text":"get_metadata(p::GeneralPolytope)\n\nIt return the metadata stored in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_name-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_name","text":"get_name(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_node_and_comp_to_dof-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_node_and_comp_to_dof","text":"get_node_and_comp_to_dof(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_node_coordinates-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_offset-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_offset","text":"get_offset(p::Polytope,d::Integer)\n\nEquivalent to get_offsets(p)[d+1].\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_offsets-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_offsets","text":"get_offsets(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, it returns a vector of integers. The position in the d+1 entry in this vector is the offset that transforms a face id in the global numeration in the polytope to the numeration restricted to faces to dimension d.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\noffsets = get_offsets(SEGMENT)\nprintln(offsets)\n\n# output\n[0, 2]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_dofs_permutations-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_dofs_permutations","text":"get_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_dofs_permutations-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_dofs_permutations","text":"get_own_dofs_permutations(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_nodes_permutations","text":"get_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_nodes_permutations","text":"get_own_nodes_permutations(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_polytope-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_polytope","text":"get_polytope(reffe::ReferenceFE) -> Polytope\n\nReturns the underlying polytope object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_prebasis-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_prebasis","text":"get_prebasis(reffe::ReferenceFE) -> Field\n\nReturns the underlying prebasis encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}}, Polytope}} where d","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{Polytope{d}},p::Polytope) where d -> Vector{Polytope{d}}\n\nGet a vector of the unique polytopes for the faces of dimension d.\n\nExamples\n\nGet the unique polytopes for the facets of a wedge.\n\nusing Gridap.ReferenceFEs\n\nreffaces = get_reffaces(Polytope{2},WEDGE)\n\nprintln(reffaces)\n\n# output\nGridap.ReferenceFEs.ExtrusionPolytope{2}[TRI, QUAD]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}} where d","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(\n  ::Type{ReferenceFE{d}},\n  reffe::GenericLagrangianRefFE{GradConformity}) where d -> Vector{GenericLagrangianRefFE{GradConformity,M,d}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_shapefuns-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_shapefuns","text":"get_shapefuns(reffe::ReferenceFE) -> Field\n\nReturns the basis of shape functions (i.e. the canonical basis) associated with the reference FE. The result is encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_coordinates-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(p::Polytope) -> Vector{Point{D,Float64}}\n\nGiven a polytope p return a vector of points representing containing the coordinates of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_node-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(reffe::LagrangianRefFE,conf::Conformity) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_node-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(reffe::LagrangianRefFE) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_permutations-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_permutations","text":"get_vertex_permutations(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p, returns a vector of vectors containing all admissible permutations of the polytope vertices. An admissible permutation is one such that, if the vertices of the polytope are re-labeled according to this permutation, the resulting polytope preserves the shape of the original one.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nperms = get_vertex_permutations(SEGMENT)\nprintln(perms)\n\n# output\nArray{Int,1}[[1, 2], [2, 1]]\n\n\nThe first admissible permutation for a segment is [1,2],i.e., the identity. The second one is [2,1], i.e., the first vertex is relabeled as 2 and the second vertex is relabeled as 1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_weights-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_weights","text":"get_weights(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_P-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_P","text":"is_P(reffe::GenericLagrangianRefFE{GradConformity})\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_Q-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_Q","text":"is_Q(reffe::GenericLagrangianRefFE{GradConformity})\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_S-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_S","text":"is_S(reffe::GenericLagrangianRefFE{GradConformity})\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_first_order-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_first_order","text":"is_first_order(reffe::GenericLagrangianRefFE{GradConformity}) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_n_cube-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_n_cube","text":"is_n_cube(p::Polytope) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_simplex-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_simplex","text":"is_simplex(p::Polytope) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.isactive-Tuple{Gridap.ReferenceFEs.Polyhedron, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.isactive","text":"isactive(p::GeneralPolytope,vertex::Integer) -> Bool\n\nIt returns whether a vertex is connected to any other vertex.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.next_corner!-Tuple{Vector{Vector{Int64}}, Int64, Vector{Int64}, Int64}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.next_corner!","text":"Sweep through the dim-dimensional hypercube recursively, collecting all simplices.\n\nWe represent vertices as bit patterns. In dim dimensions, the lowermost dim bits are either zero or one. Interpreted as integer, this labels the vertices of the hypercube from the origin (\"bottom\") 0 to the diagonally opposite vertex (\"top\") 2^dim-1.\n\nEach simplex contains both the bottom vertex 0 as well as the top vertex 2^dim-1. Its other vertices trace a path from the bottom to the top. The algorithm below finds all possible paths.\n\nsimplices is the accumulator where the simplices are collected.\nvertices is the current set of vertices as we sweep from the origin to the diagonally opposide vertex.\ncorner is the current corner.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_cell_dims-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::Type{<:ReferenceFE{D}}) where D\nnum_cell_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dims-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Type{<:Polytope{D}}) where D\nnum_dims(p::Polytope{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dims-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Type{<:ReferenceFE{D}}) where D\nnum_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dims-Union{Tuple{Gridap.ReferenceFEs.Quadrature{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Quadrature{D}) where D where D\nnum_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dofs-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dofs","text":"num_dofs(reffe::ReferenceFE) -> Int\n\nReturns the number of DOFs.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_edges-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(p::Polytope)\n\nReturns the number of edges in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_edges-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(p::Polytope,dim::Integer)\n\nReturns the number of faces of dimension dim in polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(p::Polytope)\n\nReturns the total number of faces in polytope p (from vertices to the polytope itself).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(reffe::ReferenceFE)\nnum_faces(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_facets-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(p::Polytope)\n\nReturns the number of facets in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_facets-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_point_dims-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::Type{<:ReferenceFE{D}}) where D\nnum_point_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_point_dims-Union{Tuple{Gridap.ReferenceFEs.Quadrature{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::Quadrature{D}) where D\nnum_point_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_points-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_points","text":"num_points(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_vertices-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(p::Polytope)\n\nReturns the number of vertices in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_vertices-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.simplexify-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(p::Polytope) -> Tuple{Vector{Vector{Int}},Polytope}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.simplexify_interior-Tuple{Gridap.ReferenceFEs.Polyhedron}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.simplexify_interior","text":"simplexify_interior(p::Polyhedron)\n\nsimplex_interior computes a simplex partition of the volume inside   the Polyhedron p.   It returns a vector of coordinates and an array of connectivitties.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.simplexify_surface-Tuple{Gridap.ReferenceFEs.Polyhedron}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.simplexify_surface","text":"simplexify_surface(p::Polyhedron)\n\nsimplex_surface computes a simplex partition of the surface bounding   the Polyhedron p.   It returns a vector of coordinates and an array of connectivitties.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_dof-Tuple{Gridap.ReferenceFEs.Dof, Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_dof","text":"test_dof(dof,field,v;cmp::Function=(==))\n\nTest that the Dof interface is properly implemented for object dof. It also checks if the object dof when evaluated at the field field returns the same value as v. Comparison is made with the comp function.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_lagrangian_reference_fe-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_lagrangian_reference_fe","text":"test_lagrangian_reference_fe(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_polytope-Union{Tuple{Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_polytope","text":"test_polytope(p::Polytope{D}; optional::Bool=false) where D\n\nFunction that stresses out the functions in the Polytope interface. It tests whether the function in the polytope interface are defined for the given object, and whether they return objects of the expected type. With optional=false (the default), only the mandatory functions are checked. With optional=true, the optional functions are also tested.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_quadrature-Union{Tuple{Gridap.ReferenceFEs.Quadrature{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_quadrature","text":"test_quadrature(q::Quadrature{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_reference_fe-Union{Tuple{ReferenceFE{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_reference_fe","text":"test_reference_fe(reffe::ReferenceFE{D}) where D\n\nTest if the methods in the ReferenceFE interface are defined for the object reffe.\n\n\n\n\n\n","category":"method"},{"location":"dev-notes/block-assemblers/#Block-Assemblers","page":"Block Assemblers","title":"Block Assemblers","text":"","category":"section"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"This file contains implementation details for block assemblers. We will first have a look at how standard sparse matrix assembly works, then compare it to block assembly.","category":"page"},{"location":"dev-notes/block-assemblers/#SparseMatrixAssemblers","page":"Block Assemblers","title":"SparseMatrixAssemblers","text":"","category":"section"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"Let's understand the main workflow for SparseMatrixAssemblers by looking at the assemble_matrix method:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"  function assemble_matrix(a::SparseMatrixAssembler,matdata)\n1   m1 = nz_counter(get_matrix_builder(a),(get_rows(a),get_cols(a)))\n2   symbolic_loop_matrix!(m1,a,matdata)\n3   m2 = nz_allocation(m1)\n4   numeric_loop_matrix!(m2,a,matdata)\n5   m3 = create_from_nz(m2)\n    return m3\n  end","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"By line number:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"We retrieve the SparseMatrixBuilder/ArrayBuilder from the assembler. This structure has information on which type of array will be allocated at the end. For instance CSR vs CSC sparse matrix storage, which type of element type the array should hold (Float64, Float32,...), etc... With this information, we create a non-zero counter object m1, which will manage the counting of sparse entries and eventually the allocation of the array.\nWe do a symbolic loop over the matrix contributions in matdata. During this loop, we save the row/col indexes of the non-zeros that will be present in the final matrix.\nWe allocate the necessary space for the nonzero entries we have counted. In the case of CSR and CSC storage types, we do not allocate the final matrix yet but rather do everything in COO format (which is more efficient for random access assembly). m2 is now an array allocator object.\nWe do a second loop over the matrix contributions in matdata, During this loop, we actually assemble the entries that will end up in the matrix.\nWe use the matrix allocator to allocate and fill the final sparse matrix.","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"So the objects involved and the overall workflow is given by","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"SparseMatrixBuilder -> ArrayCounter -> ArrayAllocator -> Array","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"The second part of the puzzle is given by the loops over the data, i.e symbolic_loop_X! and numeric_loop_X!. Both loops are quite similar, so we will focus on the numeric loop, which is implemented in the following function:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"  function numeric_loop_matrix!(A,a::SparseMatrixAssembler,matdata)\n    get_mat(a::Tuple) = a[1]\n    get_mat(a) = a\n    if LoopStyle(A) == DoNotLoop()\n      return A\n    end\n1   strategy = get_assembly_strategy(a)\n    for (cellmat,_cellidsrows,_cellidscols) in zip(matdata...)\n2     cellidsrows = map_cell_rows(strategy,_cellidsrows)\n2     cellidscols = map_cell_cols(strategy,_cellidscols)\n      @assert length(cellidscols) == length(cellidsrows)\n      if length(cellidscols) > 0\n        rows_cache = array_cache(cellidsrows)\n        cols_cache = array_cache(cellidscols)\n        mat1 = get_mat(first(cellmat))\n        rows1 = getindex!(rows_cache,cellidsrows,1)\n        cols1 = getindex!(cols_cache,cellidscols,1)\n3       add! = AddEntriesMap(+)\n3       add_cache = return_cache(add!,A,mat1,rows1,cols1)\n3       caches = add_cache, vals_cache, rows_cache, cols_cache\n3       _numeric_loop_matrix!(A,caches,cellmat,cellidsrows,cellidscols)\n      end\n    end\n    A\n  end\n\n  @noinline function _symbolic_loop_matrix!(A,caches,cell_rows,cell_cols,mat1)\n    touch_cache, rows_cache, cols_cache = caches\n    touch! = TouchEntriesMap()\n4   for cell in 1:length(cell_cols)\n4     rows = getindex!(rows_cache,cell_rows,cell)\n4     cols = getindex!(cols_cache,cell_cols,cell)\n4     vals = getindex!(vals_cache,cell_vals,cell)\n4     evaluate!(add_cache,add!,mat,vals,rows,cols)\n4   end\n  end","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"By line number:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"We retrieve the AssemblyStrategy object from the assembler. This object contains all the information necessary to map the DoF ids from our mesh to the final columns/rows of the matrix. In serial this map is almost always the identity, but in parallel it is crucial to handle ghosts and local/global indexes.\nWe use the col/row maps in strategy to map the cell DoF ids in each cell contribution to the corresponding rows/cols in the final matrix.\nWe prepare a TouchEntriesMap (symbolic loop) or AddEntriesMap (numeric loop). These maps will be executed on each cell contribution, and are the ones responsible to allocate/assemble the contributions on the array counter.\nFor each cell, we retrieve the rows, cols and values and execute the map on these. This will allocate/assemble the contributions of this cell into the counter. In the case of MultiFieldFESpaces,  the cell indices rows/cols will be VectorBlocks with as many blocks as fields the MultiFieldFESpace has and vals will be a MatrixBlock with an array of blocks of size (# blocks in rows, # blocks in cols). The TouchEntriesMap andAddEntriesMap maps are specialised on these types, and assemble all blocks into the same ArrayCounter.","category":"page"},{"location":"dev-notes/block-assemblers/#BlockSparseMatrixAssemblers","page":"Block Assemblers","title":"BlockSparseMatrixAssemblers","text":"","category":"section"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"To activate the block assemblers, we have created a new MultiFieldStyle called BlockMultiFieldStyle.  The purpose of this style is two-fold:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"It activates the block assembly automatically when calling SparseMatrixAssembler, so that the everything fits with the high-level API.\nIt manages the numbering of the cell DoFs when performing the integrals, ensuring the DoFs ids are local to each block.","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"To create a block-assembled MultiFieldFESpace, you can use the following constructor:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"mfs = BlockMultiFieldStyle()\nYb  = MultiFieldFESpace(tests;style=mfs)\nXb  = MultiFieldFESpace(trials;style=mfs)","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"By default, the final matrix and vector will have a block for each input FESpace. However, you can introduce some parameters when building your BlockMultiFieldStyle so that multiple fields are assembled in the same block (see section B).","category":"page"},{"location":"dev-notes/block-assemblers/#A)-One-to-one-Block-FESpace-correspondence","page":"Block Assemblers","title":"A) One to one Block <-> FESpace correspondence","text":"","category":"section"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"The design of BlockSparseMatrixAssemblers is quite simple: Instead of having a single SparseMatrixBuilder, ArrayCounter andArray in which we assemble the entries coming from all fields in the MultiFieldFESpace, the assembler will create one of these objects for each final block and put them in a ArrayBlock object. We will then dispatch on the ArrayBlock type so that the contributions from each field is assembled in the block we want.","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"For instance, for the nz_counter function we dispatch as follows:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"function Algebra.nz_counter(builder::MatrixBlock,axs)\n  s = size(builder)\n  rows = axs[1]\n  cols = axs[2]\n  counters = [nz_counter(builder.array[i,j],(rows[i],cols[j])) for i in 1:s[1], j in 1:s[2]]\n  return ArrayBlock(counters,fill(true,size(counters)))\nend","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"In this function, the variable builder is a MatrixBlock{<:ArrayBuilder}, which holds an array with the array builders for each final block. We then simply select the rows/cols for each of the blocks and apply the nz_counter function to the corresponding ArrayBuilder ,  then return a MatrixBlock{<:ArrayCounter} which holds the array counters for each block. Similar dispatches are provided for nz_allocation, create_from_nz, map_cell_rows and map_cell_cols.","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"We also specialise the evaluation of the TouchEntriesMap andAddEntriesMap maps when the counters are BlockArrays. For instance, let's have a look at the following function:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"# A) Default implementation for MultiFieldFESpaces\nfunction Fields.evaluate!(k::AddEntriesMap,A,v::MatrixBlock,I::VectorBlock,J::VectorBlock)\n  ni,nj = size(v.touched)\n  for j in 1:nj\n    for i in 1:ni\n      if v.touched[i,j]\n        evaluate!(cache[i,j],k,A,v.array[i,j],I.array[i],J.array[j])\n      end\n    end\n  end\nend\n\n# B) Dispatching for block assemblers\nfunction Fields.evaluate!(k::AddEntriesMap,A::MatrixBlock,v::MatrixBlock,I::VectorBlock,J::VectorBlock)\n  ni,nj = size(v.touched)\n  for j in 1:nj\n    for i in 1:ni\n      if v.touched[i,j]\n        evaluate!(cache[i,j],k,A.array[i,j],v.array[i,j],I.array[i],J.array[j])\n      end\n    end\n  end\nend","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"In the monolithic assembly of MultiFieldFESpaces, the variable A is an ArrayCounter. As you can see, all contribution blocks (coming from different fields) are assembled into the same ArrayCounter. The block-assembly counterpart will have the input A be a MatrixBlock{<:ArrayCounter}, and assembles each contribution block to it's corresponding ArrayCounter (notice the A.array[i,j]).","category":"page"},{"location":"dev-notes/block-assemblers/#B)-Assembling-multiple-FE-Fields-into-the-same-Block","page":"Block Assemblers","title":"B) Assembling multiple FE Fields into the same Block","text":"","category":"section"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"The BlockMultiFieldStyle constructor can take up to three parameters:","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"NB :: Integer, representing the number of final blocks. Then the matrix and vector will have NBxNB and NB blocks respectively.\nSB :: Tuple of integers, of length NB.  In each position, SB[ib] is the number of fields that will be assembled in that block.\nP  :: Tuple of integers, of length the number of fields. This represents a field permutation, such that the fields will be reordered as[P[1],P[2],....,P[n]].","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"Using this three parameters, one can assemble an arbitrary number of fields into any number of blocks.","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"Example: Consider we are solving an MHD problem with variables (u,p,j,q) , i.e (fluid velocity, fluid pressure, magnetic current, electric potential). Although the variables are in this specific order in the MultiFieldFESpace, we want to build a block-preconditioner that solves (u,j) together in a single block then p and q separately in two other blocks. Then we would need to assemble our system using NB=3, SB=(2,1,1) and P=(1,3,2,4). With this configuration, we will create 3 blocks. The first block will have size 2 and hold variables [P[1],P[2]] = [1,3] = [u,j]. The second block will have size 1 and hold variables [P[3]] = [2] = [p]. Finally, the third block will hold variables [P[4]] = [4] = [q].","category":"page"},{"location":"dev-notes/block-assemblers/","page":"Block Assemblers","title":"Block Assemblers","text":"In terms of implementation, everything is the same. We use ArrayBlockViews (which is a view counterpart of ArrayBlock) so that an array of NBxNB array builders / array counters can be indexed using the field indexes. This allows us to use the same dispatches as we had in part A.","category":"page"},{"location":"Helpers/","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"CurrentModule = Gridap.Helpers","category":"page"},{"location":"Helpers/#Gridap.Helpers","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"","category":"section"},{"location":"Helpers/","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"Modules = [Helpers,]","category":"page"},{"location":"Helpers/#Gridap.Helpers","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"This module provides a set of helper macros and helper functions\n\nThe exported macros are:\n\nGridapType\n@abstractmethod\n@check\nfirst_and_tail\nget_val_parameter\n@notimplemented\n@notimplementedif\nset_debug_mode\nset_performance_mode\ntfill\n@unreachable\n\n\n\n\n\n","category":"module"},{"location":"Helpers/#Gridap.Helpers.GridapType","page":"Gridap.Helpers","title":"Gridap.Helpers.GridapType","text":"abstract type GridapType end\n\n\n\n\n\n","category":"type"},{"location":"Helpers/#Gridap.Helpers.first_and_tail-Tuple{Tuple}","page":"Gridap.Helpers","title":"Gridap.Helpers.first_and_tail","text":"first_and_tail(a::Tuple)\n\nEquivalent to (first(a), Base.tail(a)).\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.get_val_parameter-Union{Tuple{Val{T}}, Tuple{T}} where T","page":"Gridap.Helpers","title":"Gridap.Helpers.get_val_parameter","text":"get_val_parameter(::Val{T}) where T\nget_val_parameter(::Type{Val{T}}) where T\n\nReturns T.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.set_debug_mode-Tuple{}","page":"Gridap.Helpers","title":"Gridap.Helpers.set_debug_mode","text":"set_debug_mode()\n\nEquivalent to set_execution_mode(\"debug\").\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.set_execution_mode-Tuple{String}","page":"Gridap.Helpers","title":"Gridap.Helpers.set_execution_mode","text":"set_execution_mode(new_mode::String)\n\nSets the execution mode to either \"debug\" or \"performance\", which controls  the behavior of the @check macro within the Gridap package.\n\nDebug mode (default): The @check macro will be active, which activates consistency checks  within the library. This mode is recommended for development and debugging purposes.\nPerformance mode: The @check macro will be deactivated. This mode is recommended for  production runs, where no errors are expected.\n\nPre-defined functions set_debug_mode and set_performance_mode are also available. Feature only available in Julia 1.6 and later due to restrictions from Preferences.jl.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.set_performance_mode-Tuple{}","page":"Gridap.Helpers","title":"Gridap.Helpers.set_performance_mode","text":"set_performance_mode()\n\nEquivalent to set_execution_mode(\"performance\").\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.tfill-Union{Tuple{D}, Tuple{Any, Val{D}}} where D","page":"Gridap.Helpers","title":"Gridap.Helpers.tfill","text":"tfill(v, ::Val{D}) where D\n\nReturns a tuple of length D that contains D times the object v. In contrast to tuple(fill(v,D)...) which returns the same result, this function is type-stable.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.@abstractmethod","page":"Gridap.Helpers","title":"Gridap.Helpers.@abstractmethod","text":"@abstractmethod\n\nMacro used in generic functions that must be overloaded by derived types.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@check","page":"Gridap.Helpers","title":"Gridap.Helpers.@check","text":"@check condition   @check condition \"Error message\"\n\nMacro used to make sure that condition is fulfilled, like @assert but the check gets deactivated when running Gridap in performance mode.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@notimplemented","page":"Gridap.Helpers","title":"Gridap.Helpers.@notimplemented","text":"@notimplemented\n@notimplemented \"Error message\"\n\nMacro used to raise an error, when something is not implemented.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@notimplementedif","page":"Gridap.Helpers","title":"Gridap.Helpers.@notimplementedif","text":"@notimplementedif condition\n@notimplementedif condition \"Error message\"\n\nMacro used to raise an error if the condition is true\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@unreachable","page":"Gridap.Helpers","title":"Gridap.Helpers.@unreachable","text":"@unreachable\n@unreachable \"Error message\"\n\nMacro used to make sure that a line of code is never reached.\n\n\n\n\n\n","category":"macro"},{"location":"#Gridap.jl","page":"Home","title":"Gridap.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation of the Gridap library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThese documentation pages are under construction.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gridap provides a set of tools for the grid-based approximation of partial differential equations (PDEs) written in the Julia programming language. The main motivation behind the development of this library is to provide an easy-to-use framework for the development of complex PDE solvers in a dynamically typed style without sacrificing the performance of statically typed languages. The library currently supports linear and nonlinear PDE systems for scalar and vector fields, single and multi-field problems, conforming and nonconforming finite element discretizations, on structured and unstructured meshes of simplices and hexahedra.","category":"page"},{"location":"#How-to-use-this-documentation","page":"Home","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step for new users is to visit the Getting Started page.\nA set of tutorials written as Jupyter notebooks and html pages are available here.\nThe detailed documentation is in the Manual section.\nGuidelines for developers of the Gridap project is found in the Gridap wiki page.","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the Gridap package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First steps to learn Julia form the Gridap wiki page.\nOfficial webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"Gridap.md\",\n  \"Helpers.md\",\n  \"Io.md\",\n  \"Algebra.md\",\n  \"Arrays.md\",\n  \"TensorValues.md\",\n  \"Fields.md\",\n  \"Polynomials.md\",\n  \"Integration.md\",\n  \"ReferenceFEs.md\",\n  \"Geometry.md\",\n  \"CellData.md\",\n  \"Visualization.md\",\n  \"FESpaces.md\",\n  \"MultiField.md\",\n  \"ODEs.md\",\n  \"Adaptivity.md\",\n  ]","category":"page"},{"location":"Geometry/","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CurrentModule = Gridap.Geometry","category":"page"},{"location":"Geometry/#Gridap.Geometry","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"","category":"section"},{"location":"Geometry/","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Modules = [Geometry,]","category":"page"},{"location":"Geometry/#Gridap.Geometry","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Exported names are\n\nAppendedTriangulation\nBodyFittedTriangulation\nBoundary\nBoundaryTriangulation\nCartesianDescriptor\nCartesianDiscreteModel\nCartesianGrid\nDiscreteModel\nDiscreteModelFromFile\nDiscreteModelPortion\nFaceLabeling\nFaceToFaceGlue\nGenericTriangulation\nGrid\nGridMock\nGridPortion\nGridTopology\nInterface\nInterfaceTriangulation\nInterior\nIrregular\nMappedDiscreteModel\nMappedGrid\nNonOriented\nOrientationStyle\nOriented\nRegular\nRegularityStyle\nSkeleton\nSkeletonPair\nSkeletonTriangulation\nTriangulation\nUnstructuredDiscreteModel\nUnstructuredGrid\nUnstructuredGridTopology\nadd_tag!\nadd_tag_from_tags!\nbest_target\ncompress_cell_data\ncompress_contributions\ncompress_ids\ncompute_cell_faces\ncompute_cell_permutations\ncompute_face_nodes\ncompute_face_own_nodes\ncompute_face_vertices\ncompute_isboundary_face\ncompute_linear_grid\ncompute_node_face_owner\ncompute_reference_grid\ncompute_reffaces\ncompute_vertex_node\nexpand_cell_data\nextend\nget_active_model\nget_background_model\nget_cartesian_descriptor\nget_cell_coordinates\nget_cell_entity\nget_cell_faces\nget_cell_map\nget_cell_node_ids\nget_cell_permutations\nget_cell_ref_coordinates\nget_cell_reffe\nget_cell_shapefuns\nget_cell_type\nget_cell_vertices\nget_face_entity\nget_face_labeling\nget_face_mask\nget_face_tag\nget_face_tag_index\nget_facet_normal\nget_glue\nget_grid\nget_grid_topology\nget_isboundary_face\nget_node_face_owner\nget_parent_model\nget_polytopes\nget_reffaces_offsets\nget_reffes\nget_tag_entities\nget_tag_from_name\nget_tag_name\nget_tags_from_names\nget_triangulation\nis_change_possible\nis_oriented\nis_regular\nmove_contributions\nnum_cells\nnum_entities\nnum_tags\npos_neg_data\ntest_discrete_model\ntest_grid\ntest_grid_topology\ntest_triangulation\n\n\n\n\n\n","category":"module"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel, AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nBoundaryTriangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel, Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tags::Vector{Int})\nBoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tags::Vector{String})\nBoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tag::Int)\nBoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,tags::Vector{Int})\nBoundaryTriangulation(model::DiscreteModel,tags::Vector{String})\nBoundaryTriangulation(model::DiscreteModel,tag::Int)\nBoundaryTriangulation(model::DiscreteModel,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"struct CartesianDescriptor{D,T,F<:Function}\n  origin::Point{D,T}\n  sizes::NTuple{D,T}\n  partition::NTuple{D,Int}\n  map::F\nend\n\nStruct that stores the data defining a Cartesian grid.\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor-Tuple{Any, Any}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"CartesianDescriptor(\n  domain,\n  partition;\n  map::Function=identity,\n  isperiodic::NTuple{D,Bool}=tfill(false,Val{D}))\n\ndomain and partition are 1D indexable collections of arbitrary type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor-Union{Tuple{D}, Tuple{VectorValue{D}, Tuple{Vararg{T, D}} where T, Any}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"CartesianDescriptor(\n  origin::Point{D},\n  sizes::NTuple{D},\n  partition;\n  map::Function=identity,\n  isperiodic::NTuple{D,Bool}=tfill(false,Val{D})) where D\n\npartition is a 1D indexable collection of arbitrary type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor-Union{Tuple{D}, Tuple{VectorValue{D}, VectorValue{D}, Any}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"CartesianDescriptor(\n  pmin::Point{D},\n  pmax::Point{D},\n  partition;\n  map::Function=identity,\n  isperiodic::NTuple{D,Bool}=tfill(false,Val{D})) where D\n\npartition is a 1D indexable collection of arbitrary type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"struct CartesianDiscreteModel{D,T,F} <: DiscreteModel{D,D}\n  # Private Fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Tuple","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(args...)\n\nSame args needed to construct a CartesianDescriptor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Union{Tuple{F}, Tuple{T}, Tuple{D}, Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}, CartesianIndex, CartesianIndex}, Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}, CartesianIndex, CartesianIndex, Any}} where {D, T, F}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(desc::CartesianDescriptor{D,T,F},                           cmin::CartesianIndex,                           cmax::CartesianIndex)\n\nBuilds a CartesianDiscreteModel object which represents a subgrid of   a (larger) grid represented by desc. This subgrid is described by its   D-dimensional minimum (cmin) and maximum (cmax) CartesianIndex   identifiers.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Union{Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}}, Tuple{F}, Tuple{T}, Tuple{D}} where {D, T, F}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(desc::CartesianDescriptor)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"struct CartesianGrid{D,T,F} <: Grid{D,D}\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid-Tuple","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"CartesianGrid(args...;kwargs...)\n\nSame args needed to construct a CartesianDescriptor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid-Union{Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}}, Tuple{F}, Tuple{T}, Tuple{D}} where {D, T, F}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"CartesianGrid(desc::CartesianDescriptor)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"abstract type DiscreteModel{Dc,Dp} <: Grid\n\nAbstract type holding information about a physical grid, the underlying grid topology, and a labeling of the grid faces. This is the information that typically provides a mesh generator, and it is what one needs to perform a simulation.\n\nThe DiscreteModel interface is defined by overloading the methods:\n\nget_grid(model::DiscreteModel)\nget_grid_topology(model::DiscreteModel)\nget_face_labeling(g::DiscreteModel)\n\nThe interface is tested with this function:\n\ntest_discrete_model\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel-Tuple{Gridap.Geometry.Grid, Gridap.Geometry.GridTopology, Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel-Union{Tuple{D}, Tuple{Type{<:Polytope{D}}, DiscreteModel}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelPortion","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelPortion-Tuple{DiscreteModel, AbstractVector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelPortion","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"struct FaceLabeling <: GridapType\n  d_to_dface_to_entity::Vector{Vector{Int32}}\n  tag_to_entities::Vector{Vector{Int32}}\n  tag_to_name::Vector{String}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling-Tuple{Vector{Int64}}","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"FaceLabeling(d_to_num_dfaces::Vector{Int})\nFaceLabeling(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"abstract type Grid{Dc,Dp}\n\nAbstract type that represents mesh of a domain of parametric dimension Dc and physical dimension Dp.\n\nThe interface of Grid is defined by overloading:\n\nget_node_coordinates(trian::Grid)\nget_cell_node_ids(trian::Grid)\nget_reffes(trian::Grid)\nget_cell_type(trian::Grid)\n\nThe Grid  interface has the following traits\n\nOrientationStyle(::Type{<:Grid})\nRegularityStyle(::Type{<:Grid})\n\nThe interface of Grid is tested with\n\ntest_grid\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.Grid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(::Type{ReferenceFE{d}},model::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, Polytope}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(::Type{ReferenceFE{d}},p::Polytope) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.GridPortion","text":"struct GridPortion{Dc,Dp,G} <: Grid{Dc,Dp}\n  parent::G\n  cell_to_parent_cell::Vector{Int32}\n  node_to_parent_node::Vector{Int32}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.GridPortion-Tuple{Gridap.Geometry.Grid, AbstractVector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.GridPortion","text":"GridPortion(parent::Grid{Dc,Dp},cell_to_parent_cell::Vector{Int32}) where {Dc,Dp}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridTopology","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"abstract type GridTopology{Dc,Dp}\n\nAbstract type representing the topological information associated with a grid.\n\nThe GridTopology interface is defined by overloading the methods:\n\nget_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\nget_polytopes(g::GridTopology)\nget_cell_type(g::GridTopology)\nget_vertex_coordinates(g::GridTopology)\n\nThe GridTopology interface has the following traits\n\nOrientationStyle(::Type{<:GridTopology})\nRegularityStyle(::Type{<:GridTopology})\n\nand tested with this function:\n\ntest_grid_topology\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.GridTopology-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"GridTopology(grid::Grid)\nGridTopology(grid::Grid, cell_to_vertices::Table, vertex_to_node::Vector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridTopology-Union{Tuple{D}, Tuple{Type{<:Polytope{D}}, DiscreteModel}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.MappedDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.MappedDiscreteModel","text":"MappedDiscreteModel\n\nRepresent a model with a MappedGrid grid. See also MappedGrid.\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.OrientationStyle-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.OrientationStyle","text":"OrientationStyle(::Type{<:GridTopology})\nOrientationStyle(::GridTopology)\n\nOriented() if has oriented faces, NonOriented() otherwise (default).\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.OrientationStyle-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.OrientationStyle","text":"OrientationStyle(::Type{<:Grid})\nOrientationStyle(::Grid)\n\nOriented() if has oriented faces, NonOriented() otherwise (default).\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.RegularityStyle-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.RegularityStyle","text":"RegularityStyle(::Type{<:GridTopology})\nRegularityStyle(::GridTopology)\n\nRegular() if no hanging-nodes default), Irregular() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.RegularityStyle-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.RegularityStyle","text":"RegularityStyle(::Type{<:Grid})\nRegularityStyle(::Grid)\n\nRegular() if no hanging-nodes default), Irregular() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.SkeletonPair","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonPair","text":"struct SkeletonPair{L,R} <: GridapType\n  plus::L\n  minus::R\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.SkeletonTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonTriangulation","text":"struct SkeletonTriangulation{Dc,Dp,B} <: Triangulation{Dc,Dp}\n  plus::B\n  minus::B\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.SkeletonTriangulation-Tuple{DiscreteModel, AbstractVector{Bool}}","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonTriangulation","text":"SkeletonTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nSkeletonTriangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Triangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.Triangulation","text":"abstract type Triangulation{Dt,Dp}\n\nA discredited physical domain associated with a DiscreteModel{Dm,Dp}.\n\nDt and Dm can be different.\n\nThe (mandatory) Triangulation interface can be tested with\n\ntest_triangulation\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"struct UnstructuredDiscreteModel{Dc,Dp,Tp,B} <: DiscreteModel{Dc,Dp}\n  grid::UnstructuredGrid{Dc,Dp,Tp,B}\n  grid_topology::UnstructuredGridTopology{Dc,Dp,Tp,B}\n  face_labeling::FaceLabeling\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"UnstructuredDiscreteModel(grid::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"struct UnstructuredGrid{Dc,Dp,Tp,Ti,O} <: Grid{Dc,Dp}\n  node_coordinates::Vector{Point{Dp,Tp}}\n  cell_node_ids::Table{Ti,Int32}\n  reffes::Vector{<:LagrangianRefFE{Dc}}\n  cell_types::Vector{Int8}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{AbstractArray{<:VectorValue}}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(x::AbstractArray{<:Point})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(grid::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(reffe::LagrangianRefFE)\n\nBuild a grid with a single cell that is the given reference FE itself\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Union{Tuple{Ti}, Tuple{Tp}, Tuple{Dp}, Tuple{Dc}, Tuple{Array{VectorValue{Dp, Tp}, 1}, Gridap.Arrays.Table{Ti, Vd} where Vd<:AbstractVector{Ti}, Vector{<:Gridap.ReferenceFEs.LagrangianRefFE{Dc}}, Vector}, Tuple{Array{VectorValue{Dp, Tp}, 1}, Gridap.Arrays.Table{Ti, Vd} where Vd<:AbstractVector{Ti}, Vector{<:Gridap.ReferenceFEs.LagrangianRefFE{Dc}}, Vector, Gridap.Geometry.OrientationStyle}, Tuple{Array{VectorValue{Dp, Tp}, 1}, Gridap.Arrays.Table{Ti, Vd} where Vd<:AbstractVector{Ti}, Vector{<:Gridap.ReferenceFEs.LagrangianRefFE{Dc}}, Vector, Gridap.Geometry.OrientationStyle, Any}} where {Dc, Dp, Tp, Ti}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"function UnstructuredGrid(\n  node_coordinates::Vector{Point{Dp,Tp}},\n  cell_node_ids::Table{Ti},\n  reffes::Vector{<:LagrangianRefFE{Dc}},\n  cell_types::Vector,\n  orientation_style::OrientationStyle=NonOriented()) where {Dc,Dp,Tp,Ti}\nend\n\nLow-level inner constructor.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, Polytope}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(::Type{ReferenceFE{d}},p::Polytope) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  d_to_dface_vertices::Vector{<:Table},\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation_style::OrientationStyle=NonOriented())\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-2","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  cell_vertices::Table,\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation_style::OrientationStyle=NonOriented())\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-3","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"struct UnstructuredGridTopology{Dc,Dp,T,O} <: GridTopology{Dc,Dp}\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Tuple{Gridap.Geometry.UnstructuredGrid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(grid::UnstructuredGrid)\n\nUnstructuredGridTopology(\n  grid::UnstructuredGrid,\n  cell_to_vertices::Table,\n  vertex_to_node::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelFromFile-Tuple{AbstractString}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelFromFile","text":"DiscreteModelFromFile(filename::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.InterfaceTriangulation-Tuple{DiscreteModel, Vector{Bool}}","page":"Gridap.Geometry","title":"Gridap.Geometry.InterfaceTriangulation","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry._find_ncube_face_neighbor_deltas-Union{Tuple{Gridap.ReferenceFEs.ExtrusionPolytope{D}}, Tuple{D}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry._find_ncube_face_neighbor_deltas","text":"findncubefaceneighbor_deltas(p::ExtrusionPolytope{D}) -> Vector{CartesianIndex}\n\nGiven an n-cube type ExtrusionPolytope{D}, returns V=Vector{CartesianIndex} with as many   entries as the number of faces in the boundary of the Polytope. For an entry facelid   in this vector, V[facelid] returns what has to be added to the CartesianIndex of a   cell in order to obtain the CartesianIndex of the cell neighbour of K across the face F   with local ID face_lid.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.add_tag!-Tuple{Gridap.Geometry.FaceLabeling, String, Vector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.add_tag!","text":"add_tag!(lab::FaceLabeling,name::String,entities::Vector{<:Integer})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.add_tag_from_tags!-Tuple{Gridap.Geometry.FaceLabeling, String, Vector{Int64}}","page":"Gridap.Geometry","title":"Gridap.Geometry.add_tag_from_tags!","text":"add_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{Int})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{String})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tag::Int)\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.best_target-Tuple{Triangulation, Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.best_target","text":"best_target(trian1::Triangulation,trian2::Triangulation)\n\nIf possible, returns a Triangulation to which CellDatum objects can be transferred    from trian1 and trian2. Can be trian1, trian2 or a new Triangulation.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_faces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_faces","text":"compute_cell_faces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_permutations-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_permutations","text":"compute_cell_permutations(top::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_permutations-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_permutations","text":"compute_cell_permutations(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_nodes","text":"compute_face_nodes(model::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_nodes","text":"compute_face_nodes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_own_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_own_nodes","text":"compute_face_own_nodes(model::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_own_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_own_nodes","text":"compute_face_own_nodes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_vertices","text":"compute_face_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_isboundary_face-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_isboundary_face","text":"compute_isboundary_face(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_isboundary_face-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_isboundary_face","text":"compute_isboundary_face(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_linear_grid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_linear_grid","text":"compute_linear_grid(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_node_face_owner-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_node_face_owner","text":"compute_node_face_owner(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reference_grid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reference_grid","text":"compute_reference_grid(p::LagrangianRefFE, nelems::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reference_grid-Tuple{Polytope, Any}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reference_grid","text":"compute_reference_grid(p::Polytope,nelems)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reference_grid-Union{Tuple{D}, Tuple{Gridap.ReferenceFEs.LagrangianRefFE{D}, Tuple{Vararg{Integer, D}}}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reference_grid","text":"compute_reference_grid(p::LagrangianRefFE, partition::NTuple{D,Integer})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}}, Gridap.Geometry.GridTopology}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(::Type{ReferenceFE{d}}, g::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_vertex_node-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_vertex_node","text":"compute_vertex_node(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cartesian_descriptor-Tuple{CartesianDiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cartesian_descriptor","text":"get_cartesian_descriptor(model::CartesianDiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cartesian_descriptor-Tuple{CartesianGrid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cartesian_descriptor","text":"get_cartesian_descriptor(grid::CartesianGrid)\n\nGet the descriptor of the Cartesian grid\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_entity-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_entity","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_faces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_faces","text":"get_cell_faces(g::GridTopology)\n\nDefaults to\n\ncompute_cell_faces(g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_map-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_map","text":"get_cell_map(trian::Grid) -> Vector{<:Field}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_node_ids-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_node_ids","text":"get_cell_node_ids(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_permutations-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_permutations","text":"get_cell_permutations(top::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_permutations-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_permutations","text":"get_cell_permutations(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_ref_coordinates-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_ref_coordinates","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_reffe-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_reffe","text":"get_cell_reffe(trian::Grid) -> Vector{<:LagrangianRefFE}\n\nIt is not desirable to iterate over the resulting array for large number of cells if the underlying reference FEs are of different Julia type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_shapefuns-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_shapefuns","text":"get_cell_shapefuns(trian::Grid) -> Vector{<:Field}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_type-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_type","text":"get_cell_type(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_type-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_type","text":"get_cell_type(trian::Grid) -> AbstractVector{<:Integer}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_vertices","text":"get_cell_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_entity-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_entity","text":"get_face_entity(lab::FaceLabeling,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_entity-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_entity","text":"get_face_entity(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_labeling-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_labeling","text":"get_face_labeling(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_mask-Tuple{Gridap.Geometry.FaceLabeling, Any, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_mask","text":"get_face_mask(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_mask(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_mask(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_mask(labeling::FaceLabeling,tag::String,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_tag-Tuple{Gridap.Geometry.FaceLabeling, Any, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_tag","text":"get_face_tag(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_tag(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_tag(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_tag(labeling::FaceLabeling,tag::String,d::Integer)\nget_face_tag(labeling::FaceLabeling,d::Integer)\n\nThe first of the given tags appearing in the face is taken. If there is no tag on a face, this face will have a value equal to UNSET. If not tag or tags are provided, all the tags in the model are considered\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_tag_index-Tuple{Gridap.Geometry.FaceLabeling, Any, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_tag_index","text":"get_face_tag_index(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tag::String,d::Integer)\n\nLike get_face_tag by provides the index into the array tags instead of the tag stored in tags.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_grid-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_grid","text":"get_grid(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_grid_topology-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_grid_topology","text":"get_grid_topology(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_isboundary_face-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_isboundary_face","text":"get_isboundary_face(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_isboundary_face-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_isboundary_face","text":"get_isboundary_face(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_node_face_owner-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_node_face_owner","text":"get_node_face_owner(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_polytopes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_polytopes","text":"get_polytopes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_polytopes-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_polytopes","text":"get_polytopes(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffaces_offsets-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffaces_offsets","text":"get_reffaces_offsets(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffaces_offsets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffaces_offsets","text":"get_reffaces_offsets(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffes-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffes","text":"get_reffes(trian::Grid) -> Vector{LagrangianRefFE}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_entities-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_entities","text":"get_tag_entities(lab::FaceLabeling,tag::Integer)\nget_tag_entities(lab::FaceLabeling,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_entities-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_entities","text":"get_tag_entities(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_from_name-Tuple{Gridap.Geometry.FaceLabeling, String}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_from_name","text":"get_tag_from_name(lab::FaceLabeling,name::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_from_name-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_from_name","text":"get_tag_from_name(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_name-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_name","text":"get_tag_name(lab::FaceLabeling,tag::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_name-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_name","text":"get_tag_name(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tags_from_names-Tuple{Gridap.Geometry.FaceLabeling, Vector{String}}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tags_from_names","text":"get_tags_from_names(lab::FaceLabeling,names::Vector{String})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_change_possible-Tuple{Triangulation, Triangulation}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_change_possible","text":"is_change_possible(strian::Triangulation,ttrian::Triangulation)\n\nReturns true if CellDatum objects can be transferred from strian to ttrian.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_oriented-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_oriented","text":"is_oriented(::Type{<:GridTopology}) -> Bool\nis_oriented(a::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_oriented-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_oriented","text":"is_oriented(::Type{<:Grid}) -> Bool\nis_oriented(a::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_regular-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_regular","text":"is_regular(::Type{<:GridTopology}) -> Bool\nis_regular(a::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_regular-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_regular","text":"is_regular(::Type{<:Grid}) -> Bool\nis_regular(a::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(trian::Grid) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_entities-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_entities","text":"num_entities(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_tags-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_tags","text":"num_tags(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.pos_neg_data-Tuple{AbstractArray, Gridap.Arrays.PosNegPartition}","page":"Gridap.Geometry","title":"Gridap.Geometry.pos_neg_data","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_discrete_model-Union{Tuple{DiscreteModel{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_discrete_model","text":"test_discrete_model(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_grid-Union{Tuple{Gridap.Geometry.Grid{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_grid","text":"test_grid(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_grid_topology-Union{Tuple{Gridap.Geometry.GridTopology{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_grid_topology","text":"test_grid_topology(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_triangulation-Union{Tuple{Triangulation{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_triangulation","text":"test_triangulation(trian::Triangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_dimrange-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_dimrange","text":"get_dimrange(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_dimranges-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_dimranges","text":"get_dimranges(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_coordinates-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_coordinates","text":"get_face_coordinates(g::GridTopology)\nget_face_coordinates(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(g::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(g::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(g::DiscreteModel,d::Integer)\n\nIndex to the vector get_reffaces(ReferenceFE{d},g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(g::GridTopology,d::Integer)\n\nBy default, it calls to compute_reffaces.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(g::GridTopology)\n\nDefaults to\n\ncompute_face_vertices(g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_facedims-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_facedims","text":"get_facedims(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_faces-Tuple{Gridap.Geometry.GridTopology, Integer, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_facet_normal-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_facet_normal","text":"get_facet_normal(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_node_coordinates-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(trian::Grid) -> AbstractArray{<:Point{Dp}}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_offset-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_offset","text":"get_offset(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_offsets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_offsets","text":"get_offsets(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}}, Gridap.Geometry.GridTopology}} where d","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\n\nBy default, it calls to compute_reffaces.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{ReferenceFE{d}},model::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_vertex_coordinates-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_vertex_node-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_first_order-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_first_order","text":"is_first_order(trian::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_n_cube-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_n_cube","text":"is_n_cube(p::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_simplex-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_simplex","text":"is_simplex(p::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::GridTopology) -> Int\nnum_cell_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Union{Tuple{Gridap.Geometry.Grid{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::Grid) -> Int\nnum_cell_dims(::Type{<:Grid}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc}}, Tuple{Dc}} where Dc","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::GridTopology) -> Int\nnum_dims(::Type{<:GridTopology}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Union{Tuple{Gridap.Geometry.Grid{Dc}}, Tuple{Dc}} where Dc","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Grid) -> Int\nnum_dims(::Type{<:Grid}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(g::DiscreteModel,d::Integer)\nnum_faces(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(lab::FaceLabeling,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(g::GridTopology,d::Integer)\nnum_faces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_nodes-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(trian::Grid) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_point_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_point_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::GridTopology) -> Int\nnum_point_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_point_dims-Union{Tuple{Gridap.Geometry.Grid{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::Grid) -> Int\nnum_point_dims(::Type{<:Grid}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.simplexify-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.simplexify-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(grid::Grid;kwargs...)\n\n\n\n\n\n","category":"method"}]
}
