var documenterSearchIndex = {"docs":
[{"location":"MultiField/","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"CurrentModule = Gridap.MultiField","category":"page"},{"location":"MultiField/#Gridap.MultiField","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"","category":"section"},{"location":"MultiField/","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"Modules = [MultiField,]","category":"page"},{"location":"MultiField/#Gridap.MultiField","page":"Gridap.MultiField","title":"Gridap.MultiField","text":"The exported names are\n\nConsecutiveMultiFieldStyle\nMultiFieldCellField\nMultiFieldFEFunction\nMultiFieldFESpace\nMultiFieldStyle\ncompute_field_offsets\ninterpolate\ninterpolate_dirichlet\ninterpolate_everywhere\nnum_fields\nrestrict_to_field\n\n\n\n\n\n","category":"module"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFEFunction","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFEFunction","text":"struct MultiFieldFEFunction <: CellField\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFESpace","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFESpace","text":"struct MultiFieldFESpace{S<:MultiFieldStyle,B} <: FESpace\n  spaces::Vector{<:SingleFieldFESpace}\n  multi_field_style::S\n  constraint_style::Val{B}\nend\n\n\n\n\n\n","category":"type"},{"location":"MultiField/#Gridap.MultiField.MultiFieldFESpace-Tuple{Vector{<:Gridap.FESpaces.SingleFieldFESpace}}","page":"Gridap.MultiField","title":"Gridap.MultiField.MultiFieldFESpace","text":"MultiFieldFESpace(spaces::Vector{<:SingleFieldFESpace})\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate-Tuple{Any, MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate","text":"The resulting MultiFieldFEFunction is in the space (in particular it fulfills Dirichlet BCs even in the case that the given cell field does not fulfill them)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate_dirichlet-Tuple{Any, MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate_dirichlet","text":"\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.FESpaces.interpolate_everywhere-Tuple{Any, MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.FESpaces.interpolate_everywhere","text":"like interpolate, but also compute new degrees of freedom for the dirichlet component. The resulting MultiFieldFEFunction does not necessary belongs to the underlying space\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.compute_field_offsets-Tuple{MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.compute_field_offsets","text":"compute_field_offsets(f::MultiFieldFESpace)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.num_fields-Tuple{Gridap.MultiField.MultiFieldFEFunction}","page":"Gridap.MultiField","title":"Gridap.MultiField.num_fields","text":"num_fields(m::MultiFieldFEFunction)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.num_fields-Tuple{MultiFieldFESpace}","page":"Gridap.MultiField","title":"Gridap.MultiField.num_fields","text":"num_fields(f::MultiFieldFESpace)\n\n\n\n\n\n","category":"method"},{"location":"MultiField/#Gridap.MultiField.restrict_to_field-Tuple{MultiFieldFESpace, AbstractVector, Integer}","page":"Gridap.MultiField","title":"Gridap.MultiField.restrict_to_field","text":"restrict_to_field(f::MultiFieldFESpace,free_values::AbstractVector,field::Integer)\n\n\n\n\n\n","category":"method"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation-requirements","page":"Getting Started","title":"Installation requirements","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Gridap is tested on Linux, but it should be also possible to use it on Mac OS and Windows since it is written exclusively in Julia and it only depends on registered Julia packages.","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Gridap is a registered package. Thus, the installation should be straight forward using the Julia's package manager Pkg. To this end, open the Julia REPL (i.e., execute the julia binary), type ] to enter package mode, and install Gridap as follows","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pkg> add Gridap","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"That's all.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For further information about how to install and manage Julia packages, see the Pkg documentation.","category":"page"},{"location":"getting-started/#Further-steps","page":"Getting Started","title":"Further steps","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"We recommend to follow the Gridap Tutorials in order to get familiar with the library.","category":"page"},{"location":"FESpaces/","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"CurrentModule = Gridap.FESpaces","category":"page"},{"location":"FESpaces/#Gridap.FESpaces","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"","category":"section"},{"location":"FESpaces/","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"Modules = [FESpaces,]","category":"page"},{"location":"FESpaces/#Gridap.FESpaces","page":"Gridap.FESpaces","title":"Gridap.FESpaces","text":"The exported names are\n\nAffineFEOperator\nAssembler\nAssemblyStrategy\nBasisStyle\nCLagrangianFESpace\nCellConformity\nCellFE\nConstrained\nConstraintStyle\nDefaultAssemblyStrategy\nDirichletFESpace\nEvaluationFunction\nFEBasis\nFEFunction\nFEOperator\nFESolver\nFESpace\nFESpaceWithConstantFixed\nFESpaceWithLinearConstraints\nFiniteElements\nGenericAssemblyStrategy\nGenericSparseMatrixAssembler\nHomogeneousTrialFESpace\nHomogeneousTrialFESpace!\nLinearFESolver\nNonlinearFESolver\nSingleFieldFEFunction\nSingleFieldFESpace\nSparseMatrixAssembler\nTestFESpace\nTrialFESpace\nTrialFESpace!\nUnConstrained\nUnconstrainedFESpace\nZeroMeanFESpace\nallocate_matrix\nallocate_matrix_and_vector\nallocate_vector\nassemble_matrix\nassemble_matrix!\nassemble_matrix_add!\nassemble_matrix_and_vector\nassemble_matrix_and_vector!\nassemble_matrix_and_vector_add!\nassemble_vector\nassemble_vector!\nassemble_vector_add!\ncol_map\ncol_mask\ncollect_cell_matrix\ncollect_cell_matrix_and_vector\ncollect_cell_vector\ncompute_cell_space\ncompute_conforming_cell_dofs\ncompute_dirichlet_values_for_tags\ncompute_dirichlet_values_for_tags!\ngather_dirichlet_values\ngather_dirichlet_values!\ngather_free_and_dirichlet_values!\ngather_free_values\ngather_free_values!\nget_algebraic_operator\nget_cell_constraints\nget_cell_dof_ids\nget_cell_dof_values\nget_cell_is_dirichlet\nget_cell_isconstrained\nget_cols\nget_dirichlet_dof_ids\nget_dirichlet_dof_tag\nget_dirichlet_dof_values\nget_dirichlet_values\nget_dof_value_type\nget_fe_basis\nget_fe_dof_basis\nget_fe_space\nget_free_dof_ids\nget_free_dof_values\nget_free_values\nget_matrix_builder\nget_matrix_type\nget_rows\nget_test\nget_trial\nget_trial_fe_basis\nget_vector_builder\nget_vector_type\nhas_constraints\ninterpolate\ninterpolate!\ninterpolate_dirichlet\ninterpolate_dirichlet!\ninterpolate_everywhere\ninterpolate_everywhere!\nnum_dirichlet_dofs\nnum_dirichlet_tags\nnum_free_dofs\nnumeric_loop_matrix!\nnumeric_loop_matrix_and_vector!\nnumeric_loop_vector!\nrow_map\nrow_mask\nscatter_free_and_dirichlet_values\nsymbolic_loop_matrix!\nsymbolic_loop_matrix_and_vector!\nsymbolic_loop_vector!\ntest_assembler\ntest_fe_function\ntest_fe_operator\ntest_fe_solver\ntest_fe_space\ntest_single_field_fe_space\ntest_sparse_matrix_assembler\nzero_dirichlet_values\nzero_free_values\n\n\n\n\n\n","category":"module"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"AffineFEOperator\n\nReprepresent a fully assembled affine (linear) finite element problem. See also FEOperator\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AffineFEOperator-Tuple{FESpace, FESpace, AbstractMatrix, AbstractVector}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AffineFEOperator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.Assembler","page":"Gridap.FESpaces","title":"Gridap.FESpaces.Assembler","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.AssemblyStrategy","page":"Gridap.FESpaces","title":"Gridap.FESpaces.AssemblyStrategy","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CellConformity","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellConformity","text":"Minimum data required to describe dof ownership. At this moment, the cell-wise ownership is compressed on cell types. This can be relaxed in the future, to have an arbitrary cell-wise dof ownership.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CellConformity-Tuple{AbstractArray{<:ReferenceFE}, Gridap.ReferenceFEs.Conformity}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellConformity","text":"Generate A CellConformity from a vector of reference fes\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.CellFE","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellFE","text":"Minimum data required to build a conforming FE space. At this moment, the some cell-wise info is compressed on cell types. This can be relaxed in the future, and have an arbitrary cell-wise data.\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.CellFE-Tuple{DiscreteModel, AbstractArray{<:ReferenceFE}, Gridap.ReferenceFEs.Conformity, Vararg{Any}}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CellFE","text":"Generate a CellFE from a vector of reference fes\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.DirichletFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.DirichletFESpace","text":"struct DirichletFESpace <: SingleFieldFESpace\n  space::SingleFieldFESpace\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FEFunction-Tuple{FESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunction","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEFunction-Tuple{Gridap.FESpaces.SingleFieldFESpace, AbstractVector, AbstractVector}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEFunction","text":"FEFunction(\n  fs::SingleFieldFESpace, free_values::AbstractVector, dirichlet_values::AbstractVector)\n\nThe resulting FEFunction will be in the space if and only if dirichlet_values are the ones provided by get_dirichlet_dof_values(fs)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FEOperator","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FEOperator","text":"abstract type FEOperator <: GridapType\n\nA FEOperator contains finite element problem, that is assembled as far as possible and ready to be solved. See also FETerm\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESolver","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.FESolver-Tuple{Gridap.Algebra.NonlinearSolver}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.FESpaceWithConstantFixed","page":"Gridap.FESpaces","title":"Gridap.FESpaces.FESpaceWithConstantFixed","text":"FESpaceWithConstantFixed(space::SingleFieldFESpace, fix_constant::Bool,\ndof_to_fix::Int=num_free_dofs(space))\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFESolver","text":"The solver that solves a LinearFEOperator\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.LinearFESolver-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.LinearFESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.NodeToDofGlue","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NodeToDofGlue","text":"struct NodeToDofGlue{T}\n  free_dof_to_node::Vector{Int32}\n  free_dof_to_comp::Vector{Int16}\n  dirichlet_dof_to_node::Vector{Int32}\n  dirichlet_dof_to_comp::Vector{Int16}\n  node_and_comp_to_dof::Vector{T}\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.NonlinearFESolver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NonlinearFESolver","text":"A general NonlinearFESolver\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.NonlinearFESolver-Tuple{}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.NonlinearFESolver","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.SingleFieldFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SingleFieldFESpace","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SparseMatrixAssembler","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SparseMatrixAssembler","text":"\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.SparseMatrixAssembler-Tuple{FESpace, FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.SparseMatrixAssembler","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.UnconstrainedFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.UnconstrainedFESpace","text":"Generic implementation of an unconstrained single-field FE space Private fields and type parameters\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ZeroMeanFESpace","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ZeroMeanFESpace","text":"struct ZeroMeanFESpace <: SingleFieldFESpace\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"FESpaces/#Gridap.FESpaces.ZeroMeanFESpace-Tuple{Gridap.FESpaces.SingleFieldFESpace, Measure}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.ZeroMeanFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Base.zero-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Base.zero","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_jacobian-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_jacobian","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_matrix-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_matrix_and_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_residual-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_residual","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.allocate_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.allocate_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.get_matrix-Tuple{AffineFEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.get_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.get_vector-Tuple{AffineFEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.get_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.jacobian!","text":"jacobian!(A, op, u)\n\n\nInplace version of jacobian.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.jacobian-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.jacobian","text":"jacobian(op, u)\n\n\nCompute the jacobian of an operator op. See also get_algebraic_operator, residual_and_jacobian!.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual!-Tuple{AbstractVector, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual!","text":"residual!(b, op, u)\n\n\nInplace version of residual.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual","text":"residual(op, u)\n\n\nCompute the residual of op at u. See also residual_and_jacobian\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual_and_jacobian!-Tuple{AbstractVector, AbstractMatrix, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual_and_jacobian!","text":"residual_and_jacobian!(b, A, op, u)\n\n\nInplace version of residual_and_jacobian.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.residual_and_jacobian-Tuple{FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.residual_and_jacobian","text":"residual, jacobian =\n\nresidual_and_jacobian(op, u)\n\n\nCompute the residual and jacobian of an operator op at a given point u. Depending on the nature of op the point u can either be a plain array or a FEFunction.\n\nSee also jacobian, residual, get_algebraic_operator.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve!-Tuple{Any, FESolver, FEOperator, Any}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve!","text":"uh, cache = solve!(uh,solver,op,cache)\n\nThis function changes the state of the input and can render it in a corrupted state. It is recommended to rewrite the input uh with the output as illustrated to prevent any issue. If cache===nothing, then it creates a new cache object.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve!-Tuple{Any, FESolver, FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve!","text":"uh, cache = solve!(uh,solver,op)\n\nThis function changes the state of the input and can render it in a corrupted state. It is recommended to rewrite the input uh with the output as illustrated to prevent any issue.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.Algebra.solve-Tuple{FESolver, FEOperator}","page":"Gridap.FESpaces","title":"Gridap.Algebra.solve","text":"Solve that allocates, and sets initial guess to zero and returns the solution\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.CLagrangianFESpace-Union{Tuple{T}, Tuple{Type{T}, Triangulation, Type, AbstractVector{<:Integer}, AbstractVector}, Tuple{Type{T}, Triangulation, Type, AbstractVector{<:Integer}, AbstractVector, Triangulation}} where T","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CLagrangianFESpace","text":"CLagrangianFESpace(\n::Type{T},\ngrid::Triangulation,\nvector_type::Type,\nnode_to_tag::AbstractVector,\ntag_to_mask::AbstractVector) where T\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.CLagrangianFESpace-Union{Tuple{T}, Tuple{Type{T}, Triangulation}, Tuple{Type{T}, Triangulation, Triangulation}} where T","page":"Gridap.FESpaces","title":"Gridap.FESpaces.CLagrangianFESpace","text":"CLagrangianFESpace(::Type{T},grid::Triangulation) where T\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TestFESpace-Tuple","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TestFESpace","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace!-Tuple{AbstractVector, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.TrialFESpace!-Tuple{TrialFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.TrialFESpace!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_add!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_add!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_and_vector!-Tuple{Any, Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_and_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_matrix_and_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_matrix_and_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector-Tuple{Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.assemble_vector_add!-Tuple{Any, Gridap.FESpaces.Assembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.assemble_vector_add!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.col_map-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.col_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.col_mask-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.col_mask","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.compute_conforming_cell_dofs","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_conforming_cell_dofs","text":"The result is the tuple\n\n(cell_dofs, nfree, ndiri, dirichlet_dof_tag, dirichlet_cells)\n\nIf dirichlet_components  is given, then get_dof_to_comp has to be defined for the reference elements in reffes.\n\n\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.compute_dirichlet_values_for_tags-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.compute_dirichlet_values_for_tags","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_dirichlet_values!-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_dirichlet_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_and_dirichlet_values!-Tuple{Any, Any, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_and_dirichlet_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_and_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_and_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_values!-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_values!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.gather_free_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.gather_free_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_algebraic_operator-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_algebraic_operator","text":"get_algebraic_operator(feop)\n\n\nReturn an \"algebraic view\" of an operator. Algebraic means, that the resulting operator acts on plain arrays, instead of FEFunctions. This can be useful for solving with external tools like NLsolve.jl. See also FEOperator.\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_assembly_strategy-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_assembly_strategy","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_dof_ids-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_dof_ids","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cell_dof_values-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cell_dof_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_cols-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_cols","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_ids-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_ids","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_tag-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_tag","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_dirichlet_dof_values-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_dirichlet_dof_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_basis-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_dof_basis-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_dof_basis","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_fe_space-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_fe_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_free_dof_ids-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_free_dof_ids","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_free_dof_values-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_free_dof_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_matrix_builder-Tuple{SparseMatrixAssembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_matrix_builder","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_rows-Tuple{Gridap.FESpaces.Assembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_rows","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_test-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_test","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_trial-Tuple{FEOperator}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_trial","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.get_vector_builder-Tuple{SparseMatrixAssembler}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.get_vector_builder","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate!-Tuple{Any, Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate","text":"The resulting FE function is in the space (in particular it fulfills Dirichlet BCs even in the case that the given cell field does not fulfill them)\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_dirichlet!-Tuple{Any, Any, Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_dirichlet!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_dirichlet-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_dirichlet","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_everywhere!-Tuple{Any, Any, Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_everywhere!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.interpolate_everywhere-Tuple{Any, Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.interpolate_everywhere","text":"like interpolate, but also compute new degrees of freedom for the dirichlet component. The resulting FEFunction does not necessary belongs to the underlying space\n\n\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_dirichlet_dofs-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_dirichlet_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_dirichlet_tags-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_dirichlet_tags","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.num_free_dofs-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.num_free_dofs","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.numeric_loop_matrix!-Tuple{Any, SparseMatrixAssembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.numeric_loop_matrix!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.numeric_loop_matrix_and_vector!-Tuple{Any, Any, SparseMatrixAssembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.numeric_loop_matrix_and_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.numeric_loop_vector!-Tuple{Any, SparseMatrixAssembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.numeric_loop_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.row_map-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.row_map","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.row_mask-Tuple{Gridap.FESpaces.AssemblyStrategy, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.row_mask","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.scatter_free_and_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace, Any, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.scatter_free_and_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.symbolic_loop_matrix!-Tuple{Any, SparseMatrixAssembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.symbolic_loop_matrix!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.symbolic_loop_matrix_and_vector!-Tuple{Any, Any, SparseMatrixAssembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.symbolic_loop_matrix_and_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.symbolic_loop_vector!-Tuple{Any, SparseMatrixAssembler, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.symbolic_loop_vector!","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_assembler-Tuple{Gridap.FESpaces.Assembler, Any, Any, Any}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_assembler","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_function-Tuple{FEFunction}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_function","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_operator-Tuple{FEOperator, Vararg{Any}}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_operator","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_solver","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_solver","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.test_fe_space-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_fe_space","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.test_single_field_fe_space","page":"Gridap.FESpaces","title":"Gridap.FESpaces.test_single_field_fe_space","text":"\n\n\n\n","category":"function"},{"location":"FESpaces/#Gridap.FESpaces.zero_dirichlet_values-Tuple{Gridap.FESpaces.SingleFieldFESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.zero_dirichlet_values","text":"\n\n\n\n","category":"method"},{"location":"FESpaces/#Gridap.FESpaces.zero_free_values-Tuple{FESpace}","page":"Gridap.FESpaces","title":"Gridap.FESpaces.zero_free_values","text":"\n\n\n\n","category":"method"},{"location":"Arrays/","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"CurrentModule = Gridap.Arrays","category":"page"},{"location":"Arrays/#Gridap.Arrays","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"","category":"section"},{"location":"Arrays/","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"Modules = [Arrays,]","category":"page"},{"location":"Arrays/#Gridap.Arrays","page":"Gridap.Arrays","title":"Gridap.Arrays","text":"This module provides:\n\nAn extension of the AbstractArray interface in order to properly deal with mutable caches.\nA mechanism to generate lazy arrays resulting from operations between arrays.\nA collection of concrete implementations of AbstractArray.\n\nThe exported names in this module are:\n\nAddEntriesMap\nAppendedArray\nBroadcasting\nCachedArray\nCachedMatrix\nCachedVector\nCompressedArray\nFilterMap\nIdentityVector\nLazyArray\nMap\nMulAddMap\nOperation\nPosNegPartition\nPosNegReindex\nReindex\nSubVector\nTable\nTouchEntriesMap\nTreeNode\nUNSET\nVectorWithEntryInserted\nVectorWithEntryRemoved\nappend_ptrs\nappend_ptrs!\nappend_tables_globally\nappend_tables_locally\narray_cache\nautodiff_array_gradient\nautodiff_array_hessian\nautodiff_array_jacobian\ncollect1d\nempty_table\nevaluate\nevaluate!\nfind_inverse_index_map\nfind_inverse_index_map!\nfind_local_index\nflatten_partition\ngenerate_data_and_ptrs\nget_array\nget_data_eltype\nget_local_item\nget_ptrs_eltype\ngetindex!\nidentity_table\ninverse_map\nlazy_append\nlazy_map\nlazy_split\nlength_to_ptrs!\npair_arrays\nprint_op_tree\nreturn_cache\nreturn_type\nreturn_value\nrewind_ptrs!\nsetsize!\nsimilar_tree_node\ntest_array\ntest_map\ntestargs\ntestitem\ntestvalue\nunpair_arrays\nâˆ‘\n\n\n\n\n\n","category":"module"},{"location":"Arrays/#Gridap.Arrays.UNSET","page":"Gridap.Arrays","title":"Gridap.Arrays.UNSET","text":"\n\n\n\n","category":"constant"},{"location":"Arrays/#Gridap.Arrays.Broadcasting","page":"Gridap.Arrays","title":"Gridap.Arrays.Broadcasting","text":"Broadcasting(f)\n\nReturns a mapping that represents the \"broadcasted\" version of the function f.\n\nExample\n\nusing Gridap.Arrays\n\na = [3,2]\nb = [2,1]\n\nbm = Broadcasting(+)\n\nc = evaluate(bm,a,b)\n\nprintln(c)\n\n# output\n[5, 3]\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedArray","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"mutable struct CachedArray{T, N, A<:AbstractArray{T, N}} <: AbstractArray{T, N}\n\nType providing a re-sizable array.\n\nThe size of a CachedArray is changed via the setsize! function.\n\nA CachedArray can be build with the constructors\n\nCachedArray(a::AbstractArray)\nCachedArray(T,N)\n\nusing Gridap.Arrays\n# Create an empty CachedArray\na = CachedArray(Float64,2)\n# Resize to new shape (2,3)\nsetsize!(a,(2,3))\nsize(a)\n# output\n(2, 3)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedArray-Tuple{Any, Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"CachedArray(T,N)\n\nConstructs an empty CachedArray of element type T and N dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedArray-Union{Tuple{A}, Tuple{N}, Tuple{T}} where {T, N, A<:AbstractArray{T, N}}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedArray","text":"CachedArray(a::AbstractArray)\n\nConstructs a CachedArray from a given array.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"const CachedMatrix{T,A} = CachedArray{T,2,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix-Tuple{AbstractMatrix}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"CachedMatrix(a)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedMatrix-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedMatrix","text":"CachedMatrix(T)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedVector","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"const CachedVector{T,A} = CachedArray{T,1,A}\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CachedVector-Tuple{AbstractVector}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"CachedVector(a)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CachedVector-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.CachedVector","text":"CachedVector(T)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.CompressedArray","page":"Gridap.Arrays","title":"Gridap.Arrays.CompressedArray","text":"struct CompressedArray{T,N,A,P} <: AbstractArray{T,N}\n  values::A\n  ptrs::P\nend\n\nType representing an array with a reduced set of values. The array is represented by a short array of values, namely the field values, and a large array of indices, namely the field ptrs. The i-th component of the resulting array is defined as values[ptrs[i]]. The type parameters A, and P are restricted to be array types by the inner constructor of this struct.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.CompressedArray-Tuple{AbstractArray, AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.CompressedArray","text":"CompressedArray(values::AbstractArray,ptrs::AbstractArray)\n\nCreates a CompressedArray object by the given arrays of values and ptrs.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.IdentityVector","page":"Gridap.Arrays","title":"Gridap.Arrays.IdentityVector","text":"\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.LazyArray","page":"Gridap.Arrays","title":"Gridap.Arrays.LazyArray","text":"Subtype of AbstractArray which is the result of lazy_map. It represents the result of lazy_mapping a Map to a set of arrays that contain the mapping arguments. This struct makes use of the cache provided by the mapping in order to compute its indices (thus allowing to prevent allocation). The array is lazy, i.e., the values are only computed on demand. It extends the AbstractArray API with two methods:\n\narray_cache(a::AbstractArray)    getindex!(cache,a::AbstractArray,i...)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Map","page":"Gridap.Arrays","title":"Gridap.Arrays.Map","text":"Abstract type representing a function (mapping) that provides a cache and an in-place evaluation for performance. This is the type to be used in the lazy_map function.\n\nDerived types must implement the following method:\n\nevaluate!(cache,k,x...)\n\nand optionally these ones:\n\nreturn_cache(k,x...)\nreturn_type(k,x...)\n\nThe mapping interface can be tested with the test_map function.\n\nNote that most of the functionality implemented in terms of this interface relies in duck typing. That is, it is not strictly needed to work with types that inherit from Map. This is specially useful in order to accommodate existing types into this framework without the need to implement a wrapper type that inherits from Map. For instance, a default implementation is available for Function objects.  However, we recommend that new types inherit from Map.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Operation","page":"Gridap.Arrays","title":"Gridap.Arrays.Operation","text":"Operation(op)\n\nRetuns the map that results after applying an operation f over a set of map(s) args. That is Operation(f)(args)(x...) is formally defined as f(map(a->a(x...),args)...).\n\nExample\n\nusing Gridap.Arrays\n\nfa(x) = x.*x\nfb(x) = sqrt.(x)\n\nx = collect(0:5)\n\nfab = Operation(fa)(fb)\nc = evaluate(fab,x)\n\nprintln(c)\n\n# output\n[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.OperationMap","page":"Gridap.Arrays","title":"Gridap.Arrays.OperationMap","text":"OperationMap(f,args)\n\nReturns a mapping that represents the result of applying the function f to the arguments in the tuple args. That is, OperationMap(f,args)(x...) is formally defined as f(map(a->a(x...),args)...)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.PosNegPartition","page":"Gridap.Arrays","title":"Gridap.Arrays.PosNegPartition","text":"struct representing a binary partition of a range of indices\n\nUsing this allows one to do a number of important optimizations when working with PosNegReindex\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.PosNegReindex","page":"Gridap.Arrays","title":"Gridap.Arrays.PosNegReindex","text":"PosNegReindex(values_pos,values_neg)\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Reindex","page":"Gridap.Arrays","title":"Gridap.Arrays.Reindex","text":"Reindex(values) -> Map\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.SubVector","page":"Gridap.Arrays","title":"Gridap.Arrays.SubVector","text":"struct SubVector{T,A<:AbstractVector{T}} <: AbstractVector{T}\n  vector::A\n  pini::Int\n  pend::Int\nend\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Table","page":"Gridap.Arrays","title":"Gridap.Arrays.Table","text":" struct Table{T,Vd<:AbstractVector{T},Vp<:AbstractVector} <: AbstractVector{Vector{T}}\n    data::Vd\n    ptrs::Vp\n end\n\nType representing a list of lists (i.e., a table) in compressed format.\n\n\n\n\n\n","category":"type"},{"location":"Arrays/#Gridap.Arrays.Table-Tuple{AbstractArray{<:AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.Table","text":"Table(a::AbstractArray{<:AbstractArray})\n\nBuild a table from a vector of vectors. If the inputs are multidimensional arrays instead of vectors, they are flattened.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_ptrs!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.append_ptrs!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_ptrs-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.append_ptrs","text":"append_ptrs(pa,pb)\n\nAppend two vectors of pointers.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_globally-Union{Tuple{Vararg{Gridap.Arrays.Table{T, Vd, Vp}}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_globally","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_locally-Tuple{Tuple{Vararg{T, N}} where {N, T}, Tuple{Vararg{T, N}} where {N, T}}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_locally","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.append_tables_locally-Tuple{Vararg{Gridap.Arrays.Table}}","page":"Gridap.Arrays","title":"Gridap.Arrays.append_tables_locally","text":"append_tables_locally(tables::Table...)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.array_cache-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.array_cache","text":"array_cache(a::AbstractArray)\n\nReturns a cache object to be used in the getindex! function. It defaults to\n\narray_cache(a::T) where T = nothing\n\nfor types T such that uses_hash(T) == Val(false), and\n\nfunction array_cache(a::T) where T\n  hash = Dict{UInt,Any}()\n  array_cache(hash,a)\nend\n\nfor types T such that uses_hash(T) == Val(true), see the uses_hash function. In the later case, the type T should implement the following signature:\n\narray_cache(hash::Dict,a::AbstractArray)\n\nwhere we pass a dictionary (i.e., a hash table) in the first argument. This hash table can be used to test if the object a has already built a cache and re-use it as follows\n\nid = objectid(a)\nif haskey(hash,id)\n  cache = hash[id] # Reuse cache\nelse\n  cache = ... # Build a new cache depending on your needs\n  hash[id] = cache # Register the cache in the hash table\nend\n\nThis mechanism is needed, e.g., to re-use intermediate results in complex lazy operation trees. In multi-threading computations, a different hash table per thread has to be used in order to avoid race conditions.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.collect1d-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.collect1d","text":"collect1d(a)\n\nEquivalent to\n\n[a[i] for in 1:length(a)]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.empty_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}","page":"Gridap.Arrays","title":"Gridap.Arrays.empty_table","text":"empty_table(::Type{T},::Type{P}, l::Integer) where {T,P}\nempty_table(l::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.evaluate!-Tuple{Any, Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.evaluate!","text":"evaluate!(cache,f,x...)\n\nApplies the mapping f at the arguments x... using the scratch data provided in the given cache object. The cache object is built with the return_cache function using arguments of the same type as in x. In general, the returned value y can share some part of its state with the cache object. If the result of two or more calls to this function need to be accessed simultaneously (e.g., in multi-threading), create and use several cache objects (e.g., one cache per thread).\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.evaluate-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.evaluate","text":"evaluate(f,x...)\n\nevaluates the mapping f at the arguments in x by creating a temporary cache internally. This functions is equivalent to\n\ncache = return_cache(f,x...)\nevaluate!(cache,f,x...)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_inverse_index_map","page":"Gridap.Arrays","title":"Gridap.Arrays.find_inverse_index_map","text":"\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.find_inverse_index_map!-Tuple{Any, Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_inverse_index_map!","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.find_local_index-Tuple{Any, Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.find_local_index","text":"find_local_index(a_to_b, b_to_la_to_a)\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.flatten_partition","page":"Gridap.Arrays","title":"Gridap.Arrays.flatten_partition","text":"flatten_partition(a_to_bs::Table,nb::Integer)\nflatten_partition(a_to_bs::Table)\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.generate_data_and_ptrs-Union{Tuple{AbstractArray{<:AbstractArray{T}}}, Tuple{T}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.generate_data_and_ptrs","text":"data, ptrs = generate_data_and_ptrs(vv)\n\nGiven a vector of vectors, compress it and return the corresponding data and and ptrs\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_array-Tuple{AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_array","text":"get_array(a::AbstractArray)\n\nReturns a.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_data_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_data_eltype","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.get_ptrs_eltype-Union{Tuple{Gridap.Arrays.Table{T, Vd, Vp}}, Tuple{Vp}, Tuple{Vd}, Tuple{T}} where {T, Vd, Vp}","page":"Gridap.Arrays","title":"Gridap.Arrays.get_ptrs_eltype","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.getindex!-Tuple{Any, AbstractArray, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.getindex!","text":"getindex!(cache,a::AbstractArray,i...)\n\nReturns the item of the array a associated with index i by (possibly) using the scratch data passed in the cache object.\n\nIt defaults to\n\ngetindex!(cache,a::AbstractArray,i...) = a[i...]\n\nAs for standard Julia arrays, the user needs to implement only one of the following signatures depending on the IndexStyle of the array.\n\ngetindex!(cache,a::AbstractArray,i::Integer)\ngetindex!(cache,a::AbstractArray{T,N},i::Vararg{Integer,N}) where {T,N}\n\nExamples\n\nIterating over an array using the getindex! function\n\nusing Gridap.Arrays\n\na = collect(10:15)\n\ncache = array_cache(a)\nfor i in eachindex(a)\n  ai = getindex!(cache,a,i)\n  println(\"$i -> $ai\")\nend\n\n# output\n1 -> 10\n2 -> 11\n3 -> 12\n4 -> 13\n5 -> 14\n6 -> 15\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.identity_table-Union{Tuple{P}, Tuple{T}, Tuple{Type{T}, Type{P}, Integer}} where {T, P}","page":"Gridap.Arrays","title":"Gridap.Arrays.identity_table","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.inverse_map-Tuple{Any}","page":"Gridap.Arrays","title":"Gridap.Arrays.inverse_map","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_append-Tuple{AbstractArray, AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_append","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_map-Tuple{Any, Type, Vararg{AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_map","text":"lazy_map(f,::Type{T},a::AbstractArray...) where T\n\nLike lazy_map(f,a::AbstractArray...), but the user provides the element type of the resulting array in order to circumvent type inference.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_map-Tuple{Any, Vararg{AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_map","text":"lazy_map(f,a::AbstractArray...) -> AbstractArray\n\nApplies the Map (or Function) f to the entries of the arrays in a (see the definition of Map).\n\nThe resulting array r is such that r[i] equals to evaluate(f,ai...) where ai is the tuple containing the i-th entry of the arrays in a (see function evaluate for more details). In other words, the resulting array is numerically equivalent to:\n\nmap( (x...)->evaluate(f,x...), a...)\n\nExamples\n\nUsing a function as mapping\n\nusing Gridap.Arrays\n\na = collect(0:5)\nb = collect(10:15)\n\nc = lazy_map(+,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\nUsing a user-defined mapping\n\nusing Gridap.Arrays\nimport Gridap.Arrays: evaluate!\n\na = collect(0:5)\nb = collect(10:15)\n\nstruct MySum <: Map end\n\nevaluate!(cache,::MySum,x,y) = x + y\n\nk = MySum()\n\nc = lazy_map(k,a,b)\n\nprintln(c)\n\n# output\n[10, 12, 14, 16, 18, 20]\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.lazy_split-Tuple{AbstractArray, Integer}","page":"Gridap.Arrays","title":"Gridap.Arrays.lazy_split","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.pair_arrays-Tuple{AbstractArray, AbstractArray}","page":"Gridap.Arrays","title":"Gridap.Arrays.pair_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.return_cache-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.return_cache","text":"return_cache(f,x...)\n\nReturns the cache needed to lazy_map mapping f with arguments of the same type as the objects in x. This function returns nothing by default, i.e., no cache.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.return_type-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.return_type","text":"return_type(f,x...)\n\nReturns the type of the result of calling mapping f with arguments of the types of the objects x.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.setsize!-Union{Tuple{N}, Tuple{T}, Tuple{Gridap.Arrays.CachedArray{T, N, A} where A<:AbstractArray{T, N}, Tuple{Vararg{Int64, N}}}} where {T, N}","page":"Gridap.Arrays","title":"Gridap.Arrays.setsize!","text":"setsize!(a, s)\n\n\nChanges the size of the CachedArray a to the size described the the tuple s. After calling setsize!, the array can store uninitialized values.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.test_array-Union{Tuple{N}, Tuple{S}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}}, Tuple{AbstractArray{T, N}, AbstractArray{S, N}, Any}} where {T, S, N}","page":"Gridap.Arrays","title":"Gridap.Arrays.test_array","text":"test_array(\n  a::AbstractArray{T,N}, b::AbstractArray{S,N},cmp=(==)) where {T,S,N}\n\nChecks if the entries in a and b are equal using the comparison function cmp. It also stresses the new methods added to the AbstractArray interface.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.test_map-Tuple{Any, Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.test_map","text":"test_map(y,f,x...;cmp=(==))\n\nFunction used to test if the mapping f has been implemented correctly. f is a Map sub-type, x is a tuple in the domain of the mapping and y is the expected result. Function cmp is used to compare the computed result with the expected one. The checks are done with the @test macro.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testargs-Tuple{Any, Vararg{Any}}","page":"Gridap.Arrays","title":"Gridap.Arrays.testargs","text":"testargs(f,x...)\n\nThe default implementation of this function is testargs(f,x...) = x. One can overload it in order to use lazy_map with 0-length array and maps with non-trivial domains.\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testitem-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Gridap.Arrays","title":"Gridap.Arrays.testitem","text":"testitem(a::AbstractArray{T}) -> Any\n\n\nReturns an arbitrary instance of eltype(a). The default returned value is the first entry in the array if length(a)>0 and testvalue(eltype(a)) if length(a)==0 See the testvalue function.\n\nExamples\n\nusing Gridap.Arrays\n\na = collect(3:10)\nai = testitem(a)\n\nb = Int[]\nbi = testitem(b)\n\n(ai, bi)\n\n# output\n(3, 0)\n\n\n\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.testvalue","page":"Gridap.Arrays","title":"Gridap.Arrays.testvalue","text":"testvalue(::Type{T}) where T\n\nReturns an arbitrary instance of type T. It defaults to zero(T) for non-array types and to an empty array for array types. It can be overloaded for new types T if zero(T) does not makes sense. This function is used to compute  testitem for 0-length arrays.\n\n\n\n\n\n","category":"function"},{"location":"Arrays/#Gridap.Arrays.unpair_arrays-Tuple{AbstractArray{<:Tuple{var\"#s58\", var\"#s57\"} where {var\"#s58\", var\"#s57\"}}}","page":"Gridap.Arrays","title":"Gridap.Arrays.unpair_arrays","text":"\n\n\n\n","category":"method"},{"location":"Arrays/#Gridap.Arrays.uses_hash-Tuple{Type{<:AbstractArray}}","page":"Gridap.Arrays","title":"Gridap.Arrays.uses_hash","text":"uses_hash(::Type{<:AbstractArray})\n\nThis function is used to specify if the type T uses the hash-based mechanism to reuse caches.  It should return either Val(true) or Val(false). It defaults to\n\nuses_hash(::Type{<:AbstractArray}) = Val(false)\n\nOnce this function is defined for the type T it can also be called on instances of T.\n\n\n\n\n\n","category":"method"},{"location":"CellData/","page":"Gridap.CellData","title":"Gridap.CellData","text":"CurrentModule = Gridap.CellData","category":"page"},{"location":"CellData/#Gridap.CellData","page":"Gridap.CellData","title":"Gridap.CellData","text":"","category":"section"},{"location":"CellData/","page":"Gridap.CellData","title":"Gridap.CellData","text":"Modules = [CellData,]","category":"page"},{"location":"CellData/#Gridap.CellData","page":"Gridap.CellData","title":"Gridap.CellData","text":"The exported names are\n\nCellDatum\nCellDof\nCellField\nCellPoint\nCellQuadrature\nCellState\nDiracDelta\nDomainContribution\nDomainStyle\nGenericCellField\nIntegrand\nInterpolable\nKDTreeSearch\nMeasure\nPhysicalDomain\nReferenceDomain\nadd_contribution!\nattach_constraints_cols\nattach_constraints_rows\nattach_dirichlet\nchange_domain\ncompute_cell_points_from_vector_of_points\ncross\ndet\ndot\ndouble_contraction\nget_cell_measure\nget_cell_points\nget_contribution\nget_data\nget_domains\nget_normal_vector\nget_physical_coordinate\nget_triangulation\ngradient\nidentity_constraints\ninner\njump\nmake_inverse_table\nmean\nnum_domains\nouter\nsymmetric_part\ntest_cell_datum\ntr\nupdate_state!\nÃ—\nâˆ‡\nâˆ‡âˆ‡\nâˆ«\nâŠ—\nâŠ™\nâ‹…\nâ‹…Â²\nâ‹…Â¹\n\n\n\n\n\n","category":"module"},{"location":"CellData/#Gridap.CellData.CellDatum","page":"Gridap.CellData","title":"Gridap.CellData.CellDatum","text":"Data associated with the cells of a Triangulation. CellDatum objects behave as if they are defined in the physical space of the triangulation. But in some cases they are implemented as reference quantities plus some transformation to the physical domain.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellDof","page":"Gridap.CellData","title":"Gridap.CellData.CellDof","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellField","page":"Gridap.CellData","title":"Gridap.CellData.CellField","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellPoint","page":"Gridap.CellData","title":"Gridap.CellData.CellPoint","text":"A single point or an array of points on the cells of a Triangulation CellField objects can be evaluated efficiently at CellPoint instances.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellQuadrature","page":"Gridap.CellData","title":"Gridap.CellData.CellQuadrature","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.CellState","page":"Gridap.CellData","title":"Gridap.CellData.CellState","text":"This can be used as a CellField as long as one evaluates it on the stored CellPoint.\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.DomainContribution","page":"Gridap.CellData","title":"Gridap.CellData.DomainContribution","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.DomainStyle","page":"Gridap.CellData","title":"Gridap.CellData.DomainStyle","text":"Trait that signals if a CellDatum type is implemented in the physical or the reference domain\n\n\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.CellData.DomainStyle-Tuple{Type{<:Gridap.CellData.CellDatum}}","page":"Gridap.CellData","title":"Gridap.CellData.DomainStyle","text":"Tell if the stored array is in the reference or physical domain\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.GenericCellField","page":"Gridap.CellData","title":"Gridap.CellData.GenericCellField","text":"\n\n\n\n","category":"type"},{"location":"CellData/#Gridap.Arrays.get_array-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.Arrays.get_array","text":"Get the raw array of cell data defined in the physical space.\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.change_domain-Tuple{Gridap.CellData.CellDatum, DomainStyle}","page":"Gridap.CellData","title":"Gridap.CellData.change_domain","text":"Change the underlying data to the target domain\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.distance-Tuple{Gridap.ReferenceFEs.ExtrusionPolytope, Gridap.Fields.Field, VectorValue}","page":"Gridap.CellData","title":"Gridap.CellData.distance","text":"dist = distance(polytope::ExtrusionPolytope,                    inv_cmap::Field,                    x::Point)\n\nCalculate distance from point x to the polytope. The polytope is given by its type and by the inverse cell map, i.e. by the map from the physical to the reference space.\n\nPositive distances are outside the polytope, negative distances are inside the polytope.\n\nThe distance is measured in an unspecified norm, currently the Lâˆž norm.\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.get_cell_points-Tuple{Triangulation}","page":"Gridap.CellData","title":"Gridap.CellData.get_cell_points","text":"\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.get_data-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.CellData.get_data","text":"Get the stored array of cell-wise data. It can be defined in the physical or the reference domain.\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.get_physical_coordinate-Tuple{Triangulation}","page":"Gridap.CellData","title":"Gridap.CellData.get_physical_coordinate","text":"get_physical_coordinate(trian::Triangulation)\n\nIn contrast to getcellmap, the returned object:\n\nis a CellField\nits gradient is the identity tensor\n\n\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.CellData.test_cell_datum-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.CellData.test_cell_datum","text":"\n\n\n\n","category":"method"},{"location":"CellData/#Gridap.Geometry.get_triangulation-Tuple{Gridap.CellData.CellDatum}","page":"Gridap.CellData","title":"Gridap.Geometry.get_triangulation","text":"Return the underlying Triangulation object\n\n\n\n\n\n","category":"method"},{"location":"Gridap/#Gridap","page":"Gridap","title":"Gridap","text":"","category":"section"},{"location":"Gridap/","page":"Gridap","title":"Gridap","text":"Gridap","category":"page"},{"location":"Gridap/#Gridap","page":"Gridap","title":"Gridap","text":"Gridap, grid-based approximation of PDEs in the Julia programming language\n\nThis module provides rich set of tools for the numerical solution of PDE, mainly based on finite element methods.\n\nThe module is structured in the following sub-modules:\n\nGridap.Helpers\nGridap.Io\nGridap.Algebra\nGridap.Arrays\nGridap.TensorValues\nGridap.Fields\nGridap.Polynomials\nGridap.ReferenceFEs\nGridap.CellData\nGridap.Geometry\nGridap.Visualization\nGridap.FESpaces\nGridap.MultiField\n\nThe exported names are:\n\nAffineFEOperator\nAffineFETerm\nBackslashSolver\nBoundary\nBoundaryTriangulation\nBroadcasting\nCartesianDiscreteModel\nCartesianGrid\nCellField\nCellQuadrature\nCellState\nDIV\nDiracDelta\nDiscreteModel\nDiscreteModelFromFile\nDomainStyle\nFEEnergy\nFEFunction\nFEOperator\nFESolver\nFESource\nFESpace\nFETerm\nFiniteElements\nGridapType\nHEX\nHEX8\nInterface\nInterfaceTriangulation\nInterior\nLUSolver\nLagrangian\nLinearFESolver\nLinearFETerm\nMeasure\nMultiFieldFESpace\nNLSolver\nNedelec\nOperation\nPYRAMID\nPhysicalDomain\nPoint\nPolytope\nQUAD\nQUAD4\nRaviartThomas\nReferenceDomain\nReferenceFE\nReindex\nSEG2\nSEGMENT\nSkeleton\nSkeletonTriangulation\nSparseMatrixAssembler\nTET\nTET4\nTRI\nTRI3\nTensorValue\nTestFESpace\nTrialFESpace\nTriangulation\nVERTEX\nVERTEX1\nVectorValue\nWEDGE\nadd_tag!\nadd_tag_from_tags!\napply\narray_cache\nassemble_matrix\nassemble_matrix_and_vector\nassemble_vector\ncell_measure\ncreatepvd\ncreatevtk\ncross\ncurl\ndet\ndiagonal_tensor\ndivergence\ndot\nevaluate\nevaluate!\nget_active_model\nget_array\nget_background_model\nget_cell_coordinates\nget_cell_dof_ids\nget_cell_dof_values\nget_cell_map\nget_cell_measure\nget_cell_points\nget_cell_ref_coordinates\nget_dirichlet_dof_ids\nget_dirichlet_dof_values\nget_dirichlet_values\nget_face_labeling\nget_fe_basis\nget_free_dof_ids\nget_free_dof_values\nget_free_values\nget_glue\nget_grid\nget_matrix\nget_normal_vector\nget_physical_coordinate\nget_trial_fe_basis\nget_triangulation\nget_vector\ngetindex!\ngradient\nhessian\ninner\nintegrate\ninterpolate\ninterpolate_dirichlet\ninterpolate_everywhere\ninv\nis_P\nis_Q\nis_S\nis_first_order\nis_n_cube\nis_simplex\njacobian\njump\nlagrangian\nlaplacian\nlazy_map\nmean\nmove_contributions\nnedelec\nnorm\nnum_cell_dims\nnum_cells\nnum_components\nnum_dims\nnum_dirichlet_dofs\nnum_dirichlet_tags\nnum_edges\nnum_entities\nnum_faces\nnum_facets\nnum_fields\nnum_free_dofs\nnum_point_dims\nnum_tags\nnum_vertices\nnumerical_setup\nnumerical_setup!\nouter\nprint_op_tree\nraviart_thomas\nrestrict\nsavepvd\nsimplexify\nsolve\nsolve!\nsymbolic_setup\nsymmetric_gradient\ntr\nupdate_state!\nwritevtk\nzero_initial_guess\nÃ—\nÎ”\nÎµ\nâˆ‡\nâˆ‡âˆ‡\nâˆ‘\nâˆ«\nâŠ—\nâŠ™\nâ‹…\n\n\n\n\n\n","category":"module"},{"location":"Algebra/","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"CurrentModule = Gridap.Algebra","category":"page"},{"location":"Algebra/#Gridap.Algebra","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"","category":"section"},{"location":"Algebra/","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"Modules = [Algebra,]","category":"page"},{"location":"Algebra/#Gridap.Algebra","page":"Gridap.Algebra","title":"Gridap.Algebra","text":"The exported names are\n\nAffineOperator\nArrayBuilder\nBackslashSolver\nDoNotLoop\nLUSolver\nLinearSolver\nLoop\nLoopStyle\nMinCPU\nMinMemory\nNLSolver\nNewtonRaphsonSolver\nNonlinearOperator\nNonlinearSolver\nNumericalSetup\nSparseMatrixBuilder\nSymbolicSetup\nadd_entries!\nadd_entry!\nallocate_coo_vectors\nallocate_in_domain\nallocate_in_range\nallocate_jacobian\nallocate_matrix\nallocate_matrix_and_vector\nallocate_residual\nallocate_residual_and_jacobian\nallocate_vector\ncopy_entries!\ncreate_from_nz\nfinalize_coo!\nget_array_type\nget_matrix\nget_vector\nhessian\nhessian!\nis_entry_stored\njacobian\njacobian!\nlength_to_ptrs!\nmuladd!\nnumerical_setup\nnumerical_setup!\nnz_allocation\nnz_counter\nnz_index\npush_coo!\nresidual\nresidual!\nresidual_and_jacobian\nresidual_and_jacobian!\nrewind_ptrs!\nsolve\nsolve!\nsparse_from_coo\nsymbolic_setup\ntest_linear_solver\ntest_nonlinear_operator\ntest_nonlinear_solver\nzero_initial_guess\n\n\n\n\n\n","category":"module"},{"location":"Algebra/#Gridap.Algebra.AffineOperator","page":"Gridap.Algebra","title":"Gridap.Algebra.AffineOperator","text":"struct AffineOperator{A<:AbstractMatrix,B<:AbstractVector} <: NonlinearOperator\n  matrix::A\n  vector::B\nend\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.BackslashSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.BackslashSolver","text":"struct BackslashSolver <: LinearSolver end\n\nWrapper of the backslash solver available in julia This is typically faster than LU for a single solve\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.LUSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.LUSolver","text":"struct LUSolver <: LinearSolver end\n\nWrapper of the LU solver available in julia\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.LinearSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.LinearSolver","text":"abstract type LinearSolver <: NonlinearSolver end\n\nsymbolic_setup(::LinearSolver,mat::AbstractMatrix)\ntest_linear_solver\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NLSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NLSolver","text":"struct NLSolver <: NonlinearSolver\n  # private fields\nend\n\nThe cache generated when using this solver has a field result that hosts the result object generated by the underlying nlsolve function. It corresponds to the most latest solve.\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NLSolver-Tuple{}","page":"Gridap.Algebra","title":"Gridap.Algebra.NLSolver","text":"NLSolver(ls::LinearSolver;kwargs...)\nNLSolver(;kwargs...)\n\nSame kwargs as in nlsolve. If ls is provided, it is not possible to use the linsolve kw-argument.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.NewtonRaphsonSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NewtonRaphsonSolver","text":"struct NewtonRaphsonSolver <:NonlinearSolver\n  # Private fields\nend\n\nVanilla Newton-Raphson method\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NonlinearOperator","page":"Gridap.Algebra","title":"Gridap.Algebra.NonlinearOperator","text":"abstract type NonlinearOperator <: GridapType end\n\nresidual!(b::AbstractVector,op::NonlinearOperator,x::AbstractVector)\njacobian!(A::AbstractMatrix,op::NonlinearOperator,x::AbstractVector)\nzero_initial_guess(op::NonlinearOperator)\nallocate_residual(op::NonlinearOperator,x::AbstractVector)\nallocate_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NonlinearSolver","page":"Gridap.Algebra","title":"Gridap.Algebra.NonlinearSolver","text":"abstract type NonlinearSolver <: GridapType end\n\nsolve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator)\nsolve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator, cache)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.NumericalSetup","page":"Gridap.Algebra","title":"Gridap.Algebra.NumericalSetup","text":"abstract type NumericalSetup <: GridapType end\n\nnumerical_setup!(::NumericalSetup,mat::AbstractMatrix)\nsolve!(x::AbstractVector,::NumericalSetup,b::AbstractVector)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.SymbolicSetup","page":"Gridap.Algebra","title":"Gridap.Algebra.SymbolicSetup","text":"abstract type SymbolicSetup <: GridapType end\n\nnumerical_setup(::SymbolicSetup,mat::AbstractMatrix)\n\n\n\n\n\n","category":"type"},{"location":"Algebra/#Gridap.Algebra.add_entries!-Tuple{Function, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entries!","text":"add_entries!(combine::Function,A,vs,is,js)\n\nAdd several entries only for positive input indices. Returns A.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.add_entry!-Tuple{Function, Vararg{Any}}","page":"Gridap.Algebra","title":"Gridap.Algebra.add_entry!","text":"add_entry!(combine::Function,A,v,i...)\nadd_entry!(A,v,i...)\n\nAdd an entry. Returns A.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_domain-Union{Tuple{V}, Tuple{Type{V}, Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_domain","text":"allocate_in_domain(::Type{V},matrix) where V\n\nAllocate a vector of type V in the domain of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_in_range-Union{Tuple{V}, Tuple{Type{V}, Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_in_range","text":"allocate_in_range(::Type{V},matrix) where V\n\nAllocate a vector of type V in the range of matrix matrix.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_jacobian","text":"allocate_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_residual","text":"allocate_residual(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_residual_and_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_residual_and_jacobian","text":"allocate_residual_and_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.allocate_vector-Union{Tuple{V}, Tuple{Type{V}, Any}} where V","page":"Gridap.Algebra","title":"Gridap.Algebra.allocate_vector","text":"allocate_vector(::Type{V},indices) where V\n\nAllocate a vector of type V indexable at the indices indices\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.copy_entries!-Tuple{Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.copy_entries!","text":"copy_entries!(a,b)\n\nCopy the entries of array b into array a. Returns a.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.finalize_coo!-Tuple{Type, Any, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.finalize_coo!","text":"finalize_coo!(::Type,I,J,V,m,n)\n\nCheck and insert diagonal entries in COO vectors if needed.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.get_matrix-Tuple{Gridap.Algebra.AffineOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.get_matrix","text":"get_matrix(operator)\n\nReturn the matrix corresponding to the assembled left hand side of the operator. This matrix incorporates all boundary conditions and constraints.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.get_vector-Tuple{Gridap.Algebra.AffineOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.get_vector","text":"get_vector(operator)\n\nReturn the vector corresponding to the assembled right hand side of the operator. This vector includes all boundary conditions and constraints.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.is_entry_stored-Tuple{Type, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.is_entry_stored","text":"is_entry_stored(::Type,i,j) -> Bool\n\nTells if the entry with coordinates [i,j] will be stored in the coo vectors.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.jacobian!-Tuple{AbstractMatrix, Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.jacobian!","text":"jacobian!(A::AbstractMatrix,op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.jacobian","text":"jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.length_to_ptrs!-Tuple{AbstractArray{<:Integer}}","page":"Gridap.Algebra","title":"Gridap.Algebra.length_to_ptrs!","text":"length_to_ptrs!(ptrs)\n\nGiven a vector of integers, mutate it from length state to pointer state.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.muladd!-Tuple{Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.muladd!","text":"muladd!(c,a,b)\n\nMatrix multiply a*b and add to result to c. Returns c.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.numerical_setup!-Tuple{Gridap.Algebra.NumericalSetup, AbstractMatrix}","page":"Gridap.Algebra","title":"Gridap.Algebra.numerical_setup!","text":"numerical_setup!(::NumericalSetup,mat::AbstractMatrix)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.numerical_setup-Tuple{Gridap.Algebra.SymbolicSetup, AbstractMatrix}","page":"Gridap.Algebra","title":"Gridap.Algebra.numerical_setup","text":"numerical_setup(::SymbolicSetup,mat::AbstractMatrix) -> NumericalSetup\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.push_coo!-Tuple{Type, Any, Any, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.push_coo!","text":"push_coo!(::Type, I,J,V,i,j,v)\n\nInserts entries in COO vectors for further building a sparse matrix of type T.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual!-Tuple{AbstractVector, Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual!","text":"residual!(b::AbstractVector,op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual","text":"residual(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual_and_jacobian!-Tuple{AbstractVector, AbstractMatrix, Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual_and_jacobian!","text":"residual_and_jacobian!(\n  b::AbstractVector, A::AbstractMatrix,\n  op::NonlinearOperator, x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.residual_and_jacobian-Tuple{Gridap.Algebra.NonlinearOperator, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.residual_and_jacobian","text":"residual_and_jacobian(op::NonlinearOperator,x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.rewind_ptrs!-Tuple{AbstractVector{<:Integer}}","page":"Gridap.Algebra","title":"Gridap.Algebra.rewind_ptrs!","text":"rewind_ptrs!(ptrs)\n\nRewind the given vector of pointers.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.LinearSolver, AbstractMatrix, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,ls::LinearSolver,A::AbstractMatrix,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.LinearSolver, Gridap.Algebra.AffineOperator, Any, Bool}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(\n  x::AbstractVector,\n  ls::LinearSolver,\n  op::AffineOperator,\n  cache,\n  newmatrix::Bool)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.NonlinearSolver, Gridap.Algebra.NonlinearOperator, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator,cache)\n\nSolve using the cache object from a previous solve.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.NonlinearSolver, Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,nls::NonlinearSolver,op::NonlinearOperator)\n\nUsage:\n\ncache = solve!(x,nls,op)\n\nThe returned cache object can be used in subsequent solves:\n\ncache = solve!(x,nls,op,cache)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve!-Tuple{AbstractVector, Gridap.Algebra.NumericalSetup, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve!","text":"solve!(x::AbstractVector,::NumericalSetup,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve-Tuple{Gridap.Algebra.LinearSolver, AbstractMatrix, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve","text":"solve(ls::LinearSolver,A::AbstractMatrix,b::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.solve-Tuple{Gridap.Algebra.NonlinearSolver, Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.solve","text":"solve(nls::NonlinearSolver,op::NonlinearOperator)\n\nCreates and uses a zero initial guess.\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.sparse_from_coo-Tuple{Type, Any, Any, Any, Any, Any}","page":"Gridap.Algebra","title":"Gridap.Algebra.sparse_from_coo","text":"sparse_from_coo(::Type,I,J,V,m,n)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.symbolic_setup-Tuple{Gridap.Algebra.LinearSolver, AbstractMatrix}","page":"Gridap.Algebra","title":"Gridap.Algebra.symbolic_setup","text":"symbolic_setup(::LinearSolver,mat::AbstractMatrix) -> SymbolicSetup\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.test_linear_solver-Tuple{Gridap.Algebra.LinearSolver, AbstractMatrix, AbstractVector, AbstractVector}","page":"Gridap.Algebra","title":"Gridap.Algebra.test_linear_solver","text":"test_linear_solver(\n  ls::LinearSolver,\n  A::AbstractMatrix,\n  b::AbstractVector,\n  x::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Algebra/#Gridap.Algebra.test_nonlinear_operator","page":"Gridap.Algebra","title":"Gridap.Algebra.test_nonlinear_operator","text":"test_nonlinear_operator(\n  op::NonlinearOperator,\n  x::AbstractVector,\n  b::AbstractVector,\n  pred=isapprox;\n  jac=nothing)\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.test_nonlinear_solver","page":"Gridap.Algebra","title":"Gridap.Algebra.test_nonlinear_solver","text":"test_nonlinear_solver(\n  nls::NonlinearSolver,\n  op::NonlinearOperator,\n  x0::AbstractVector,\n  x::AbstractVector,\n  pred::Function=isapprox)\n\n\n\n\n\n","category":"function"},{"location":"Algebra/#Gridap.Algebra.zero_initial_guess-Tuple{Gridap.Algebra.NonlinearOperator}","page":"Gridap.Algebra","title":"Gridap.Algebra.zero_initial_guess","text":"zero_initial_guess(op::NonlinearOperator)\n\n\n\n\n\n","category":"method"},{"location":"Io/","page":"Gridap.Io","title":"Gridap.Io","text":"CurrentModule = Gridap.Io","category":"page"},{"location":"Io/#Gridap.Io","page":"Gridap.Io","title":"Gridap.Io","text":"","category":"section"},{"location":"Io/","page":"Gridap.Io","title":"Gridap.Io","text":"Modules = [Io,]","category":"page"},{"location":"Io/#Gridap.Io","page":"Gridap.Io","title":"Gridap.Io","text":"The exported names in this module are:\n\nfrom_bson_file\nfrom_dict\nfrom_jld2_file\nfrom_json\nfrom_json_file\nto_bson_file\nto_dict\nto_jld2_file\nto_json\nto_json_file\n\n\n\n\n\n","category":"module"},{"location":"Io/#Gridap.Io.check_dict-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"Gridap.Io","title":"Gridap.Io.check_dict","text":"check_dict(::Type{T},dict::Dict) where T\n\nCheck validity of a dictionary dict for an object of type T. It runs succesfully if the dictionary is valid for a particular  type or throws an error in any other case.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_bson_file-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_bson_file","text":"function from_bson_file(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_dict-Union{Tuple{T}, Tuple{Type{T}, Dict}} where T","page":"Gridap.Io","title":"Gridap.Io.from_dict","text":"from_dict(::Type{T},dict::Dict) where T\n\nDe-serialize an object of type T from the dictionary dict. Values stored into this dictionary must be of any native  Julia data type (Real, Integer, String, etc.) Dictionary keys are Symbols.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_jld2_file","page":"Gridap.Io","title":"Gridap.Io.from_jld2_file","text":"function from_jld2_file(filename::AbstractString,dataset::AbstractString=\"data\")\n\nLoads an object from a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the generated JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"Io/#Gridap.Io.from_jld2_file-Union{Tuple{T}, Tuple{Type{T}, AbstractString}, Tuple{Type{T}, AbstractString, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_jld2_file","text":"function from_jld2_file(::Type{T},filename::AbstractString,dataset::AbstractString=\"data\") where T\n\nLoads an object from a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the generated JLD2 file. Checks if the returned object is of the expected Type{T}, if not return error.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_json-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_json","text":"from_json(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.from_json_file-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T","page":"Gridap.Io","title":"Gridap.Io.from_json_file","text":"from_json_file(::Type{T},s::AbstractString) where T\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_bson_file-Tuple{Any, Any}","page":"Gridap.Io","title":"Gridap.Io.to_bson_file","text":"to_bson_file(object,filename)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_dict-Tuple{Any}","page":"Gridap.Io","title":"Gridap.Io.to_dict","text":"to_dict(object) -> Dict\n\nSerialize object into a dictionary of type Dict{Symbol,Any}. Values stored into this dictionary must be of any native  Julia data type (Real, Integer, String, etc.) Dictionary keys are Symbols.\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_jld2_file","page":"Gridap.Io","title":"Gridap.Io.to_jld2_file","text":"function to_jld2_file(object,filename::AbstractString,dataset::AbstractString=\"data\")\n\nStores an object to a JLD2 file given its filename and, optionally, the dataset name. The dataset specifies the name and the root location of the data inside the JLD2 file.\n\n\n\n\n\n","category":"function"},{"location":"Io/#Gridap.Io.to_json-Tuple{Any}","page":"Gridap.Io","title":"Gridap.Io.to_json","text":"to_json(object)\n\n\n\n\n\n","category":"method"},{"location":"Io/#Gridap.Io.to_json_file-Tuple{Any, Any}","page":"Gridap.Io","title":"Gridap.Io.to_json_file","text":"to_json_file(object,filename)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"CurrentModule = Gridap.Polynomials","category":"page"},{"location":"Polynomials/#Gridap.Polynomials","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"","category":"section"},{"location":"Polynomials/","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"Modules = [Polynomials,]","category":"page"},{"location":"Polynomials/#Gridap.Polynomials","page":"Gridap.Polynomials","title":"Gridap.Polynomials","text":"This module provides a collection of multivariate polynomial bases.\n\nThe exported names are:\n\nMonomialBasis\nPCurlGradMonomialBasis\nQCurlGradMonomialBasis\nQGradMonomialBasis\nget_exponents\nget_order\nget_orders\nnum_terms\n\n\n\n\n\n","category":"module"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"struct MonomialBasis{D,T} <: AbstractVector{Monomial}\n\nType representing a basis of multivariate scalar-valued, vector-valued, or tensor-valued, iso- or aniso-tropic monomials. The fields of this struct are not public. This type fully implements the Field interface, with up to second order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}, Tuple{Type{T}, Int64, Function}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, order::Int [, filter::Function]) where {D,T}\n\nReturns an instance of MonomialBasis representing a multivariate polynomial basis in D dimensions, of polynomial degree order, whose value is represented by the type T. The type T is typically <:Number, e.g., Float64 for scalar-valued functions and VectorValue{D,Float64} for vector-valued ones.\n\nFilter function\n\nThe filter function is used to select which terms of the tensor product space of order order in D dimensions are to be used. If the filter is not provided, the full tensor-product space is used by default leading to a multivariate polynomial space of type Q. The signature of the filter function is\n\n(e,order) -> Bool\n\nwhere e is a tuple of D integers containing the exponents of a multivariate monomial. The following filters are used to select well known polynomial spaces\n\nQ space: (e,order) -> true\nP space: (e,order) -> sum(e) <= order\n\"Serendipity\" space: (e,order) -> sum( [ i for i in e if i>1 ] ) <= order\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.MonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Tuple{Vararg{Int64, D}}}, Tuple{Type{T}, Tuple{Vararg{Int64, D}}, Function}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.MonomialBasis","text":"MonomialBasis{D}(::Type{T}, orders::Tuple [, filter::Function]) where {D,T}\n\nThis version of the constructor allows to pass a tuple orders containing the polynomial order to be used in each of the D dimensions in order to  construct an anisotropic tensor-product space.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.PCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.PCurlGradMonomialBasis","text":"struct PCurlGradMonomialBasis{...} <: AbstractArray{Monomial}\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on simplices. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.PCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.PCurlGradMonomialBasis","text":"PCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a PCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the divergence of the  functions in this basis is in the P space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.QCurlGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QCurlGradMonomialBasis","text":"struct QCurlGradMonomialBasis{...} <: AbstractArray{Monomial}\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Raviart-Thomas reference elements on n-cubes. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.QCurlGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QCurlGradMonomialBasis","text":"QCurlGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QCurlGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the divergence of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.QGradMonomialBasis","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QGradMonomialBasis","text":"struct QGradMonomialBasis{...} <: AbstractVector{Monomial}\n\nThis type implements a multivariate vector-valued polynomial basis spanning the space needed for Nedelec reference elements on n-cubes. The type parameters and fields of this struct are not public. This type fully implements the Field interface, with up to first order derivatives.\n\n\n\n\n\n","category":"type"},{"location":"Polynomials/#Gridap.Polynomials.QGradMonomialBasis-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, Int64}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.QGradMonomialBasis","text":"QGradMonomialBasis{D}(::Type{T},order::Int) where {D,T}\n\nReturns a QGradMonomialBasis object. D is the dimension of the coordinate space and T is the type of the components in the vector-value. The order argument has the following meaning: the curl of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Arrays.return_type-Union{Tuple{Gridap.Polynomials.MonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Arrays.return_type","text":"\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_exponents-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_exponents","text":"get_exponents(b::MonomialBasis)\n\nGet a vector of tuples with the exponents of all the terms in the monomial basis.\n\nExamples\n\nusing Gridap.Polynomials\n\nb = MonomialBasis{2}(Float64,2)\n\nexponents = get_exponents(b)\n\nprintln(exponents)\n\n# output\nTuple{Int,Int}[(0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1), (0, 2), (1, 2), (2, 2)]\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_order-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_order","text":"get_order(b::MonomialBasis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.get_orders-Tuple{Gridap.Polynomials.MonomialBasis}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.get_orders","text":"get_orders(b::MonomialBasis)\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.PCurlGradMonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::PCurlGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.QCurlGradMonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::QCurlGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"Polynomials/#Gridap.Polynomials.num_terms-Union{Tuple{Gridap.Polynomials.QGradMonomialBasis{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.Polynomials","title":"Gridap.Polynomials.num_terms","text":"num_terms(f::QGradMonomialBasis{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"TensorValues/","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"CurrentModule = Gridap.TensorValues","category":"page"},{"location":"TensorValues/#Gridap.TensorValues","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"","category":"section"},{"location":"TensorValues/","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"Modules = [TensorValues,]","category":"page"},{"location":"TensorValues/#Gridap.TensorValues","page":"Gridap.TensorValues","title":"Gridap.TensorValues","text":"This module provides concrete implementations of Number that represent 1st, 2nd and general order tensors.\n\nWhy\n\nThe main feature of this module is that the provided types do not extend from AbstractArray, but from Number!\n\nThis allows one to work with them as if they were scalar values in broadcasted operations on arrays of VectorValue objects (also for TensorValue or MultiValue objects). For instance, one can perform the following manipulations:\n\n# Assing a VectorValue to all the entries of an Array of VectorValues\nA = zeros(VectorValue{2,Int}, (4,5))\nv = VectorValue(12,31)\nA .= v # This is posible since  VectorValue <: Number\n\n# Broadcasting of tensor operations in arrays of TensorValues\nt = TensorValue(13,41,53,17) # creates a 2x2 TensorValue\ng = TensorValue(32,41,3,14) # creates another 2x2 TensorValue\nB = fill(t,(1,5))\nC = inner.(g,B) # inner product of g against all TensorValues in the array B\n@show C\n# C = [2494 2494 2494 2494 2494]\n\nThe exported names are:\n\nMultiValue\nMutable\nSymFourthOrderTensorValue\nSymTensorValue\nTensorValue\nThirdOrderTensorValue\nVectorValue\nchange_eltype\ncross\ndata_index\ndet\ndiagonal_tensor\ndot\ndouble_contraction\ninner\ninv\nmeas\nmutable\nn_components\nnorm\nnum_components\nouter\nsymmetric_part\ntr\nÃ—\nâŠ—\nâŠ™\nâ‹…\nâ‹…Â²\nâ‹…Â¹\n\n\n\n\n\n","category":"module"},{"location":"TensorValues/#Gridap.TensorValues.MultiValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.MultiValue","text":"Type representing a multi-dimensional value\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.SymFourthOrderTensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.SymFourthOrderTensorValue","text":"Type representing a symmetric fourth-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.SymTensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.SymTensorValue","text":"Type representing a symmetric second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.TensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.TensorValue","text":"Type representing a second-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.ThirdOrderTensorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.ThirdOrderTensorValue","text":"Type representing a third-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.VectorValue","page":"Gridap.TensorValues","title":"Gridap.TensorValues.VectorValue","text":"Type representing a first-order tensor\n\n\n\n\n\n","category":"type"},{"location":"TensorValues/#Gridap.TensorValues.meas-Union{Tuple{Gridap.TensorValues.MultiValue{Tuple{D}}}, Tuple{D}} where D","page":"Gridap.TensorValues","title":"Gridap.TensorValues.meas","text":"\n\n\n\n","category":"method"},{"location":"TensorValues/#Gridap.TensorValues.outer-Tuple{Number, Number}","page":"Gridap.TensorValues","title":"Gridap.TensorValues.outer","text":"\n\n\n\n","category":"method"},{"location":"TensorValues/#Gridap.TensorValues.symmetric_part-Union{Tuple{Gridap.TensorValues.MultiValue{Tuple{D, D}}}, Tuple{D}} where D","page":"Gridap.TensorValues","title":"Gridap.TensorValues.symmetric_part","text":"\n\n\n\n","category":"method"},{"location":"Fields/","page":"Gridap.Fields","title":"Gridap.Fields","text":"CurrentModule = Gridap.Fields","category":"page"},{"location":"Fields/#Gridap.Fields","page":"Gridap.Fields","title":"Gridap.Fields","text":"","category":"section"},{"location":"Fields/","page":"Gridap.Fields","title":"Gridap.Fields","text":"Modules = [Fields,]","category":"page"},{"location":"Fields/#Gridap.Fields.AffineMap","page":"Gridap.Fields","title":"Gridap.Fields.AffineMap","text":"A Field with this form y = xâ‹…G + y0\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.BroadcastOpFieldArray","page":"Gridap.Fields","title":"Gridap.Fields.BroadcastOpFieldArray","text":"Type that represents a broadcast operation over a set of AbstractArray{<:Field}. The result is a sub-type of AbstractArray{<:Field}\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.Field","page":"Gridap.Fields","title":"Gridap.Fields.Field","text":"abstract type Field <: Map\n\nAbstract type representing a physical (scalar, vector, or tensor) field. The domain is a Point and the range a scalar (i.e., a sub-type of Julia Number), a VectorValue, or a TensorValue.\n\nThese different cases are distinguished by the return value obtained when evaluating them. E.g., a physical field returns a vector of values when evaluated at a vector of points, and a basis of nf fields returns a 2d matrix (np x nf) when evaluated at a vector of np points.\n\nThe following functions (i.e., the Map API) need to be overloaded:\n\nevaluate!(cache,f,x)\nreturn_cache(f,x)\n\nand optionally\n\nreturn_type(f,x)\n\nA Field can also provide its gradient if the following function is implemented\n\ngradient(f)\n\nHigher derivatives can be obtained if the resulting object also implements this method.\n\nThe next paragraph is out-of-date:\n\nMoreover, if the gradient(f) is not provided, a default implementation that uses the following functions will be used.\n\nevaluate_gradient!(cache,f,x)\nreturn_gradient_cache(f,x)\n\nHigher order derivatives require the implementation of\n\nevaluate_hessian!(cache,f,x)\nreturn_hessian_cache(f,x)\n\nThese four methods are only designed to be called by the default implementation of field_gradient(f) and thus cannot be assumed that they are available for an arbitrary field. For this reason, these functions are not exported. The general way of evaluating a gradient of a field is to build the gradient with gradient(f) and evaluating the resulting object. For evaluating the hessian, use two times gradient.\n\nThe interface can be tested with\n\ntest_field\n\nFor performance, the user can also consider a vectorised version of the Field API that evaluates the field in a vector of points (instead of only one point). E.g., the evaluate! function for a vector of points returns a vector of scalar, vector or tensor values.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.FieldGradient","page":"Gridap.Fields","title":"Gridap.Fields.FieldGradient","text":"Type that represents the gradient of a field. The wrapped field must implement evaluate_gradient! and return_gradient_cache for this gradient to work.\n\nN is how many times the gradient is applied\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.FieldGradientArray","page":"Gridap.Fields","title":"Gridap.Fields.FieldGradientArray","text":"A wrapper that represents the broadcast of gradient over an array of fields. Ng is the number of times the gradient is applyed\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.GenericField","page":"Gridap.Fields","title":"Gridap.Fields.GenericField","text":"A wrapper for objects that can act as fields, e.g., functions which implement the Field API.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.OperationField","page":"Gridap.Fields","title":"Gridap.Fields.OperationField","text":"A Field that is obtained as a given operation over a tuple of fields.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.Point","page":"Gridap.Fields","title":"Gridap.Fields.Point","text":"const Point{D,T} = VectorValue{D,T}\n\nType representing a point of D dimensions with coordinates of type T. Fields are evaluated at vectors of Point objects.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.TransposeFieldIndices","page":"Gridap.Fields","title":"Gridap.Fields.TransposeFieldIndices","text":"Given a matrix np x nf1 x nf2 result of the evaluation of a field vector on a vector of points, it returns an array in which the field axes (second and third axes) are permuted. It is equivalent as Base.permutedims(A,(1,3,2)) but more performant, since it does not involve allocations.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Gridap.Fields.ZeroField","page":"Gridap.Fields","title":"Gridap.Fields.ZeroField","text":"It represents 0.0*f for a field f.\n\n\n\n\n\n","category":"type"},{"location":"Fields/#Base.:âˆ˜-Tuple{Gridap.Fields.Field, Gridap.Fields.Field}","page":"Gridap.Fields","title":"Base.:âˆ˜","text":"fâˆ˜g\n\nIt returns the composition of two fields, which is just Operation(f)(g)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Arrays.evaluate!-Union{Tuple{T}, Tuple{Any, AbstractArray{T}, VectorValue}} where T<:Gridap.Fields.Field","page":"Gridap.Fields","title":"Gridap.Arrays.evaluate!","text":"Implementation of return_cache for a array of Field.\n\nIf the field vector has length nf and it is evaluated in one point, it returns an nf vector with the result. If the same array is applied to a vector of np points, it returns a matrix np x nf.\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.DIV-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.DIV","text":"DIV(f)\nReference space divergence\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.curl-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.curl","text":"curl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.divergence-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.divergence","text":"divergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.grad2curl-Tuple{TensorValue{2}}","page":"Gridap.Fields","title":"Gridap.Fields.grad2curl","text":"grad2curl(âˆ‡f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.gradient_type-Union{Tuple{T}, Tuple{Type{T}, VectorValue}} where T","page":"Gridap.Fields","title":"Gridap.Fields.gradient_type","text":"gradient_type(::Type{T},x::Point) where T\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{AbstractArray{<:Gridap.Fields.Field}, AbstractVector{<:VectorValue}, AbstractVector{<:Real}, Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given array of fields in the \"reference\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{AbstractArray{<:Gridap.Fields.Field}, AbstractVector{<:VectorValue}, AbstractVector{<:Real}}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given array of fields in the \"physical\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{Gridap.Fields.Field, AbstractVector{<:VectorValue}, AbstractVector{<:Real}, Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given field in the \"reference\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.integrate-Tuple{Gridap.Fields.Field, AbstractVector{<:VectorValue}, AbstractVector{<:Real}}","page":"Gridap.Fields","title":"Gridap.Fields.integrate","text":"Integration of a given field in the \"physical\" space\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.laplacian-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.laplacian","text":"laplacian(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.symmetric_gradient-Tuple{Any}","page":"Gridap.Fields","title":"Gridap.Fields.symmetric_gradient","text":"symmetric_gradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.Fields.test_field","page":"Gridap.Fields","title":"Gridap.Fields.test_field","text":"test_field(\n  f::Union{Field,AbstractArray{<:Field}},\n  x,\n  v,\n  cmp=(==);\n  grad=nothing,\n  gradgrad=nothing)\n\nFunction used to test the field interface. v is an array containing the expected result of evaluating the field f at the point or vector of points x. The comparison is performed using the cmp function. For fields objects that support the gradient function, the keyword argument grad can be used. It should contain the result of evaluating gradient(f) at x. Idem for gradgrad. The checks are performed with the @test macro.\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.Fields.Î”","page":"Gridap.Fields","title":"Gridap.Fields.Î”","text":"const Î” = laplacian\n\nAlias for the laplacian function\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.Fields.Îµ","page":"Gridap.Fields","title":"Gridap.Fields.Îµ","text":"const Îµ = symmetric_gradient\n\nAlias for the symmetric gradient\n\n\n\n\n\n","category":"function"},{"location":"Fields/#Gridap.TensorValues.outer-Tuple{Gridap.Fields.Field, typeof(gradient)}","page":"Gridap.Fields","title":"Gridap.TensorValues.outer","text":"outer(f,âˆ‡)\n\nEquivalent to\n\ntranspose(gradient(f))\n\n\n\n\n\n","category":"method"},{"location":"Fields/#Gridap.TensorValues.outer-Tuple{typeof(gradient), Gridap.Fields.Field}","page":"Gridap.Fields","title":"Gridap.TensorValues.outer","text":"outer(âˆ‡,f)\n\nEquivalent to\n\ngradient(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.cross-Tuple{typeof(gradient), Gridap.Fields.Field}","page":"Gridap.Fields","title":"LinearAlgebra.cross","text":"cross(âˆ‡,f)\n\nEquivalent to\n\ncurl(f)\n\n\n\n\n\n","category":"method"},{"location":"Fields/#LinearAlgebra.dot-Tuple{typeof(gradient), Gridap.Fields.Field}","page":"Gridap.Fields","title":"LinearAlgebra.dot","text":"âˆ‡â‹…f\n\nEquivalent to\n\ndivergence(f)\n\n\n\n\n\n","category":"method"},{"location":"Visualization/","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"CurrentModule = Gridap.Visualization","category":"page"},{"location":"Visualization/#Gridap.Visualization","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"","category":"section"},{"location":"Visualization/","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"Modules = [Visualization,]","category":"page"},{"location":"Visualization/#Gridap.Visualization","page":"Gridap.Visualization","title":"Gridap.Visualization","text":"The exported names are\n\nVisualizationData\ncreatepvd\ncreatevtk\nsavepvd\nvisualization_data\nwrite_vtk_file\nwritevtk\n\n\n\n\n\n","category":"module"},{"location":"Visualization/#Gridap.Visualization.create_vtk_file-Tuple{Gridap.Geometry.Grid, Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.create_vtk_file","text":"create_vtk_file(\n  trian::Grid,\n  filebase;\n  celldata=Dict(),\n  nodaldata=Dict())\n\nLow level entry point to vtk. Other vtk-related routines in Gridap eventually call this one. This function only creates the vtkFile, without writing to disk.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.createpvd-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.createpvd","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.createvtk-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.createvtk","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.get_vtkid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Visualization","title":"Gridap.Visualization.get_vtkid","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.get_vtknodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Visualization","title":"Gridap.Visualization.get_vtknodes","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.savepvd-Tuple{WriteVTK.CollectionFile}","page":"Gridap.Visualization","title":"Gridap.Visualization.savepvd","text":"\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.visualization_data-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.visualization_data","text":"This function returns an iterable collection (e.g. a Vector) of VisualizationData objects\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.write_vtk_file-Tuple{Gridap.Geometry.Grid, Any}","page":"Gridap.Visualization","title":"Gridap.Visualization.write_vtk_file","text":"write_vtk_file(\n  trian::Grid,\n  filebase;\n  celldata=Dict(),\n  nodaldata=Dict())\n\nLow level entry point to vtk. Other vtk-related routines in Gridap eventually call this one.\n\n\n\n\n\n","category":"method"},{"location":"Visualization/#Gridap.Visualization.writevtk-Tuple","page":"Gridap.Visualization","title":"Gridap.Visualization.writevtk","text":"\n\n\n\n","category":"method"},{"location":"ReferenceFEs/","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"CurrentModule = Gridap.ReferenceFEs","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"","category":"section"},{"location":"ReferenceFEs/","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"Modules = [ReferenceFEs,]","category":"page"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs","text":"The exported names are\n\nBezier\nBezierRefFE\nCDConformity\nCONT\nConformity\nContraVariantPiolaMap\nCurlConformity\nDISC\nDivConformity\nDof\nExtrusionPolytope\nGenericLagrangianRefFE\nGenericQuadrature\nGenericRefFE\nGradConformity\nH1Conformity\nHEX\nHEX8\nHEX_AXIS\nINVALID_PERM\nL2Conformity\nLagrangian\nLagrangianDofBasis\nLagrangianRefFE\nMomentBasedDofBasis\nNedelec\nNedelecRefFE\nPYRAMID\nPolytope\nQUAD\nQUAD4\nQuadrature\nQuadratureName\nRaviartThomas\nRaviartThomasRefFE\nReferenceFE\nReferenceFEName\nSEG2\nSEGMENT\nSerendipityRefFE\nTET\nTET4\nTET_AXIS\nTRI\nTRI3\nVERTEX\nVERTEX1\nWEDGE\nbezier\ncompress_cell_data\ncompute_face_orders\ncompute_lagrangian_reffaces\ncompute_monomial_basis\ncompute_nodes\ncompute_own_nodes\ncompute_own_nodes_permutations\ncompute_shapefuns\nduffy\nevaluate!\nevaluate_dof\nexpand_cell_data\nget_bounding_box\nget_coordinates\nget_dimrange\nget_dimranges\nget_dof_basis\nget_dof_to_comp\nget_dof_to_node\nget_edge_tangent\nget_extrusion\nget_face_coordinates\nget_face_dimranges\nget_face_dofs\nget_face_moments\nget_face_nodes\nget_face_nodes_dofs\nget_face_own_dofs\nget_face_own_dofs_permutations\nget_face_own_nodes\nget_face_own_nodes_permutations\nget_face_type\nget_face_vertex_permutations\nget_face_vertices\nget_facedims\nget_faces\nget_facet_normal\nget_facet_orientations\nget_name\nget_node_and_comp_to_dof\nget_node_coordinates\nget_nodes\nget_offset\nget_offsets\nget_order\nget_orders\nget_own_dofs_permutations\nget_own_nodes_permutations\nget_polytope\nget_prebasis\nget_reffaces\nget_shapefuns\nget_vertex_coordinates\nget_vertex_node\nget_vertex_permutations\nget_weights\nis_P\nis_Q\nis_S\nis_first_order\nis_n_cube\nis_simplex\nlagrangian\nnedelec\nnum_cell_dims\nnum_dims\nnum_dofs\nnum_edges\nnum_faces\nnum_facets\nnum_nodes\nnum_point_dims\nnum_points\nnum_vertices\nraviart_thomas\nreturn_cache\nreturn_type\nsimplexify\nstrang\ntensor_product\ntest_dof\ntest_dof_array\ntest_lagrangian_reference_fe\ntest_polytope\ntest_quadrature\ntest_reference_fe\n\n\n\n\n\n","category":"module"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX","text":"const HEX = Polytope(HEX_AXIS,HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX8","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX8","text":"const HEX8 = LagrangianRefFE(Float64,HEX,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.HEX_AXIS","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.HEX_AXIS","text":"Constant to be used in order to indicate a hex-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.INVALID_PERM","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.INVALID_PERM","text":"Constant of type Int  used to signal that a permutation is not valid.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.PYRAMID","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.PYRAMID","text":"const PYRAMID = Polytope(HEX_AXIS,HEX_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.QUAD","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.QUAD","text":"const QUAD = Polytope(HEX_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.QUAD4","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.QUAD4","text":"const QUAD4 = LagrangianRefFE(Float64,QUAD,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SEG2","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SEG2","text":"const SEG2 = LagrangianRefFE(Float64,SEGMENT,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SEGMENT","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SEGMENT","text":"const SEGMENT = Polytope(HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET","text":"const TET = Polytope(TET_AXIS,TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET4","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET4","text":"const TET4 = LagrangianRefFE(Float64,TET,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TET_AXIS","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TET_AXIS","text":"Constant to be used in order to indicate a tet-like extrusion axis.\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TRI","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TRI","text":"const TRI = Polytope(TET_AXIS,TET_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.TRI3","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.TRI3","text":"const TRI3 = LagrangianRefFE(Float64,TRI,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.VERTEX","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.VERTEX","text":"const VERTEX = Polytope()\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.VERTEX1","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.VERTEX1","text":"const VERTEX1 = LagrangianRefFE(Float64,VERTEX,1)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.WEDGE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.WEDGE","text":"const WEDGE = Polytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\n\n\n\n\n","category":"constant"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Conformity-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Conformity","text":"Conformity(reffe::ReferenceFE) -> Conformity\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ExtrusionPolytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ExtrusionPolytope","text":"struct ExtrusionPolytope{D} <: Polytope{D}\n  extrusion::Point{D,Int}\n  # + private fields\nend\n\nConcrete type for polytopes that can be represented with an \"extrusion\" tuple. The underlying extrusion is available in the field extrusion. Instances of this type can be obtained with the constructors\n\nPolytope(extrusion::Int...)\nExtrusionPolytope(extrusion::Int...)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ExtrusionPolytope-Tuple{Vararg{Int64}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ExtrusionPolytope","text":"ExtrusionPolytope(extrusion::Int...)\n\nGenerates an ExtrusionPolytope from the tuple extrusion. The values in extrusion are either equal to the constant HEX_AXIS or the constant TET_AXIS.\n\nExamples\n\nCreating a quadrilateral, a triangle, and a wedge\n\nusing Gridap.ReferenceFEs\n\nquad = ExtrusionPolytope(HEX_AXIS,HEX_AXIS)\n\ntri = ExtrusionPolytope(TET_AXIS,TET_AXIS)\n\nwedge = ExtrusionPolytope(TET_AXIS,TET_AXIS,HEX_AXIS)\n\nprintln(quad == QUAD)\nprintln(tri == TRI)\nprintln(wedge == WEDGE)\n\n# output\ntrue\ntrue\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericLagrangianRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericLagrangianRefFE","text":"struct GenericLagrangianRefFE{C,D} <: LagrangianRefFE{D}     reffe::GenericRefFE{C,D}     face_nodes::Vector{Vector{Int}}   end\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericQuadrature","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericQuadrature","text":"struct GenericQuadrature{D,T} <: Quadrature{D,T}\n  coordinates::Vector{Point{D,T}}\n  weights::Vector{T}\nend\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericRefFE","text":"struct GenericRefFE{T,D} <: ReferenceFE{D}\n  # + private fields\nend\n\nThis type is a materialization of the ReferenceFE interface. That is, it is a struct that stores the values of all abstract methods in the ReferenceFE interface. This type is useful to build reference FEs from the underlying ingredients without the need to create a new type.\n\nNote that some fields in this struct are type unstable deliberately in order to simplify the type signature. Don't access them in computationally expensive functions, instead extract the required fields before and pass them to the computationally expensive function.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.GenericRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Int64, Polytope{D}, AbstractVector{<:Gridap.Fields.Field}, AbstractVector{<:Gridap.ReferenceFEs.Dof}, Gridap.ReferenceFEs.Conformity, Any, Vector{Vector{Int64}}}, Tuple{Int64, Polytope{D}, AbstractVector{<:Gridap.Fields.Field}, AbstractVector{<:Gridap.ReferenceFEs.Dof}, Gridap.ReferenceFEs.Conformity, Any, Vector{Vector{Int64}}, AbstractVector{<:Gridap.Fields.Field}}} where {T, D}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.GenericRefFE","text":"  GenericRefFE{T}(\n  ndofs::Int,\n  polytope::Polytope{D},\n  prebasis::AbstractVector{<:Field},\n  dofs::AbstractVector{<:Dof},\n  conformity::Conformity,\n  metadata,\n  face_dofs::Vector{Vector{Int}},\n  shapefuns::AbstractVector{<:Field}=compute_shapefuns(dofs,prebasis)) where {T,D}\n\nConstructs a GenericRefFE object with the provided data.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianDofBasis","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianDofBasis","text":"struct LagrangianDofBasis{P,V} <: AbstractArray{<:Dof}\n  nodes::Vector{P}\n  dof_to_node::Vector{Int}\n  dof_to_comp::Vector{Int}\n  node_and_comp_to_dof::Vector{V}\nend\n\nType that implements a Lagrangian dof basis.\n\nFields:\n\nnodes::Vector{P} vector of points (P<:Point) storing the nodal coordinates\nnode_and_comp_to_dof::Vector{V} vector such that node_and_comp_to_dof[node][comp] returns the dof associated with node node and the component comp in the type V.\ndof_to_node::Vector{Int} vector of integers such that dof_to_node[dof] returns the node id associated with dof id dof.\ndof_to_comp::Vector{Int} vector of integers such that dof_to_comp[dof] returns the component id associated with dof id dof.\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianDofBasis-Union{Tuple{T}, Tuple{Type{T}, Vector{<:VectorValue}}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianDofBasis","text":"LagrangianDofBasis(::Type{T},nodes::Vector{<:Point}) where T\n\nCreates a LagrangianDofBasis for fields of value type T associated with the vector of nodal coordinates nodes.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianRefFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianRefFE","text":"abstract type LagrangianRefFE{D} <: ReferenceFE{D}\n\nAbstract type representing a Lagrangian reference FE. Lagrangian in the sense that get_dof_basis returns an instance of LagrangianDofBasis. The interface for this type is defined with the methods of ReferenceFE plus the following ones\n\nget_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity)\nget_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\nget_face_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.LagrangianRefFE-Union{Tuple{D}, Tuple{T}, Tuple{Type{T}, Polytope{D}, Any}} where {T, D}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.LagrangianRefFE","text":"LagrangianRefFE(::Type{T},p::Polytope,orders) where T\nLagrangianRefFE(::Type{T},p::Polytope,order::Int) where T\n\nBuilds a LagrangianRefFE object on top of the given polytope. T is the type of the value of the approximation space (e.g., T=Float64 for scalar-valued problems, T=VectorValue{N,Float64} for vector-valued problems with N components). The arguments order or orders are for the polynomial order of the resulting space, which allows isotropic or anisotropic orders respectively (provided that the cell topology allows the given anisotropic order). The argument orders should be an indexable collection of D integers (e.g., a tuple or a vector), being D the number of space dimensions.\n\nIn order to be able to use this function, the type of the provided polytope p has to implement the following additional methods. They have been implemented for ExtrusionPolytope in the library. They need to be implemented for new polytope types in order to build Lagangian reference elements on top of them.\n\ncompute_monomial_basis(::Type{T},p::Polytope,orders) where T\ncompute_own_nodes(p::Polytope,orders)\ncompute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nThe following methods are also used in the construction of the LagrangianRefFE object. A default implementation of them is available in terms of the three previous methods. However, the user can also implement them for new polytope types increasing customization possibilities.\n\ncompute_nodes(p::Polytope,orders)\ncompute_own_nodes_permutations(p::Polytope, interior_nodes)\ncompute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"abstract type Polytope{D} <: GridapType\n\nAbstract type representing a polytope (i.e., a polyhedron in arbitrary dimensions). D is the environment dimension (typically, 0, 1, 2, or 3). This type parameter is needed since there are functions in the Polytope interface that return containers with Point{D} objects. We adopt the usual nomenclature for polytope-related objects. All objects in a polytope (from vertices to the polytope itself) are called n-faces or simply faces. The notation n-faces is used only when it is needed to refer to the object dimension n. Otherwise we simply use face. In addition, we say\n\nvertex (pl. vertices): for 0-faces\nedge: for 1-faces\nfacet: for (D-1)-faces\n\nThe Polytope interface is defined by overloading the following functions\n\nget_faces(p::Polytope)\nget_dimranges(p::Polytope)\nPolytope{N}(p::Polytope,faceid::Integer) where N\nget_vertex_coordinates(p::Polytope)\n(==)(a::Polytope{D},b::Polytope{D}) where D\n\nAnd optionally these ones:\n\nget_edge_tangent(p::Polytope)\nget_facet_normal(p::Polytope)\nget_facet_orientations(p::Polytope)\nget_vertex_permutations(p::Polytope)\nis_n_cube(p::Polytope)\nis_simplex(p::Polytope)\nsimplexify(p::Polytope)\n\nThe interface can be tested with the function\n\ntest_polytope\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope-Tuple{Vararg{Int64}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"Polytope(extrusion::Int...)\n\nEquivalent to ExtrusionPolytope(extrusion...)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Polytope-Union{Tuple{D}, Tuple{Polytope, Integer}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Polytope","text":"Polytope{N}(p::Polytope,faceid::Integer) where N\n\nReturns a Polytope{N} object representing the \"reference\" polytope of the N-face with id faceid. The value faceid refers to the numeration restricted to the dimension N (it starts with 1 for the first N-face).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Quadrature","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Quadrature","text":"abstract type Quadrature{D,T} <: GridapType end\n\n-get_coordinates(q::Quadrature) -get_weights(q::Quadrature) -test_quadrature\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.Quadrature-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.Quadrature","text":"Quadrature(polytope::Polytope{D},degree) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ReferenceFE","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ReferenceFE","text":"abstract type ReferenceFE{D} <: GridapType\n\nAbstract type representing a Reference finite element. D is the underlying coordinate space dimension. We follow the Ciarlet definition. A reference finite element is defined by a polytope (cell topology), a basis of an interpolation space of top of this polytope (denoted here as the prebasis), and a basis of the dual of this space (i.e. the degrees of freedom). From this information one can compute the shape functions (i.e, the canonical basis of w.r.t. the degrees of freedom) with a simple change of basis. In addition, we also encode in this type information about how the interpolation space in a reference finite element is \"glued\" with neighbors in order to build conforming cell-wise spaces.\n\nThe ReferenceFE interface is defined by overloading these methods:\n\nnum_dofs(reffe::ReferenceFE)\nget_polytope(reffe::ReferenceFE)\nget_prebasis(reffe::ReferenceFE)\nget_dof_basis(reffe::ReferenceFE)\nConformity(reffe::ReferenceFE)\nget_face_own_dofs(reffe::ReferenceFE,conf::Conformity)\nget_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity)\nget_face_dofs(reffe::ReferenceFE)\n\nThe interface is tested with\n\ntest_reference_fe(reffe::ReferenceFE)\n\n\n\n\n\n","category":"type"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.ReferenceFE-Union{Tuple{N}, Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}, Integer}} where N","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.ReferenceFE","text":"ReferenceFE{N}(reffe::GenericLagrangianRefFE{GradConformity},iface::Integer) where N\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{Gridap.ReferenceFEs.LagrangianRefFE{D}, Gridap.ReferenceFEs.LagrangianRefFE{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::LagrangianRefFE{D}, b::LagrangianRefFE{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Base.:==-Union{Tuple{D}, Tuple{Polytope{D}, Polytope{D}}} where D","page":"Gridap.ReferenceFEs","title":"Base.:==","text":"(==)(a::Polytope{D},b::Polytope{D}) where D\n\nReturns true if the polytopes a and b are equivalent. Otherwise, it returns false. Note that the operator == returns false by default for polytopes of different dimensions. Thus, this function has to be overloaded only for the case of polytopes a and b of same dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Polynomials.get_order-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.Polynomials.get_order","text":"get_order(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.Polynomials.get_orders-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.Polynomials.get_orders","text":"get_orders(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.NedelecRefFE-Union{Tuple{et}, Tuple{Type{et}, Polytope, Integer}} where et","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.NedelecRefFE","text":"NedelecRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the curl of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.RaviartThomasRefFE-Union{Tuple{et}, Tuple{Type{et}, Polytope, Integer}} where et","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.RaviartThomasRefFE","text":"RaviartThomasRefFE(::Type{et},p::Polytope,order::Integer) where et\n\nThe order argument has the following meaning: the divergence of the  functions in this basis is in the Q space of degree order.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.SerendipityRefFE-Union{Tuple{T}, Tuple{Type{T}, Polytope, Int64}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.SerendipityRefFE","text":"SerendipityRefFE(::Type{T},p::Polytope,order::Int) where T\nSerendipityRefFE(::Type{T},p::Polytope,orders::Tuple) where T\n\nReturns an instance of LagrangianRefFE, whose underlying approximation space is the serendipity space of order order. Implemented for order from 1 to 4. The type of the polytope p has to implement all the queries detailed in the constructor LagrangianRefFE(::Type{T},p::Polytope{D},orders) where {T,D}.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\norder = 2\nreffe = SerendipityRefFE(Float64,QUAD,order)\n\nprintln( num_dofs(reffe) )\n\n# output\n8\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_face_orders-Tuple{Polytope, Polytope, Int64, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_face_orders","text":"compute_face_orders(p::Polytope,face::Polytope,iface::Int,orders)\n\nReturns a vector or a tuple with the order per direction at the face face of the polytope p when restricting the order per direction orders to this face. iface is the face id of face in the numeration restricted to the face dimension.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_lagrangian_reffaces-Union{Tuple{T}, Tuple{Type{T}, Polytope, Any}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_lagrangian_reffaces","text":"compute_lagrangian_reffaces(::Type{T},p::Polytope,orders) where T\n\nReturns a tuple of length D being the number of space dimensions. The entry d+1 of this tuple contains a vector of LagrangianRefFE one for each face of dimension d on the boundary of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_monomial_basis-Union{Tuple{T}, Tuple{Type{T}, Polytope, Any}} where T","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_monomial_basis","text":"compute_monomial_basis(::Type{T},p::Polytope,orders) where T -> MonomialBasis\n\nReturns the monomial basis of value type T and order per direction described by orders on top of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_nodes-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_nodes","text":"compute_nodes(p::Polytope,orders)\n\nWhen called\n\nnode_coords, face_own_nodes = compute_nodes(p,orders)\n\nReturns node_coords, the nodal coordinates of all the Lagrangian nodes associated with the order per direction orders, and face_own_nodes, being a vector of vectors indicating which nodes are owned by each of the faces of the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_own_nodes-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_own_nodes","text":"compute_own_nodes(p::Polytope{D},orders) where D -> Vector{Point{D,Float64}}\n\nReturns the coordinates of the nodes owned by the interior of the polytope associated with a Lagrangian space with the order per direction described by orders.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_own_nodes_permutations-Tuple{Polytope, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_own_nodes_permutations","text":"compute_own_nodes_permutations(\n  p::Polytope, own_nodes_coordinates) -> Vector{Vector{Int}}\n\nReturns a vector of vectors with the permutations of the nodes owned by the interior of the polytope.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.compute_shapefuns-Tuple{Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.compute_shapefuns","text":"compute_shapefuns(dofs,prebasis)\n\nHelper function used to compute the shape function basis associated with the dof basis dofs and the basis prebasis.\n\nIt is equivalent to\n\nchange = inv(evaluate(dofs,prebasis))\nlinear_combination(change,prebasis) # i.e. transpose(change)*prebasis\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.expand_cell_data-Tuple{Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.expand_cell_data","text":"\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_bounding_box-Union{Tuple{Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_bounding_box","text":"get_bounding_box(p::Polytope{D}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_coordinates-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_coordinates","text":"get_coordinates(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dimrange-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dimrange","text":"get_dimrange(p::Polytope,d::Integer)\n\nEquivalent to\n\nget_dimranges(p)[d+1]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dimranges-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dimranges","text":"get_dimranges(p::Polytope) -> Vector{UnitRange{Int}}\n\nGiven a polytope p it returns a vector of ranges. The entry d+1 in this vector contains the range of face ids for the faces of dimension d.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nranges = get_dimranges(SEGMENT)\nprintln(ranges)\n\n# output\nUnitRange{Int}[1:2, 3:3]\n\nFace ids for the vertices in the segment range from 1 to 2 (2 vertices), the face ids for edges in the segment range from 3 to 3 (only one edge with id 3).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_basis-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_basis","text":"get_dof_basis(reffe::ReferenceFE) -> Dof\n\nReturns the underlying dof basis encoded in a Dof object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_to_comp-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_to_comp","text":"get_dof_to_comp(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_dof_to_node-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_dof_to_node","text":"get_dof_to_node(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_edge_tangent-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_edge_tangent","text":"get_edge_tangent(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit tangent vectors to the polytope edges.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_extrusion-Tuple{Gridap.ReferenceFEs.ExtrusionPolytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_extrusion","text":"get_extrusion(p::ExtrusionPolytope)\n\nEquivalent to p.extrusion.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_coordinates-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_coordinates","text":"get_face_coordinates(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dimranges-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dimranges","text":"get_face_dimranges(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dofs-Tuple{ReferenceFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dofs","text":"get_face_dofs(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_dofs-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_dofs","text":"get_face_dofs(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\nReturns a vector of vector that, for each face, stores the dofids in the closure of the face.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,conf::Conformity) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs","text":"get_face_own_dofs(reffe::ReferenceFE) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity) -> Vector{Vector{Vector{Int}}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_dofs_permutations-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_dofs_permutations","text":"get_face_own_dofs_permutations(reffe::ReferenceFE) -> Vector{Vector{Vector{Int}}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_own_nodes_permutations","text":"get_face_own_nodes_permutations(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(reffe::GenericLagrangianRefFE{GradConformity}, d::Integer) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_type-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(p::Polytope,d::Integer) -> Vector{Int}\n\nReturn a vector of integers denoting, for each face of dimension d, an index to the vector get_reffaces(Polytope{d},p)\n\nExamples\n\nGet the unique polytopes for the facets of a wedge and identify of which type each face is.\n\nusing Gridap.ReferenceFEs\n\nreffaces = get_reffaces(Polytope{2},WEDGE)\n\nface_types = get_face_type(WEDGE,2)\n\nprintln(reffaces)\nprintln(face_types)\n\n# output\nGridap.ReferenceFEs.ExtrusionPolytope{2}[TRI, QUAD]\n[1, 1, 2, 2, 2]\n\n\nThe three first facets are of type 1, i.e, QUAD, and the last ones of type 2, i.e., TRI.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_vertex_permutations-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_vertex_permutations","text":"get_face_vertex_permutations(p::Polytope)\nget_face_vertex_permutations(p::Polytope,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(p::Polytope) -> Vector{Vector{Int}}\nget_face_vertices(p::Polytope,dim::Integer) -> Vector{Vector{Int}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facedims-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facedims","text":"get_facedims(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, returns a vector indicating the dimension of each face in the polytope\n\nExamples\n\nusing Gridap.ReferenceFEs\n\ndims = get_facedims(SEGMENT)\nprintln(dims)\n\n# output\n[0, 0, 1]\n\n\nThe first two faces in the segment (the two vertices) have dimension 0 and the third face (the segment itself) has dimension 1\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_faces-Tuple{Polytope, Integer, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(p::Polytope,dimfrom::Integer,dimto::Integer) -> Vector{Vector{Int}}\n\nFor dimfrom >= dimto returns a vector that for each face of dimension dimfrom stores a vector of the ids of faces of dimension dimto on its boundary.\n\nFor dimfrom < dimto returns a vector that for each face of dimfrom stores a vector of the face ids of faces of dimension dimto that touch it.\n\nThe numerations used in this funcitons are the ones restricted to each dimension.\n\nusing Gridap.ReferenceFEs\n\nedge_to_vertices = get_faces(QUAD,1,0)\nprintln(edge_to_vertices)\n\nvertex_to_edges_around = get_faces(QUAD,0,1)\nprintln(vertex_to_edges_around)\n\n# output\nArray{Int,1}[[1, 2], [3, 4], [1, 3], [2, 4]]\nArray{Int,1}[[1, 3], [1, 4], [2, 3], [2, 4]]\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_faces-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p the function returns a vector of vectors defining the incidence relation of the faces in the polytope.\n\nEach face in the polytope receives a unique integer id. The id 1 is assigned to the first 0-face. Consecutive increasing ids are assigned to the other 0-faces, then to 1-faces, and so on. The polytope itself receives the largest id which coincides with num_faces(p). For a face id iface, get_faces(p)[iface] is a vector of face ids, corresponding to the faces that are incident with the face labeled with iface. That is, faces that are either on its boundary or the face itself. In this vector of incident face ids, faces are ordered by dimension, starting with 0-faces. Within each dimension, the labels are ordered in a consistent way with the polyope object for the face iface itself.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nfaces = get_faces(SEGMENT)\nprintln(faces)\n\n# output\nArray{Int,1}[[1], [2], [1, 2, 3]]\n\nThe constant SEGMENT is bound to a predefined instance of polytope that represents a segment. The face labels associated with a segment are [1,2,3], being 1 and 2 for the vertices and 3 for the segment itself. In this case, this function returns the vector of vectors [[1],[2],[1,2,3]] meaning that vertex 1 is incident with vertex 1 (idem for vertex 2), and that the segment (id 3) is incident with the vertices 1 and 2 and the segment itself.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facet_normal-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facet_normal","text":"get_facet_normal(p::Polytope) -> Vector{VectorValue{D,Float64}}\n\nGiven a polytope p, returns a vector of VectorValue objects representing the unit outward normal vectors to the polytope facets.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_facet_orientations-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_facet_orientations","text":"get_facet_orientations(p::Polytope) -> Vector{Int}\n\nGiven a polytope p returns a vector of integers of length num_facets(p). Facets, whose vertices are ordered consistently with the outwards normal vector, receive value 1 in this vector. Otherwise, facets receive value -1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_name-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_name","text":"get_name(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_node_and_comp_to_dof-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_node_and_comp_to_dof","text":"get_node_and_comp_to_dof(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_node_coordinates-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_offset-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_offset","text":"get_offset(p::Polytope,d::Integer)\n\nEquivalent to get_offsets(p)[d+1].\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_offsets-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_offsets","text":"get_offsets(p::Polytope) -> Vector{Int}\n\nGiven a polytope p, it returns a vector of integers. The position in the d+1 entry in this vector is the offset that transforms a face id in the global numeration in the polytope to the numeration restricted to faces to dimension d.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\noffsets = get_offsets(SEGMENT)\nprintln(offsets)\n\n# output\n[0, 2]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_dofs_permutations-Tuple{ReferenceFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_dofs_permutations","text":"get_own_dofs_permutations(reffe::ReferenceFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_dofs_permutations-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_dofs_permutations","text":"get_own_dofs_permutations(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_nodes_permutations","text":"get_own_nodes_permutations(reffe::LagrangianRefFE,conf::Conformity)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_own_nodes_permutations-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_own_nodes_permutations","text":"get_own_nodes_permutations(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_polytope-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_polytope","text":"get_polytope(reffe::ReferenceFE) -> Polytope\n\nReturns the underlying polytope object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_prebasis-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_prebasis","text":"get_prebasis(reffe::ReferenceFE) -> Field\n\nReturns the underlying prebasis encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}}, Polytope}} where d","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{Polytope{d}},p::Polytope) where d -> Vector{Polytope{d}}\n\nGet a vector of the unique polytopes for the faces of dimension d.\n\nExamples\n\nGet the unique polytopes for the facets of a wedge.\n\nusing Gridap.ReferenceFEs\n\nreffaces = get_reffaces(Polytope{2},WEDGE)\n\nprintln(reffaces)\n\n# output\nGridap.ReferenceFEs.ExtrusionPolytope{2}[TRI, QUAD]\n\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}} where d","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(\n  ::Type{ReferenceFE{d}},\n  reffe::GenericLagrangianRefFE{GradConformity}) where d -> Vector{GenericLagrangianRefFE{GradConformity,M,d}}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_shapefuns-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_shapefuns","text":"get_shapefuns(reffe::ReferenceFE) -> Field\n\nReturns the basis of shape functions (i.e. the canonical basis) associated with the reference FE. The result is encoded as a Field object.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_coordinates-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(p::Polytope) -> Vector{Point{D,Float64}}\n\nGiven a polytope p return a vector of points representing containing the coordinates of the vertices.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_node-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Gridap.ReferenceFEs.Conformity}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(reffe::LagrangianRefFE,conf::Conformity) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_node-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(reffe::LagrangianRefFE) -> Vector{Int}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_vertex_permutations-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_vertex_permutations","text":"get_vertex_permutations(p::Polytope) -> Vector{Vector{Int}}\n\nGiven a polytope p, returns a vector of vectors containing all admissible permutations of the polytope vertices. An admissible permutation is one such that, if the vertices of the polytope are re-labeled according to this permutation, the resulting polytope preserves the shape of the original one.\n\nExamples\n\nusing Gridap.ReferenceFEs\n\nperms = get_vertex_permutations(SEGMENT)\nprintln(perms)\n\n# output\nArray{Int,1}[[1, 2], [2, 1]]\n\n\nThe first admissible permutation for a segment is [1,2],i.e., the identity. The second one is [2,1], i.e., the first vertex is relabeled as 2 and the second vertex is relabeled as 1.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.get_weights-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.get_weights","text":"get_weights(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_P-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_P","text":"is_P(reffe::GenericLagrangianRefFE{GradConformity})\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_Q-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_Q","text":"is_Q(reffe::GenericLagrangianRefFE{GradConformity})\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_S-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_S","text":"is_S(reffe::GenericLagrangianRefFE{GradConformity})\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_first_order-Tuple{Gridap.ReferenceFEs.GenericLagrangianRefFE{Gridap.ReferenceFEs.GradConformity}}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_first_order","text":"is_first_order(reffe::GenericLagrangianRefFE{GradConformity}) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_n_cube-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_n_cube","text":"is_n_cube(p::Polytope) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.is_simplex-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.is_simplex","text":"is_simplex(p::Polytope) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.next_corner!-Tuple{Vector{Vector{Int64}}, Int64, Vector{Int64}, Int64}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.next_corner!","text":"Sweep through the dim-dimensional hypercube recursively, collecting all simplices.\n\nWe represent vertices as bit patterns. In dim dimensions, the lowermost dim bits are either zero or one. Interpreted as integer, this labels the vertices of the hypercube from the origin (\"bottom\") 0 to the diagonally opposite vertex (\"top\") 2^dim-1.\n\nEach simplex contains both the bottom vertex 0 as well as the top vertex 2^dim-1. Its other vertices trace a path from the bottom to the top. The algorithm below finds all possible paths.\n\nsimplices is the accumulator where the simplices are collected.\nvertices is the current set of vertices as we sweep from the origin to the diagonally opposide vertex.\ncorner is the current corner.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_cell_dims-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::Type{<:ReferenceFE{D}}) where D\nnum_cell_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dims-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Type{<:Polytope{D}}) where D\nnum_dims(p::Polytope{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dims-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Type{<:ReferenceFE{D}}) where D\nnum_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dims-Union{Tuple{Gridap.ReferenceFEs.Quadrature{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Quadrature{D}) where D where D\nnum_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_dofs-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_dofs","text":"num_dofs(reffe::ReferenceFE) -> Int\n\nReturns the number of DOFs.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_edges-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(p::Polytope)\n\nReturns the number of edges in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_edges-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Polytope, Integer}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(p::Polytope,dim::Integer)\n\nReturns the number of faces of dimension dim in polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(p::Polytope)\n\nReturns the total number of faces in polytope p (from vertices to the polytope itself).\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_faces-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(reffe::ReferenceFE)\nnum_faces(reffe::ReferenceFE,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_facets-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(p::Polytope)\n\nReturns the number of facets in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_facets-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_nodes-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_point_dims-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::Type{<:ReferenceFE{D}}) where D\nnum_point_dims(reffe::ReferenceFE{D}) where D\n\nReturns D.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_point_dims-Union{Tuple{Gridap.ReferenceFEs.Quadrature{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::Quadrature{D}) where D\nnum_point_dims(::Type{<:Quadrature{D}}) where D\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_points-Tuple{Gridap.ReferenceFEs.Quadrature}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_points","text":"num_points(q::Quadrature)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_vertices-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(p::Polytope)\n\nReturns the number of vertices in the polytope p.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.num_vertices-Tuple{ReferenceFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(reffe::ReferenceFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.simplexify-Tuple{Polytope}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(p::Polytope) -> Tuple{Vector{Vector{Int}},Polytope}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_dof-Tuple{Gridap.ReferenceFEs.Dof, Any, Any}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_dof","text":"test_dof(dof,field,v;cmp::Function=(==))\n\nTest that the Dof interface is properly implemented for object dof. It also checks if the object dof when evaluated at the field field returns the same value as v. Comparison is made with the comp function.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_lagrangian_reference_fe-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_lagrangian_reference_fe","text":"test_lagrangian_reference_fe(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_polytope-Union{Tuple{Polytope{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_polytope","text":"test_polytope(p::Polytope{D}; optional::Bool=false) where D\n\nFunction that stresses out the functions in the Polytope interface. It tests whether the function in the polytope interface are defined for the given object, and whether they return objects of the expected type. With optional=false (the default), only the mandatory functions are checked. With optional=true, the optional functions are also tested.\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_quadrature-Union{Tuple{Gridap.ReferenceFEs.Quadrature{D, T}}, Tuple{T}, Tuple{D}} where {D, T}","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_quadrature","text":"test_quadrature(q::Quadrature{D,T}) where {D,T}\n\n\n\n\n\n","category":"method"},{"location":"ReferenceFEs/#Gridap.ReferenceFEs.test_reference_fe-Union{Tuple{ReferenceFE{D}}, Tuple{D}} where D","page":"Gridap.ReferenceFEs","title":"Gridap.ReferenceFEs.test_reference_fe","text":"test_reference_fe(reffe::ReferenceFE{D}) where D\n\nTest if the methods in the ReferenceFE interface are defined for the object reffe.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"CurrentModule = Gridap.Helpers","category":"page"},{"location":"Helpers/#Gridap.Helpers","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"","category":"section"},{"location":"Helpers/","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"Modules = [Helpers,]","category":"page"},{"location":"Helpers/#Gridap.Helpers","page":"Gridap.Helpers","title":"Gridap.Helpers","text":"This module provides a set of helper macros and helper functions\n\nThe exported macros are:\n\nGridapType\n@abstractmethod\n@check\nfirst_and_tail\nget_val_parameter\n@notimplemented\n@notimplementedif\ntfill\n@unreachable\n\n\n\n\n\n","category":"module"},{"location":"Helpers/#Gridap.Helpers.GridapType","page":"Gridap.Helpers","title":"Gridap.Helpers.GridapType","text":"abstract type GridapType end\n\n\n\n\n\n","category":"type"},{"location":"Helpers/#Gridap.Helpers.first_and_tail-Tuple{Tuple}","page":"Gridap.Helpers","title":"Gridap.Helpers.first_and_tail","text":"first_and_tail(a::Tuple)\n\nEquivalent to (first(a), Base.tail(a)).\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.get_val_parameter-Union{Tuple{Val{T}}, Tuple{T}} where T","page":"Gridap.Helpers","title":"Gridap.Helpers.get_val_parameter","text":"get_val_parameter(::Val{T}) where T\nget_val_parameter(::Type{Val{T}}) where T\n\nReturns T.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.tfill-Union{Tuple{D}, Tuple{Any, Val{D}}} where D","page":"Gridap.Helpers","title":"Gridap.Helpers.tfill","text":"tfill(v, ::Val{D}) where D\n\nReturns a tuple of length D that contains D times the object v. In contrast to tuple(fill(v,D)...) which returns the same result, this function is type-stable.\n\n\n\n\n\n","category":"method"},{"location":"Helpers/#Gridap.Helpers.@abstractmethod","page":"Gridap.Helpers","title":"Gridap.Helpers.@abstractmethod","text":"@abstractmethod\n\nMacro used in generic functions that must be overloaded by derived types.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@check","page":"Gridap.Helpers","title":"Gridap.Helpers.@check","text":"@check condition   @check condition \"Error message\"\n\nMacro used to make sure that condition is fulfilled, like @assert but the check gets deactivated when running Julia with â€“boundscheck=no\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@notimplemented","page":"Gridap.Helpers","title":"Gridap.Helpers.@notimplemented","text":"@notimplemented\n@notimplemented \"Error message\"\n\nMacro used to raise an error, when something is not implemented.\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@notimplementedif","page":"Gridap.Helpers","title":"Gridap.Helpers.@notimplementedif","text":"@notimplementedif condition\n@notimplementedif condition \"Error message\"\n\nMacro used to raise an error if the condition is true\n\n\n\n\n\n","category":"macro"},{"location":"Helpers/#Gridap.Helpers.@unreachable","page":"Gridap.Helpers","title":"Gridap.Helpers.@unreachable","text":"@unreachable\n@unreachable \"Error message\"\n\nMacro used to make sure that a line of code is never reached.\n\n\n\n\n\n","category":"macro"},{"location":"#Gridap.jl","page":"Home","title":"Gridap.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation of the Gridap library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThese documentation pages are under construction.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gridap provides a set of tools for the grid-based approximation of partial differential equations (PDEs) written in the Julia programming language. The main motivation behind the development of this library is to provide an easy-to-use framework for the development of complex PDE solvers in a dynamically typed style without sacrificing the performance of statically typed languages. The library currently supports linear and nonlinear PDE systems for scalar and vector fields, single and multi-field problems, conforming and nonconforming finite element discretizations, on structured and unstructured meshes of simplices and hexahedra.","category":"page"},{"location":"#How-to-use-this-documentation","page":"Home","title":"How to use this documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step for new users is to visit the Getting Started page.\nA set of tutorials written as Jupyter notebooks and html pages are available here.\nThe detailed documentation is in the Manual section.\nGuidelines for developers of the Gridap project is found in the Gridap wiki page.","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the Gridap package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First steps to learn Julia form the Gridap wiki page.\nOfficial webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"Gridap.md\",\n  \"Helpers.md\",\n  \"Io.md\",\n  \"Algebra.md\",\n  \"Arrays.md\",\n  \"TensorValues.md\",\n  \"Fields.md\",\n  \"Polynomials.md\",\n  \"Integration.md\",\n  \"ReferenceFEs.md\",\n  \"Geometry.md\",\n  \"CellData.md\",\n  \"Visualization.md\",\n  \"FESpaces.md\",\n  \"MultiField.md\",\n  ]","category":"page"},{"location":"Geometry/","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"CurrentModule = Gridap.Geometry","category":"page"},{"location":"Geometry/#Gridap.Geometry","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"","category":"section"},{"location":"Geometry/","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Modules = [Geometry,]","category":"page"},{"location":"Geometry/#Gridap.Geometry","page":"Gridap.Geometry","title":"Gridap.Geometry","text":"Exported names are\n\nAppendedTriangulation\nBodyFittedTriangulation\nBoundary\nBoundaryTriangulation\nCartesianDescriptor\nCartesianDiscreteModel\nCartesianGrid\nDiscreteModel\nDiscreteModelFromFile\nDiscreteModelPortion\nFaceLabeling\nFaceToFaceGlue\nGenericTriangulation\nGrid\nGridMock\nGridPortion\nGridTopology\nInterface\nInterfaceTriangulation\nInterior\nIrregular\nNonOriented\nOrientationStyle\nOriented\nRegular\nRegularityStyle\nSkeleton\nSkeletonPair\nSkeletonTriangulation\nTriangulation\nUnstructuredDiscreteModel\nUnstructuredGrid\nUnstructuredGridTopology\nadd_tag!\nadd_tag_from_tags!\nbest_target\ncompress_cell_data\ncompress_contributions\ncompress_ids\ncompute_cell_faces\ncompute_cell_permutations\ncompute_face_nodes\ncompute_face_own_nodes\ncompute_face_vertices\ncompute_isboundary_face\ncompute_linear_grid\ncompute_node_face_owner\ncompute_reference_grid\ncompute_reffaces\ncompute_vertex_node\nexpand_cell_data\nextend\nget_active_model\nget_background_model\nget_cartesian_descriptor\nget_cell_coordinates\nget_cell_entity\nget_cell_faces\nget_cell_map\nget_cell_node_ids\nget_cell_permutations\nget_cell_ref_coordinates\nget_cell_reffe\nget_cell_shapefuns\nget_cell_type\nget_cell_vertices\nget_face_entity\nget_face_labeling\nget_face_mask\nget_face_tag\nget_face_tag_index\nget_facet_normal\nget_glue\nget_grid\nget_grid_topology\nget_isboundary_face\nget_node_face_owner\nget_parent_model\nget_polytopes\nget_reffaces_offsets\nget_reffes\nget_tag_entities\nget_tag_from_name\nget_tag_name\nget_tags_from_names\nget_triangulation\nis_change_possible\nis_oriented\nis_regular\nmove_contributions\nnum_cells\nnum_entities\nnum_tags\npos_neg_data\ntest_discrete_model\ntest_grid\ntest_grid_topology\ntest_triangulation\n\n\n\n\n\n","category":"module"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel, AbstractVector{<:Integer}, AbstractVector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nBoundaryTriangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel, Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tags::Vector{Int})\nBoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tags::Vector{String})\nBoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tag::Int)\nBoundaryTriangulation(model::DiscreteModel,labeling::FaceLabeling;tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.BoundaryTriangulation-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.BoundaryTriangulation","text":"BoundaryTriangulation(model::DiscreteModel,tags::Vector{Int})\nBoundaryTriangulation(model::DiscreteModel,tags::Vector{String})\nBoundaryTriangulation(model::DiscreteModel,tag::Int)\nBoundaryTriangulation(model::DiscreteModel,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"struct CartesianDescriptor{D,T,F<:Function}\n  origin::Point{D,T}\n  sizes::NTuple{D,T}\n  partition::NTuple{D,Int}\n  map::F\nend\n\nStruct that stores the data defining a Cartesian grid.\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor-Tuple{Any, Any}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"CartesianDescriptor(\n  domain,\n  partition;\n  map::Function=identity,\n  isperiodic::NTuple{D,Bool}=tfill(false,Val{D}))\n\ndomain and partition are 1D indexable collections of arbitrary type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor-Union{Tuple{D}, Tuple{VectorValue{D}, Tuple{Vararg{T, D}} where T, Any}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"CartesianDescriptor(\n  origin::Point{D},\n  sizes::NTuple{D},\n  partition;\n  map::Function=identity,\n  isperiodic::NTuple{D,Bool}=tfill(false,Val{D})) where D\n\npartition is a 1D indexable collection of arbitrary type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDescriptor-Union{Tuple{D}, Tuple{VectorValue{D}, VectorValue{D}, Any}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDescriptor","text":"CartesianDescriptor(\n  pmin::Point{D},\n  pmax::Point{D},\n  partition;\n  map::Function=identity,\n  isperiodic::NTuple{D,Bool}=tfill(false,Val{D})) where D\n\npartition is a 1D indexable collection of arbitrary type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"struct CartesianDiscreteModel{D,T,F} <: DiscreteModel{D,D}\n  # Private Fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Tuple","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(args...)\n\nSame args needed to construct a CartesianDescriptor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Union{Tuple{F}, Tuple{T}, Tuple{D}, Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}, CartesianIndex, CartesianIndex}} where {D, T, F}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(desc::CartesianDescriptor{D,T,F},\n                       cmin::CartesianIndex,\n                       cmax::CartesianIndex)\n\nBuilds a CartesianDiscreteModel object which represents a subgrid of\na (larger) grid represented by desc. This subgrid is described by its\nD-dimensional minimum (cmin) and maximum (cmax) CartesianIndex\nidentifiers.\n\nInner constructor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianDiscreteModel-Union{Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}}, Tuple{F}, Tuple{T}, Tuple{D}} where {D, T, F}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianDiscreteModel","text":"CartesianDiscreteModel(desc::CartesianDescriptor)\n\nInner constructor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"struct CartesianGrid{D,T,F} <: Grid{D,D}\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid-Tuple","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"CartesianGrid(args...;kwargs...)\n\nSame args needed to construct a CartesianDescriptor\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.CartesianGrid-Union{Tuple{Gridap.Geometry.CartesianDescriptor{D, T, F}}, Tuple{F}, Tuple{T}, Tuple{D}} where {D, T, F}","page":"Gridap.Geometry","title":"Gridap.Geometry.CartesianGrid","text":"CartesianGrid(desc::CartesianDescriptor)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"abstract type DiscreteModel{Dc,Dp} <: Grid\n\nAbstract type holding information about a physical grid, the underlying grid topology, and a labeling of the grid faces. This is the information that typically provides a mesh generator, and it is what one needs to perform a simulation.\n\nThe DiscreteModel interface is defined by overloading the methods:\n\nget_grid(model::DiscreteModel)\nget_grid_topology(model::DiscreteModel)\nget_face_labeling(g::DiscreteModel)\n\nThe interface is tested with this function:\n\ntest_discrete_model\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel-Tuple{Gridap.Geometry.Grid, Gridap.Geometry.GridTopology, Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModel-Union{Tuple{D}, Tuple{Type{<:Polytope{D}}, DiscreteModel}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModel","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelPortion","text":"\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelPortion-Tuple{DiscreteModel, AbstractVector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelPortion","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"struct FaceLabeling <: GridapType\n  d_to_dface_to_entity::Vector{Vector{Int32}}\n  tag_to_entities::Vector{Vector{Int32}}\n  tag_to_name::Vector{String}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.FaceLabeling-Tuple{Vector{Int64}}","page":"Gridap.Geometry","title":"Gridap.Geometry.FaceLabeling","text":"FaceLabeling(d_to_num_dfaces::Vector{Int})\nFaceLabeling(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"abstract type Grid{Dc,Dp}\n\nAbstract type that represents mesh of a domain of parametric dimension Dc and physical dimension Dp.\n\nThe interface of Grid is defined by overloading:\n\nget_node_coordinates(trian::Grid)\nget_cell_node_ids(trian::Grid)\nget_reffes(trian::Grid)\nget_cell_type(trian::Grid)\n\nThe Grid  interface has the following traits\n\nOrientationStyle(::Type{<:Grid})\nRegularityStyle(::Type{<:Grid})\n\nThe interface of Grid is tested with\n\ntest_grid\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.Grid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(::Type{ReferenceFE{d}},model::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Grid-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, Polytope}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.Grid","text":"Grid(::Type{ReferenceFE{d}},p::Polytope) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridPortion","page":"Gridap.Geometry","title":"Gridap.Geometry.GridPortion","text":"struct GridPortion{Dc,Dp,G} <: Grid{Dc,Dp}\n  parent::G\n  cell_to_parent_cell::Vector{Int32}\n  node_to_parent_node::Vector{Int32}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.GridPortion-Tuple{Gridap.Geometry.Grid, AbstractVector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.GridPortion","text":"GridPortion(parent::Grid{Dc,Dp},cell_to_parent_cell::Vector{Int32}) where {Dc,Dp}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridTopology","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"abstract type GridTopology{Dc,Dp}\n\nAbstract type representing the topological information associated with a grid.\n\nThe GridTopology interface is defined by overloading the methods:\n\nget_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\nget_polytopes(g::GridTopology)\nget_cell_type(g::GridTopology)\nget_vertex_coordinates(g::GridTopology)\n\nThe GridTopology interface has the following traits\n\nOrientationStyle(::Type{<:GridTopology})\nRegularityStyle(::Type{<:GridTopology})\n\nand tested with this function:\n\ntest_grid_topology\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.GridTopology-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"GridTopology(grid::Grid)\nGridTopology(grid::Grid, cell_to_vertices::Table, vertex_to_node::Vector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.GridTopology-Union{Tuple{D}, Tuple{Type{<:Polytope{D}}, DiscreteModel}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry.GridTopology","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.OrientationStyle-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.OrientationStyle","text":"OrientationStyle(::Type{<:GridTopology})\nOrientationStyle(::GridTopology)\n\nOriented() if has oriented faces, NonOriented() otherwise (default).\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.OrientationStyle-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.OrientationStyle","text":"OrientationStyle(::Type{<:Grid})\nOrientationStyle(::Grid)\n\nOriented() if has oriented faces, NonOriented() otherwise (default).\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.RegularityStyle-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.RegularityStyle","text":"RegularityStyle(::Type{<:GridTopology})\nRegularityStyle(::GridTopology)\n\nRegular() if no hanging-nodes default), Irregular() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.RegularityStyle-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.RegularityStyle","text":"RegularityStyle(::Type{<:Grid})\nRegularityStyle(::Grid)\n\nRegular() if no hanging-nodes default), Irregular() otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.SkeletonPair","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonPair","text":"struct SkeletonPair{L,R} <: GridapType\n  plus::L\n  minus::R\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.SkeletonTriangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonTriangulation","text":"struct SkeletonTriangulation{Dc,Dp,B} <: Triangulation{Dc,Dp}\n  plus::B\n  minus::B\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.SkeletonTriangulation-Tuple{DiscreteModel, AbstractVector{Bool}}","page":"Gridap.Geometry","title":"Gridap.Geometry.SkeletonTriangulation","text":"SkeletonTriangulation(model::DiscreteModel,face_to_mask::Vector{Bool})\nSkeletonTriangulation(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.Triangulation","page":"Gridap.Geometry","title":"Gridap.Geometry.Triangulation","text":"abstract type Triangulation{Dt,Dp}\n\nA discredited physical domain associated with a DiscreteModel{Dm,Dp}.\n\nDt and Dm can be different.\n\nThe (mandatory) Triangulation interface can be tested with\n\ntest_triangulation\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"struct UnstructuredDiscreteModel{Dc,Dp,Tp,B} <: DiscreteModel{Dc,Dp}\n  grid::UnstructuredGrid{Dc,Dp,Tp,B}\n  grid_topology::UnstructuredGridTopology{Dc,Dp,Tp,B}\n  face_labeling::FaceLabeling\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredDiscreteModel-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredDiscreteModel","text":"UnstructuredDiscreteModel(grid::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"struct UnstructuredGrid{Dc,Dp,Tp,Ti,O} <: Grid{Dc,Dp}\n  node_coordinates::Vector{Point{Dp,Tp}}\n  cell_node_ids::Table{Ti,Int32}\n  reffes::Vector{<:LagrangianRefFE{Dc}}\n  cell_types::Vector{Int8}\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{AbstractArray{<:VectorValue}}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(x::AbstractArray{<:Point})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(grid::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(reffe::LagrangianRefFE)\n\nBuild a grid with a single cell that is the given reference FE itself\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Union{Tuple{Ti}, Tuple{Tp}, Tuple{Dp}, Tuple{Dc}, Tuple{Array{VectorValue{Dp, Tp}, 1}, Gridap.Arrays.Table{Ti, Vd} where Vd<:AbstractVector{Ti}, Vector{<:Gridap.ReferenceFEs.LagrangianRefFE{Dc}}, Vector}, Tuple{Array{VectorValue{Dp, Tp}, 1}, Gridap.Arrays.Table{Ti, Vd} where Vd<:AbstractVector{Ti}, Vector{<:Gridap.ReferenceFEs.LagrangianRefFE{Dc}}, Vector, Gridap.Geometry.OrientationStyle}, Tuple{Array{VectorValue{Dp, Tp}, 1}, Gridap.Arrays.Table{Ti, Vd} where Vd<:AbstractVector{Ti}, Vector{<:Gridap.ReferenceFEs.LagrangianRefFE{Dc}}, Vector, Gridap.Geometry.OrientationStyle, Any}} where {Dc, Dp, Tp, Ti}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"function UnstructuredGrid(\n  node_coordinates::Vector{Point{Dp,Tp}},\n  cell_node_ids::Table{Ti},\n  reffes::Vector{<:LagrangianRefFE{Dc}},\n  cell_types::Vector,\n  orientation_style::OrientationStyle=NonOriented()) where {Dc,Dp,Tp,Ti}\nend\n\nLow-level inner constructor.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGrid-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, Polytope}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGrid","text":"UnstructuredGrid(::Type{ReferenceFE{d}},p::Polytope) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  d_to_dface_vertices::Vector{<:Table},\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation_style::OrientationStyle=NonOriented())\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-2","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(\n  vertex_coordinates::Vector{<:Point},\n  cell_vertices::Table,\n  cell_type::Vector{<:Integer},\n  polytopes::Vector{<:Polytope},\n  orientation_style::OrientationStyle=NonOriented())\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-3","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"struct UnstructuredGridTopology{Dc,Dp,T,O} <: GridTopology{Dc,Dp}\n  # private fields\nend\n\n\n\n\n\n","category":"type"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.UnstructuredGridTopology-Tuple{Gridap.Geometry.UnstructuredGrid}","page":"Gridap.Geometry","title":"Gridap.Geometry.UnstructuredGridTopology","text":"UnstructuredGridTopology(grid::UnstructuredGrid)\n\nUnstructuredGridTopology(\n  grid::UnstructuredGrid,\n  cell_to_vertices::Table,\n  vertex_to_node::AbstractVector)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.DiscreteModelFromFile-Tuple{AbstractString}","page":"Gridap.Geometry","title":"Gridap.Geometry.DiscreteModelFromFile","text":"DiscreteModelFromFile(filename::AbstractString)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.InterfaceTriangulation-Tuple{DiscreteModel, Vector{Bool}}","page":"Gridap.Geometry","title":"Gridap.Geometry.InterfaceTriangulation","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry._find_ncube_face_neighbor_deltas-Union{Tuple{Gridap.ReferenceFEs.ExtrusionPolytope{D}}, Tuple{D}} where D","page":"Gridap.Geometry","title":"Gridap.Geometry._find_ncube_face_neighbor_deltas","text":"findncubefaceneighbor_deltas(p::ExtrusionPolytope{D}) -> Vector{CartesianIndex}\n\nGiven an n-cube type ExtrusionPolytope{D}, returns V=Vector{CartesianIndex} with as many   entries as the number of faces in the boundary of the Polytope. For an entry facelid   in this vector, V[facelid] returns what has to be added to the CartesianIndex of a   cell in order to obtain the CartesianIndex of the cell neighbour of K across the face F   with local ID face_lid.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.add_tag!-Tuple{Gridap.Geometry.FaceLabeling, String, Vector{<:Integer}}","page":"Gridap.Geometry","title":"Gridap.Geometry.add_tag!","text":"add_tag!(lab::FaceLabeling,name::String,entities::Vector{<:Integer})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.add_tag_from_tags!-Tuple{Gridap.Geometry.FaceLabeling, String, Vector{Int64}}","page":"Gridap.Geometry","title":"Gridap.Geometry.add_tag_from_tags!","text":"add_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{Int})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tags::Vector{String})\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tag::Int)\nadd_tag_from_tags!(lab::FaceLabeling, name::String, tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_faces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_faces","text":"compute_cell_faces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_permutations-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_permutations","text":"compute_cell_permutations(top::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_cell_permutations-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_cell_permutations","text":"compute_cell_permutations(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_nodes","text":"compute_face_nodes(model::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_nodes","text":"compute_face_nodes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_own_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_own_nodes","text":"compute_face_own_nodes(model::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_own_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_own_nodes","text":"compute_face_own_nodes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_face_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_face_vertices","text":"compute_face_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_isboundary_face-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_isboundary_face","text":"compute_isboundary_face(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_isboundary_face-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_isboundary_face","text":"compute_isboundary_face(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_linear_grid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_linear_grid","text":"compute_linear_grid(reffe::LagrangianRefFE)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_node_face_owner-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_node_face_owner","text":"compute_node_face_owner(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reference_grid-Tuple{Gridap.ReferenceFEs.LagrangianRefFE, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reference_grid","text":"compute_reference_grid(p::LagrangianRefFE, nelems::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reference_grid-Tuple{Polytope, Any}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reference_grid","text":"compute_reference_grid(p::Polytope,nelems)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}}, Gridap.Geometry.GridTopology}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_reffaces-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_reffaces","text":"compute_reffaces(::Type{ReferenceFE{d}}, g::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.compute_vertex_node-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.compute_vertex_node","text":"compute_vertex_node(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cartesian_descriptor-Tuple{CartesianDiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cartesian_descriptor","text":"get_cartesian_descriptor(model::CartesianDiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cartesian_descriptor-Tuple{CartesianGrid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cartesian_descriptor","text":"get_cartesian_descriptor(grid::CartesianGrid)\n\nGet the descriptor of the Cartesian grid\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_entity-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_entity","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_faces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_faces","text":"get_cell_faces(g::GridTopology)\n\nDefaults to\n\ncompute_cell_faces(g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_map-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_map","text":"get_cell_map(trian::Grid) -> Vector{<:Field}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_node_ids-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_node_ids","text":"get_cell_node_ids(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_permutations-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_permutations","text":"get_cell_permutations(top::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_permutations-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_permutations","text":"get_cell_permutations(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_ref_coordinates-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_ref_coordinates","text":"\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_reffe-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_reffe","text":"get_cell_reffe(trian::Grid) -> Vector{<:LagrangianRefFE}\n\nIt is not desirable to iterate over the resulting array for large number of cells if the underlying reference FEs are of different Julia type.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_shapefuns-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_shapefuns","text":"get_cell_shapefuns(trian::Grid) -> Vector{<:Field}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_type-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_type","text":"get_cell_type(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_type-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_type","text":"get_cell_type(trian::Grid) -> AbstractVector{<:Integer}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_cell_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_cell_vertices","text":"get_cell_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_entity-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_entity","text":"get_face_entity(lab::FaceLabeling,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_entity-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_entity","text":"get_face_entity(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_labeling-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_labeling","text":"get_face_labeling(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_mask-Tuple{Gridap.Geometry.FaceLabeling, Any, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_mask","text":"get_face_mask(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_mask(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_mask(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_mask(labeling::FaceLabeling,tag::String,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_tag-Tuple{Gridap.Geometry.FaceLabeling, Any, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_tag","text":"get_face_tag(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_tag(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_tag(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_tag(labeling::FaceLabeling,tag::String,d::Integer)\nget_face_tag(labeling::FaceLabeling,d::Integer)\n\nThe first of the given tags appearing in the face is taken. If there is no tag on a face, this face will have a value equal to UNSET. If not tag or tags are provided, all the tags in the model are considered\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_face_tag_index-Tuple{Gridap.Geometry.FaceLabeling, Any, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_face_tag_index","text":"get_face_tag_index(labeling::FaceLabeling,tags::Vector{Int},d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tags::Vector{String},d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tag::Int,d::Integer)\nget_face_tag_index(labeling::FaceLabeling,tag::String,d::Integer)\n\nLike get_face_tag by provides the index into the array tags instead of the tag stored in tags.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_grid-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_grid","text":"get_grid(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_grid_topology-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_grid_topology","text":"get_grid_topology(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_isboundary_face-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_isboundary_face","text":"get_isboundary_face(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_isboundary_face-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_isboundary_face","text":"get_isboundary_face(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_node_face_owner-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_node_face_owner","text":"get_node_face_owner(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_polytopes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_polytopes","text":"get_polytopes(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_polytopes-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_polytopes","text":"get_polytopes(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffaces_offsets-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffaces_offsets","text":"get_reffaces_offsets(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffaces_offsets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffaces_offsets","text":"get_reffaces_offsets(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_reffes-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_reffes","text":"get_reffes(trian::Grid) -> Vector{LagrangianRefFE}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_entities-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_entities","text":"get_tag_entities(lab::FaceLabeling,tag::Integer)\nget_tag_entities(lab::FaceLabeling,tag::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_entities-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_entities","text":"get_tag_entities(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_from_name-Tuple{Gridap.Geometry.FaceLabeling, String}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_from_name","text":"get_tag_from_name(lab::FaceLabeling,name::String)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_from_name-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_from_name","text":"get_tag_from_name(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_name-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_name","text":"get_tag_name(lab::FaceLabeling,tag::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tag_name-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tag_name","text":"get_tag_name(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.get_tags_from_names-Tuple{Gridap.Geometry.FaceLabeling, Vector{String}}","page":"Gridap.Geometry","title":"Gridap.Geometry.get_tags_from_names","text":"get_tags_from_names(lab::FaceLabeling,names::Vector{String})\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_oriented-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_oriented","text":"is_oriented(::Type{<:GridTopology}) -> Bool\nis_oriented(a::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_oriented-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_oriented","text":"is_oriented(::Type{<:Grid}) -> Bool\nis_oriented(a::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_regular-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_regular","text":"is_regular(::Type{<:GridTopology}) -> Bool\nis_regular(a::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.is_regular-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.is_regular","text":"is_regular(::Type{<:Grid}) -> Bool\nis_regular(a::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_cells-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_cells","text":"num_cells(trian::Grid) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_entities-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_entities","text":"num_entities(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.num_tags-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.Geometry.num_tags","text":"num_tags(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_discrete_model-Union{Tuple{DiscreteModel{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_discrete_model","text":"test_discrete_model(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_grid-Union{Tuple{Gridap.Geometry.Grid{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_grid","text":"test_grid(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_grid_topology-Union{Tuple{Gridap.Geometry.GridTopology{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_grid_topology","text":"test_grid_topology(top::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.Geometry.test_triangulation-Union{Tuple{Triangulation{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.Geometry.test_triangulation","text":"test_triangulation(trian::Triangulation)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_dimrange-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_dimrange","text":"get_dimrange(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_dimranges-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_dimranges","text":"get_dimranges(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(g::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_nodes","text":"get_face_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(g::DiscreteModel,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_own_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_own_nodes","text":"get_face_own_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(g::DiscreteModel,d::Integer)\n\nIndex to the vector get_reffaces(ReferenceFE{d},g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(g::GridTopology,d::Integer)\n\nBy default, it calls to compute_reffaces.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_type-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_type","text":"get_face_type(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_face_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_face_vertices","text":"get_face_vertices(g::GridTopology)\n\nDefaults to\n\ncompute_face_vertices(g)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_facedims-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_facedims","text":"get_facedims(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_faces-Tuple{Gridap.Geometry.GridTopology, Integer, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_faces","text":"get_faces(g::GridTopology,dimfrom::Integer,dimto::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_facet_normal-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_facet_normal","text":"get_facet_normal(trian::Grid)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_node_coordinates-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_node_coordinates","text":"get_node_coordinates(trian::Grid) -> AbstractArray{<:Point{Dp}}\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_offset-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_offset","text":"get_offset(g::GridTopology,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_offsets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_offsets","text":"get_offsets(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(topo::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{Polytope{d}}, Gridap.Geometry.GridTopology}} where d","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{Polytope{d}}, g::GridTopology) where d\n\nBy default, it calls to compute_reffaces.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_reffaces-Union{Tuple{d}, Tuple{Type{ReferenceFE{d}}, DiscreteModel}} where d","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_reffaces","text":"get_reffaces(::Type{ReferenceFE{d}},model::DiscreteModel) where d\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_vertex_coordinates-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_vertex_coordinates","text":"get_vertex_coordinates(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.get_vertex_node-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.get_vertex_node","text":"get_vertex_node(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_first_order-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_first_order","text":"is_first_order(trian::Grid) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_n_cube-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_n_cube","text":"is_n_cube(p::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.is_simplex-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.is_simplex","text":"is_simplex(p::GridTopology) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::GridTopology) -> Int\nnum_cell_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_cell_dims-Union{Tuple{Gridap.Geometry.Grid{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_cell_dims","text":"num_cell_dims(::Grid) -> Int\nnum_cell_dims(::Type{<:Grid}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc}}, Tuple{Dc}} where Dc","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::GridTopology) -> Int\nnum_dims(::Type{<:GridTopology}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_dims-Union{Tuple{Gridap.Geometry.Grid{Dc}}, Tuple{Dc}} where Dc","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_dims","text":"num_dims(::Grid) -> Int\nnum_dims(::Type{<:Grid}) -> Int\n\nEquivalent to num_cell_dims.\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_edges-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_edges","text":"num_edges(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{DiscreteModel, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(g::DiscreteModel,d::Integer)\nnum_faces(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.FaceLabeling, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(lab::FaceLabeling,d::Integer)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_faces-Tuple{Gridap.Geometry.GridTopology, Integer}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_faces","text":"num_faces(g::GridTopology,d::Integer)\nnum_faces(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_facets-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_facets","text":"num_facets(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_nodes-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_nodes-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_nodes","text":"num_nodes(trian::Grid) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_point_dims-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_point_dims-Union{Tuple{Gridap.Geometry.GridTopology{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::GridTopology) -> Int\nnum_point_dims(::Type{<:GridTopology}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_point_dims-Union{Tuple{Gridap.Geometry.Grid{Dc, Dp}}, Tuple{Dp}, Tuple{Dc}} where {Dc, Dp}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_point_dims","text":"num_point_dims(::Grid) -> Int\nnum_point_dims(::Type{<:Grid}) -> Int\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(g::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.Geometry.FaceLabeling}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(lab::FaceLabeling)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.num_vertices-Tuple{Gridap.Geometry.GridTopology}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.num_vertices","text":"num_vertices(g::GridTopology)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.simplexify-Tuple{DiscreteModel}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(model::DiscreteModel)\n\n\n\n\n\n","category":"method"},{"location":"Geometry/#Gridap.ReferenceFEs.simplexify-Tuple{Gridap.Geometry.Grid}","page":"Gridap.Geometry","title":"Gridap.ReferenceFEs.simplexify","text":"simplexify(grid::Grid)\n\n\n\n\n\n","category":"method"}]
}
