<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Block Assemblers · Gridap.jl</title><meta name="title" content="Block Assemblers · Gridap.jl"/><meta property="og:title" content="Block Assemblers · Gridap.jl"/><meta property="twitter:title" content="Block Assemblers · Gridap.jl"/><meta name="description" content="Documentation for Gridap.jl."/><meta property="og:description" content="Documentation for Gridap.jl."/><meta property="twitter:description" content="Documentation for Gridap.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Gridap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Gridap.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../../Gridap/">Gridap</a></li><li><a class="tocitem" href="../../Helpers/">Gridap.Helpers</a></li><li><a class="tocitem" href="../../Io/">Gridap.Io</a></li><li><a class="tocitem" href="../../Algebra/">Gridap.Algebra</a></li><li><a class="tocitem" href="../../Arrays/">Gridap.Arrays</a></li><li><a class="tocitem" href="../../TensorValues/">Gridap.TensorValues</a></li><li><a class="tocitem" href="../../Fields/">Gridap.Fields</a></li><li><a class="tocitem" href="../../Polynomials/">Gridap.Polynomials</a></li><li><a class="tocitem" href="../../ReferenceFEs/">Gridap.ReferenceFEs</a></li><li><a class="tocitem" href="../../Geometry/">Gridap.Geometry</a></li><li><a class="tocitem" href="../../CellData/">Gridap.CellData</a></li><li><a class="tocitem" href="../../Visualization/">Gridap.Visualization</a></li><li><a class="tocitem" href="../../FESpaces/">Gridap.FESpaces</a></li><li><a class="tocitem" href="../../MultiField/">Gridap.MultiField</a></li><li><a class="tocitem" href="../../ODEs/">Gridap.ODEs</a></li><li><a class="tocitem" href="../../Adaptivity/">Gridap.Adaptivity</a></li><li><span class="tocitem">Developper notes</span><ul><li class="is-active"><a class="tocitem" href>Block Assemblers</a><ul class="internal"><li><a class="tocitem" href="#SparseMatrixAssemblers"><span>SparseMatrixAssemblers</span></a></li><li><a class="tocitem" href="#BlockSparseMatrixAssemblers"><span>BlockSparseMatrixAssemblers</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developper notes</a></li><li class="is-active"><a href>Block Assemblers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Block Assemblers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gridap/Gridap.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gridap/Gridap.jl/blob/master/docs/src/dev-notes/block-assemblers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Block-Assemblers"><a class="docs-heading-anchor" href="#Block-Assemblers">Block Assemblers</a><a id="Block-Assemblers-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Assemblers" title="Permalink"></a></h1><p>This file contains implementation details for block assemblers. We will first have a look at how standard sparse matrix assembly works, then compare it to block assembly.</p><h2 id="SparseMatrixAssemblers"><a class="docs-heading-anchor" href="#SparseMatrixAssemblers">SparseMatrixAssemblers</a><a id="SparseMatrixAssemblers-1"></a><a class="docs-heading-anchor-permalink" href="#SparseMatrixAssemblers" title="Permalink"></a></h2><p>Let&#39;s understand the main workflow for <code>SparseMatrixAssemblers</code> by looking at the <code>assemble_matrix</code> method:</p><pre><code class="language-julia hljs">  function assemble_matrix(a::SparseMatrixAssembler,matdata)
1   m1 = nz_counter(get_matrix_builder(a),(get_rows(a),get_cols(a)))
2   symbolic_loop_matrix!(m1,a,matdata)
3   m2 = nz_allocation(m1)
4   numeric_loop_matrix!(m2,a,matdata)
5   m3 = create_from_nz(m2)
    return m3
  end</code></pre><p>By line number:</p><ol><li>We retrieve the <code>SparseMatrixBuilder/ArrayBuilder</code> from the assembler. This structure has information on which type of array will be allocated at the end. For instance CSR vs CSC sparse matrix storage, which type of element type the array should hold (Float64, Float32,...), etc... With this information, we create a non-zero counter object <code>m1</code>, which will manage the counting of sparse entries and eventually the allocation of the array.</li><li>We do a symbolic loop over the matrix contributions in <code>matdata</code>. During this loop, we save the row/col indexes of the non-zeros that will be present in the final matrix.</li><li>We allocate the necessary space for the nonzero entries we have counted. In the case of CSR and CSC storage types, we do not allocate the final matrix yet but rather do everything in COO format (which is more efficient for random access assembly). <code>m2</code> is now an array allocator object.</li><li>We do a second loop over the matrix contributions in <code>matdata</code>, During this loop, we actually assemble the entries that will end up in the matrix.</li><li>We use the matrix allocator to allocate and fill the final sparse matrix.</li></ol><p>So the objects involved and the overall workflow is given by</p><pre><code class="language-md hljs">SparseMatrixBuilder -&gt; ArrayCounter -&gt; ArrayAllocator -&gt; Array</code></pre><p>The second part of the puzzle is given by the loops over the data, i.e <code>symbolic_loop_X!</code> and <code>numeric_loop_X!</code>. Both loops are quite similar, so we will focus on the numeric loop, which is implemented in the following function:</p><pre><code class="language-julia hljs">  function numeric_loop_matrix!(A,a::SparseMatrixAssembler,matdata)
    get_mat(a::Tuple) = a[1]
    get_mat(a) = a
    if LoopStyle(A) == DoNotLoop()
      return A
    end
1   strategy = get_assembly_strategy(a)
    for (cellmat,_cellidsrows,_cellidscols) in zip(matdata...)
2     cellidsrows = map_cell_rows(strategy,_cellidsrows)
2     cellidscols = map_cell_cols(strategy,_cellidscols)
      @assert length(cellidscols) == length(cellidsrows)
      if length(cellidscols) &gt; 0
        rows_cache = array_cache(cellidsrows)
        cols_cache = array_cache(cellidscols)
        mat1 = get_mat(first(cellmat))
        rows1 = getindex!(rows_cache,cellidsrows,1)
        cols1 = getindex!(cols_cache,cellidscols,1)
3       add! = AddEntriesMap(+)
3       add_cache = return_cache(add!,A,mat1,rows1,cols1)
3       caches = add_cache, vals_cache, rows_cache, cols_cache
3       _numeric_loop_matrix!(A,caches,cellmat,cellidsrows,cellidscols)
      end
    end
    A
  end

  @noinline function _symbolic_loop_matrix!(A,caches,cell_rows,cell_cols,mat1)
    touch_cache, rows_cache, cols_cache = caches
    touch! = TouchEntriesMap()
4   for cell in 1:length(cell_cols)
4     rows = getindex!(rows_cache,cell_rows,cell)
4     cols = getindex!(cols_cache,cell_cols,cell)
4     vals = getindex!(vals_cache,cell_vals,cell)
4     evaluate!(add_cache,add!,mat,vals,rows,cols)
4   end
  end</code></pre><p>By line number:</p><ol><li>We retrieve the <code>AssemblyStrategy</code> object from the assembler. This object contains all the information necessary to map the DoF ids from our mesh to the final columns/rows of the matrix. In serial this map is almost always the identity, but in parallel it is crucial to handle ghosts and local/global indexes.</li><li>We use the col/row maps in strategy to map the cell DoF ids in each cell contribution to the corresponding rows/cols in the final matrix.</li><li>We prepare a <code>TouchEntriesMap</code> (symbolic loop) or <code>AddEntriesMap</code> (numeric loop). These maps will be executed on each cell contribution, and are the ones responsible to allocate/assemble the contributions on the array counter.</li><li>For each cell, we retrieve the rows, cols and values and execute the map on these. This will allocate/assemble the contributions of this cell into the counter. In the case of <code>MultiFieldFESpaces</code>,  the cell indices <code>rows</code>/<code>cols</code> will be <code>VectorBlocks</code> with as many blocks as fields the <code>MultiFieldFESpace</code> has and <code>vals</code> will be a <code>MatrixBlock</code> with an array of blocks of size (# blocks in rows, # blocks in cols). The <code>TouchEntriesMap</code> and<code>AddEntriesMap</code> maps are specialised on these types, and assemble all blocks into the same <code>ArrayCounter</code>.</li></ol><h2 id="BlockSparseMatrixAssemblers"><a class="docs-heading-anchor" href="#BlockSparseMatrixAssemblers">BlockSparseMatrixAssemblers</a><a id="BlockSparseMatrixAssemblers-1"></a><a class="docs-heading-anchor-permalink" href="#BlockSparseMatrixAssemblers" title="Permalink"></a></h2><p>To activate the block assemblers, we have created a new <code>MultiFieldStyle</code> called <code>BlockMultiFieldStyle</code>.  The purpose of this style is two-fold:</p><ol><li>It activates the block assembly automatically when calling <code>SparseMatrixAssembler</code>, so that the everything fits with the high-level API.</li><li>It manages the numbering of the cell DoFs when performing the integrals, ensuring the DoFs ids are local to each block.</li></ol><p>To create a block-assembled <code>MultiFieldFESpace</code>, you can use the following constructor:</p><pre><code class="language-julia hljs">mfs = BlockMultiFieldStyle()
Yb  = MultiFieldFESpace(tests;style=mfs)
Xb  = MultiFieldFESpace(trials;style=mfs)</code></pre><p>By default, the final matrix and vector will have a block for each input <code>FESpace</code>. However, you can introduce some parameters when building your <code>BlockMultiFieldStyle</code> so that multiple fields are assembled in the same block (see section B).</p><h3 id="A)-One-to-one-Block-FESpace-correspondence"><a class="docs-heading-anchor" href="#A)-One-to-one-Block-FESpace-correspondence">A) One to one Block &lt;-&gt; FESpace correspondence</a><a id="A)-One-to-one-Block-FESpace-correspondence-1"></a><a class="docs-heading-anchor-permalink" href="#A)-One-to-one-Block-FESpace-correspondence" title="Permalink"></a></h3><p>The design of <code>BlockSparseMatrixAssemblers</code> is quite simple: Instead of having a single <code>SparseMatrixBuilder</code>, <code>ArrayCounter</code> and<code>Array</code> in which we assemble the entries coming from all fields in the <code>MultiFieldFESpace</code>, the assembler will create one of these objects for each final block and put them in a <code>ArrayBlock</code> object. We will then dispatch on the <code>ArrayBlock</code> type so that the contributions from each field is assembled in the block we want.</p><p>For instance, for the <code>nz_counter</code> function we dispatch as follows:</p><pre><code class="language-julia hljs">function Algebra.nz_counter(builder::MatrixBlock,axs)
  s = size(builder)
  rows = axs[1]
  cols = axs[2]
  counters = [nz_counter(builder.array[i,j],(rows[i],cols[j])) for i in 1:s[1], j in 1:s[2]]
  return ArrayBlock(counters,fill(true,size(counters)))
end</code></pre><p>In this function, the variable <code>builder</code> is a <code>MatrixBlock{&lt;:ArrayBuilder}</code>, which holds an array with the array builders for each final block. We then simply select the rows/cols for each of the blocks and apply the <code>nz_counter</code> function to the corresponding <code>ArrayBuilder</code> ,  then return a <code>MatrixBlock{&lt;:ArrayCounter}</code> which holds the array counters for each block. Similar dispatches are provided for <code>nz_allocation</code>, <code>create_from_nz</code>, <code>map_cell_rows</code> and <code>map_cell_cols</code>.</p><p>We also specialise the evaluation of the <code>TouchEntriesMap</code> and<code>AddEntriesMap</code> maps when the counters are <code>BlockArrays</code>. For instance, let&#39;s have a look at the following function:</p><pre><code class="language-julia hljs"># A) Default implementation for MultiFieldFESpaces
function Fields.evaluate!(k::AddEntriesMap,A,v::MatrixBlock,I::VectorBlock,J::VectorBlock)
  ni,nj = size(v.touched)
  for j in 1:nj
    for i in 1:ni
      if v.touched[i,j]
        evaluate!(cache[i,j],k,A,v.array[i,j],I.array[i],J.array[j])
      end
    end
  end
end

# B) Dispatching for block assemblers
function Fields.evaluate!(k::AddEntriesMap,A::MatrixBlock,v::MatrixBlock,I::VectorBlock,J::VectorBlock)
  ni,nj = size(v.touched)
  for j in 1:nj
    for i in 1:ni
      if v.touched[i,j]
        evaluate!(cache[i,j],k,A.array[i,j],v.array[i,j],I.array[i],J.array[j])
      end
    end
  end
end</code></pre><p>In the monolithic assembly of <code>MultiFieldFESpaces</code>, the variable <code>A</code> is an <code>ArrayCounter</code>. As you can see, all contribution blocks (coming from different fields) are assembled into the same <code>ArrayCounter</code>. The block-assembly counterpart will have the input <code>A</code> be a <code>MatrixBlock{&lt;:ArrayCounter}</code>, and assembles each contribution block to it&#39;s corresponding <code>ArrayCounter</code> (notice the <code>A.array[i,j]</code>).</p><h3 id="B)-Assembling-multiple-FE-Fields-into-the-same-Block"><a class="docs-heading-anchor" href="#B)-Assembling-multiple-FE-Fields-into-the-same-Block">B) Assembling multiple FE Fields into the same Block</a><a id="B)-Assembling-multiple-FE-Fields-into-the-same-Block-1"></a><a class="docs-heading-anchor-permalink" href="#B)-Assembling-multiple-FE-Fields-into-the-same-Block" title="Permalink"></a></h3><p>The <code>BlockMultiFieldStyle</code> constructor can take up to three parameters:</p><ol><li><code>NB</code> :: Integer, representing the number of final blocks. Then the matrix and vector will have <code>NBxNB</code> and <code>NB</code> blocks respectively.</li><li><code>SB</code> :: Tuple of integers, of length <code>NB</code>.  In each position, <code>SB[ib]</code> is the number of fields that will be assembled in that block.</li><li><code>P</code>  :: Tuple of integers, of length the number of fields. This represents a field permutation, such that the fields will be reordered as<code>[P[1],P[2],....,P[n]]</code>.</li></ol><p>Using this three parameters, one can assemble an arbitrary number of fields into any number of blocks.</p><p><strong>Example</strong>: Consider we are solving an MHD problem with variables <code>(u,p,j,q)</code> , i.e (fluid velocity, fluid pressure, magnetic current, electric potential). Although the variables are in this specific order in the <code>MultiFieldFESpace</code>, we want to build a block-preconditioner that solves <code>(u,j)</code> together in a single block then <code>p</code> and <code>q</code> separately in two other blocks. Then we would need to assemble our system using <code>NB=3</code>, <code>SB=(2,1,1)</code> and <code>P=(1,3,2,4)</code>. With this configuration, we will create 3 blocks. The first block will have size 2 and hold variables <code>[P[1],P[2]] = [1,3] = [u,j]</code>. The second block will have size 1 and hold variables <code>[P[3]] = [2] = [p]</code>. Finally, the third block will hold variables <code>[P[4]] = [4] = [q]</code>.</p><p>In terms of implementation, everything is the same. We use <code>ArrayBlockViews</code> (which is a view counterpart of <code>ArrayBlock</code>) so that an array of <code>NBxNB</code> array builders / array counters can be indexed using the field indexes. This allows us to use the same dispatches as we had in part A.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Adaptivity/">« Gridap.Adaptivity</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 9 December 2024 06:01">Monday 9 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
